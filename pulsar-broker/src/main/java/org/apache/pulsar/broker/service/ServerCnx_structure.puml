@startuml

/' diagram meta data start
config=StructureConfiguration;
{
  "projectClassification": {
    "searchMode": "OpenProject", // OpenProject, AllProjects
    "includedProjects": "",
    "pathEndKeywords": "*.impl",
    "isClientPath": "",
    "isClientName": "",
    "isTestPath": "",
    "isTestName": "",
    "isMappingPath": "",
    "isMappingName": "",
    "isDataAccessPath": "",
    "isDataAccessName": "",
    "isDataStructurePath": "",
    "isDataStructureName": "",
    "isInterfaceStructuresPath": "",
    "isInterfaceStructuresName": "",
    "isEntryPointPath": "",
    "isEntryPointName": "",
    "treatFinalFieldsAsMandatory": false
  },
  "graphRestriction": {
    "classPackageExcludeFilter": "",
    "classPackageIncludeFilter": "",
    "classNameExcludeFilter": "",
    "classNameIncludeFilter": "",
    "methodNameExcludeFilter": "",
    "methodNameIncludeFilter": "",
    "removeByInheritance": "", // inheritance/annotation based filtering is done in a second step
    "removeByAnnotation": "",
    "removeByClassPackage": "", // cleanup the graph after inheritance/annotation based filtering is done
    "removeByClassName": "",
    "cutMappings": false,
    "cutEnum": true,
    "cutTests": true,
    "cutClient": true,
    "cutDataAccess": false,
    "cutInterfaceStructures": false,
    "cutDataStructures": false,
    "cutGetterAndSetter": true,
    "cutConstructors": true
  },
  "graphTraversal": {
    "forwardDepth": 6,
    "backwardDepth": 6,
    "classPackageExcludeFilter": "",
    "classPackageIncludeFilter": "",
    "classNameExcludeFilter": "",
    "classNameIncludeFilter": "",
    "methodNameExcludeFilter": "",
    "methodNameIncludeFilter": "",
    "hideMappings": false,
    "hideDataStructures": false,
    "hidePrivateMethods": true,
    "hideInterfaceCalls": true, // indirection: implementation -> interface (is hidden) -> implementation
    "onlyShowApplicationEntryPoints": false, // root node is included
    "useMethodCallsForStructureDiagram": "ForwardOnly" // ForwardOnly, BothDirections, No
  },
  "details": {
    "aggregation": "GroupByClass", // ByClass, GroupByClass, None
    "showClassGenericTypes": true,
    "showMethods": true,
    "showMethodParameterNames": true,
    "showMethodParameterTypes": true,
    "showMethodReturnType": true,
    "showPackageLevels": 2,
    "showDetailedClassStructure": true
  },
  "rootClass": "org.apache.pulsar.broker.service.ServerCnx",
  "extensionCallbackMethod": "" // qualified.class.name#methodName - signature: public static String method(String)
}
diagram meta data end '/



digraph g {
    rankdir="TB"
    splines=polyline
    

'nodes 
subgraph cluster_1411517106 { 
   	label=apache
	labeljust=l
	fillcolor="#ececec"
	style=filled
   
   subgraph cluster_523310109 { 
   	label=pulsar
	labeljust=l
	fillcolor="#d8d8d8"
	style=filled
   
   AbstractBaseDispatcher1718290011[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)AbstractBaseDispatcher</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   dispatchThrottlingOnBatchMessageEnabled: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   entryFilters: ImmutableList&lt;EntryFilterWithClassLoader&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >#   filterContext: FilterContext [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   serviceConfig: ServiceConfiguration [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   subscription: Subscription [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># computeReadLimits(messagesToRead: int, availablePermitsOnMsg: int, bytesToRead: long, availablePermitsOnByte: long): Pair&lt;Integer, Long&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- fillContext(context: FilterContext, msgMetadata: MessageMetadata, subscription: Subscription)</TD></TR>
<TR><TD ALIGN="LEFT" >+ filterEntriesForConsumer(entries: List&lt;Entry&gt;, batchSizes: EntryBatchSizes, sendMessageInfo: SendMessageInfo, indexesAcks: EntryBatchIndexesAcks, cursor: ManagedCursor, isReplayRead: boolean): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ filterEntriesForConsumer(entryWrapper: Optional&lt;EntryWrapper[]&gt;, entryWrapperOffset: int, entries: List&lt;Entry&gt;, batchSizes: EntryBatchSizes, sendMessageInfo: SendMessageInfo, indexesAcks: EntryBatchIndexesAcks, cursor: ManagedCursor, isReplayRead: boolean): int</TD></TR>
<TR><TD ALIGN="LEFT" >- getFilterResult(filterContext: FilterContext, entry: Entry, entryFilters: ImmutableList&lt;EntryFilterWithClassLoader&gt;): FilterResult</TD></TR>
<TR><TD ALIGN="LEFT" ># isConsumersExceededOnSubscription(topic: AbstractTopic, consumerSize: int): boolean</TD></TR>
<TR><TD ALIGN="LEFT" ># peekStickyKey(metadataAndPayload: ByteBuf): byte[]</TD></TR>
<TR><TD ALIGN="LEFT" >- processReplicatedSubscriptionSnapshot(pos: PositionImpl, headersAndPayload: ByteBuf)</TD></TR>
<TR><TD ALIGN="LEFT" ># reScheduleRead()</TD></TR>
<TR><TD ALIGN="LEFT" ># reachDispatchRateLimit(dispatchRateLimiter: DispatchRateLimiter): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ resetCloseFuture()</TD></TR>
<TR><TD ALIGN="LEFT" ># updateEntryWrapperWithMetadata(entryWrappers: EntryWrapper[], entries: List&lt;Entry&gt;): int</TD></TR>
<TR><TD ALIGN="LEFT" ># updateMessagesToRead(dispatchRateLimiter: DispatchRateLimiter, messagesToRead: int, bytesToRead: long): Pair&lt;Integer, Long&gt;</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

AbstractBatchMessageContainer12001400[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)AbstractBatchMessageContainer</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   compressionType: CompressionType [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   compressor: CompressionCodec [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   currentBatchSizeBytes: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   currentTxnidLeastBits: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   currentTxnidMostBits: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   maxBatchSize: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   maxBytesInBatch: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   maxNumMessagesInBatch: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   numMessagesInBatch: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   producer: ProducerImpl [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   producerName: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   topicName: String [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ createOpSendMsg(): OpSendMsg</TD></TR>
<TR><TD ALIGN="LEFT" >+ createOpSendMsgs(): List&lt;OpSendMsg&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ hasSameTxn(msg: MessageImpl&lt;?&gt;): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ haveEnoughSpace(msg: MessageImpl&lt;?&gt;): boolean</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

AbstractDispatcherMultipleConsumers1718290011[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)AbstractDispatcherMultipleConsumers</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   consumerList: CopyOnWriteArrayList&lt;Consumer&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >#   consumerSet: ObjectSet&lt;Consumer&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   currentConsumerRoundRobinIndex: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   isClosed: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   random: Random [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ canUnsubscribe(consumer: Consumer): boolean</TD></TR>
<TR><TD ALIGN="LEFT" ># cancelPendingRead()</TD></TR>
<TR><TD ALIGN="LEFT" >- getConsumerFromHigherPriority(targetPriority: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >- getFirstConsumerIndexOfPriority(targetPriority: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >- getNextConsumerFromSameOrLowerLevel(currentRoundRobinIndex: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ isConsumerAvailable(consumer: Consumer): boolean</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

AbstractDispatcherSingleActiveConsumer1718290011[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)AbstractDispatcherSingleActiveConsumer</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   activeConsumer: Consumer [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   closeFuture: CompletableFuture&lt;Void&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   consumers: CopyOnWriteArrayList&lt;Consumer&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >#   cursor: ManagedCursor [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   isClosed: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   isFirstRead: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   isKeyHashRangeFiltered: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   partitionIndex: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   stickyKeyConsumerSelector: StickyKeyConsumerSelector [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   subscriptionType: SubType [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   topicName: String [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ addConsumer(consumer: Consumer)</TD></TR>
<TR><TD ALIGN="LEFT" >+ canUnsubscribe(consumer: Consumer): boolean</TD></TR>
<TR><TD ALIGN="LEFT" ># cancelPendingRead()</TD></TR>
<TR><TD ALIGN="LEFT" >+ close(): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ disconnectActiveConsumers(isResetCursor: boolean): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ disconnectAllConsumers(isResetCursor: boolean): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># notifyActiveConsumerChanged(activeConsumer: Consumer)</TD></TR>
<TR><TD ALIGN="LEFT" ># pickAndScheduleActiveConsumer(): boolean</TD></TR>
<TR><TD ALIGN="LEFT" ># readMoreEntries(consumer: Consumer)</TD></TR>
<TR><TD ALIGN="LEFT" >+ removeConsumer(consumer: Consumer)</TD></TR>
<TR><TD ALIGN="LEFT" >+ reset()</TD></TR>
<TR><TD ALIGN="LEFT" >+ resetCloseFuture()</TD></TR>
<TR><TD ALIGN="LEFT" ># scheduleReadOnActiveConsumer()</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

AbstractGenericSchema75672144[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)AbstractGenericSchema</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   fields: List&lt;Field&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >#   useProvidedSchemaAsReaderSchema: boolean [1]</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

AbstractMetadataStore437280412[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)AbstractMetadataStore</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   childrenCache: AsyncLoadingCache&lt;String, List&lt;String&gt;&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   executor: ScheduledExecutorService [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   existsCache: AsyncLoadingCache&lt;String, Boolean&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   isConnected: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   listeners: CopyOnWriteArrayList&lt;Consumer&lt;Notification&gt;&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   metadataCaches: CopyOnWriteArrayList&lt;MetadataCacheImpl&lt;?&gt;&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   sessionListeners: CopyOnWriteArrayList&lt;Consumer&lt;SessionEvent&gt;&gt; [0..*]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ accept(n: Notification)</TD></TR>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ delete(path: String, expectedVersion: Optional&lt;Long&gt;): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ deleteRecursive(path: String): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># execute(task: Runnable, future: CompletableFuture&lt;?&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ exists(path: String): CompletableFuture&lt;Boolean&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># existsFromStore(path: String): CompletableFuture&lt;Boolean&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ get(path: String): CompletableFuture&lt;Optional&lt;GetResult&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getChildren(path: String): CompletableFuture&lt;List&lt;String&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># getChildrenFromStore(path: String): CompletableFuture&lt;List&lt;String&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getMetadataCache(clazz: Class&lt;T&gt;): MetadataCache&lt;T&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getMetadataCache(typeRef: TypeReference&lt;T&gt;): MetadataCache&lt;T&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getMetadataCache(serde: MetadataSerde&lt;T&gt;): MetadataCache&lt;T&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ invalidateAll()</TD></TR>
<TR><TD ALIGN="LEFT" ># isValidPath(path: String): boolean</TD></TR>
<TR><TD ALIGN="LEFT" ># notifyParentChildrenChanged(path: String)</TD></TR>
<TR><TD ALIGN="LEFT" ># parent(path: String): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ put(path: String, value: byte[], expectedVersion: Optional&lt;Long&gt;): CompletableFuture&lt;Stat&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ put(path: String, data: byte[], optExpectedVersion: Optional&lt;Long&gt;, options: EnumSet&lt;CreateOption&gt;): CompletableFuture&lt;Stat&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># receivedNotification(notification: Notification): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># receivedSessionEvent(event: SessionEvent)</TD></TR>
<TR><TD ALIGN="LEFT" >+ registerListener(listener: Consumer&lt;Notification&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ registerSessionListener(listener: Consumer&lt;SessionEvent&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" ># storeDelete(path: String, expectedVersion: Optional&lt;Long&gt;): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># storeGet(path: String): CompletableFuture&lt;Optional&lt;GetResult&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># storePut(path: String, data: byte[], optExpectedVersion: Optional&lt;Long&gt;, options: EnumSet&lt;CreateOption&gt;): CompletableFuture&lt;Stat&gt;</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

AbstractMultiVersionReader657740342[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)AbstractMultiVersionReader&lt;T&gt;</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   providerSchemaReader: SchemaReader&lt;T&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   readerCache: LoadingCache&lt;BytesSchemaVersion, SchemaReader&lt;T&gt;&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   schemaInfoProvider: SchemaInfoProvider [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># getSchemaInfoByVersion(schemaVersion: byte[]): SchemaInfo</TD></TR>
<TR><TD ALIGN="LEFT" >+ getSchemaReader(schemaVersion: byte[]): SchemaReader&lt;T&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># loadReader(schemaVersion: BytesSchemaVersion): SchemaReader&lt;T&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ read(bytes: byte[], offset: int, length: int): T</TD></TR>
<TR><TD ALIGN="LEFT" >+ read(inputStream: InputStream): T</TD></TR>
<TR><TD ALIGN="LEFT" >+ read(inputStream: InputStream, schemaVersion: byte[]): T</TD></TR>
<TR><TD ALIGN="LEFT" >+ read(bytes: byte[], schemaVersion: byte[]): T</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

AbstractReplicator1718290011[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)AbstractReplicator</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   backOff: Backoff [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   brokerService: BrokerService [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   client: PulsarClientImpl [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   localCluster: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   producer: ProducerImpl [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   producerBuilder: ProducerBuilder&lt;byte[]&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   producerQueueSize: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   remoteCluster: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   replicationClient: PulsarClientImpl [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   replicatorPrefix: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   state: State [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   topicName: String [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># closeProducerAsync(): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># disableReplicatorRead()</TD></TR>
<TR><TD ALIGN="LEFT" >+ disconnect(): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ disconnect(failIfHasBacklog: boolean): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getRemoteCluster(remoteCursor: String): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ getReplicatorName(replicatorPrefix: String, cluster: String): String</TD></TR>
<TR><TD ALIGN="LEFT" ># readEntries(producer: Producer&lt;byte[]&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ remove(): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ startProducer()</TD></TR>
<TR><TD ALIGN="LEFT" >+ validatePartitionedTopicAsync(topic: String, brokerService: BrokerService): CompletableFuture&lt;Void&gt;</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

AbstractSchema1622012615[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)AbstractSchema&lt;T&gt;</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ atSchemaVersion(schemaVersion: byte[]): Schema&lt;?&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ clone(): Schema&lt;T&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ decode(byteBuf: ByteBuf): T</TD></TR>
<TR><TD ALIGN="LEFT" >+ decode(byteBuf: ByteBuf, schemaVersion: byte[]): T</TD></TR>
<TR><TD ALIGN="LEFT" ># validate(byteBuf: ByteBuf)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

AbstractStructSchema1622012615[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)AbstractStructSchema&lt;T&gt;</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   reader: SchemaReader&lt;T&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   schemaInfo: SchemaInfo [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   schemaInfoProvider: SchemaInfoProvider [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   writer: SchemaWriter&lt;T&gt; [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ atSchemaVersion(schemaVersion: byte[]): Schema&lt;T&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ decode(bytes: byte[]): T</TD></TR>
<TR><TD ALIGN="LEFT" >+ decode(bytes: byte[], schemaVersion: byte[]): T</TD></TR>
<TR><TD ALIGN="LEFT" >+ decode(byteBuf: ByteBuf): T</TD></TR>
<TR><TD ALIGN="LEFT" >+ decode(byteBuf: ByteBuf, schemaVersion: byte[]): T</TD></TR>
<TR><TD ALIGN="LEFT" >+ encode(message: T): byte[]</TD></TR>
<TR><TD ALIGN="LEFT" >- getAbstractStructSchemaAtVersion(schemaVersion: byte[], schemaInfo: SchemaInfo): AbstractStructSchema&lt;T&gt;</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

AbstractTopic1718290011[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)AbstractTopic</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   addEntryLatencyStatsUsec: StatsBuckets [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   brokerService: BrokerService [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   bytesInCounter: LongAdder [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   exclusiveProducerName: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   hasBatchMessagePublished: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   hasExclusiveProducer: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   isAllowAutoUpdateSchema: Boolean [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   isEncryptionRequired: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   isFenced: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   lastActive: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   lock: ReentrantReadWriteLock [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   msgInCounter: LongAdder [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   preciseTopicPublishRateLimitingEnable: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   producers: ConcurrentHashMap&lt;String, Producer&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >#   publishRateLimitedTimes: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   replicatorPrefix: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   resourceGroupPublishLimiter: ResourceGroupPublishLimiter [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   resourceGroupRateLimitingEnabled: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   schemaValidationEnforced: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   topic: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   topicEpoch: Optional&lt;Long&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   topicPolicies: HierarchyTopicPolicies [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   topicPublishRateLimiter: PublishRateLimiter [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   usageCount: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   waitingExclusiveProducers: Queue&lt;Pair&lt;Producer, CompletableFuture&lt;Optional&lt;Long&gt;&gt;&gt;&gt; [0..*]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># addConsumerToSubscription(subscription: Subscription, consumer: Consumer): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ addProducer(producer: Producer, producerQueuedFuture: CompletableFuture&lt;Void&gt;): CompletableFuture&lt;Optional&lt;Long&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ addSchema(schema: SchemaData): CompletableFuture&lt;SchemaVersion&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- allowAutoUpdateSchema(): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ checkSchemaCompatibleForConsumer(schema: SchemaData): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># checkTopicFenced()</TD></TR>
<TR><TD ALIGN="LEFT" >+ checkTopicPublishThrottlingRate()</TD></TR>
<TR><TD ALIGN="LEFT" >+ currentUsageCount(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ decrementUsageCount()</TD></TR>
<TR><TD ALIGN="LEFT" >+ deletePartitionedTopicMetadataWhileInactive(): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ deleteSchema(): CompletableFuture&lt;SchemaVersion&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ deleteTopicPolicies(): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ disableCnxAutoRead()</TD></TR>
<TR><TD ALIGN="LEFT" ># disableProducerRead()</TD></TR>
<TR><TD ALIGN="LEFT" >+ enableCnxAutoRead()</TD></TR>
<TR><TD ALIGN="LEFT" ># enableProducerReadForPublishBufferLimiting()</TD></TR>
<TR><TD ALIGN="LEFT" ># enableProducerReadForPublishRateLimiting()</TD></TR>
<TR><TD ALIGN="LEFT" >- formatSchemaCompatibilityStrategy(strategy: SchemaCompatibilityStrategy): SchemaCompatibilityStrategy</TD></TR>
<TR><TD ALIGN="LEFT" ># getActiveConsumer(subscription: Subscription): Consumer</TD></TR>
<TR><TD ALIGN="LEFT" >+ getNumberOfSameAddressConsumers(clientAddress: String): int</TD></TR>
<TR><TD ALIGN="LEFT" ># getNumberOfSameAddressConsumers(clientAddress: String, subscriptions: List&lt;? extends Subscription&gt;): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ getNumberOfSameAddressProducers(clientAddress: String): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ handleConsumerAdded(subscriptionName: String, consumerName: String)</TD></TR>
<TR><TD ALIGN="LEFT" ># handleProducerRemoved(producer: Producer)</TD></TR>
<TR><TD ALIGN="LEFT" >+ increasePublishLimitedTimes(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ incrementPublishCount(numOfMessages: int, msgSizeInBytes: long)</TD></TR>
<TR><TD ALIGN="LEFT" ># incrementTopicEpoch(currentEpoch: Optional&lt;Long&gt;): CompletableFuture&lt;Long&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># incrementTopicEpochIfNeeded(producer: Producer, producerQueuedFuture: CompletableFuture&lt;Void&gt;): CompletableFuture&lt;Optional&lt;Long&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># internalAddProducer(producer: Producer)</TD></TR>
<TR><TD ALIGN="LEFT" ># isExceedMaximumMessageSize(size: int, publishContext: PublishContext): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ isResourceGroupPublishRateExceeded(numMessages: int, bytes: int): boolean</TD></TR>
<TR><TD ALIGN="LEFT" ># isSameAddressConsumersExceededOnTopic(consumer: Consumer): boolean</TD></TR>
<TR><TD ALIGN="LEFT" ># isSameAddressProducersExceeded(producer: Producer): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ isTopicPublishRateExceeded(numberMessages: int, bytes: int): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >- isUserProvidedProducerName(producer: Producer): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ markBatchMessagePublished()</TD></TR>
<TR><TD ALIGN="LEFT" >- normalize(dispatchRate: DispatchRateImpl): DispatchRateImpl</TD></TR>
<TR><TD ALIGN="LEFT" >- publishRateInBroker(config: ServiceConfiguration): PublishRate</TD></TR>
<TR><TD ALIGN="LEFT" >+ recordAddLatency(latency: long, unit: TimeUnit)</TD></TR>
<TR><TD ALIGN="LEFT" ># registerTopicPolicyListener()</TD></TR>
<TR><TD ALIGN="LEFT" >+ removeProducer(producer: Producer)</TD></TR>
<TR><TD ALIGN="LEFT" >+ resetBrokerPublishCountAndEnableReadIfRequired(doneBrokerReset: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ resetTopicPublishCountAndEnableReadIfRequired()</TD></TR>
<TR><TD ALIGN="LEFT" ># setTopicEpoch(newEpoch: long): CompletableFuture&lt;Long&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- subTypeStringsToEnumSet(getSubscriptionTypesEnabled: Set&lt;String&gt;): EnumSet&lt;SubType&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- subscriptionDispatchRateInBroker(config: ServiceConfiguration): DispatchRateImpl</TD></TR>
<TR><TD ALIGN="LEFT" >- tryOverwriteOldProducer(oldProducer: Producer, newProducer: Producer)</TD></TR>
<TR><TD ALIGN="LEFT" ># unregisterTopicPolicyListener()</TD></TR>
<TR><TD ALIGN="LEFT" >+ updateBrokerSubscriptionDispatchRate()</TD></TR>
<TR><TD ALIGN="LEFT" >+ updateBrokerSubscriptionTypesEnabled()</TD></TR>
<TR><TD ALIGN="LEFT" >- updateNamespacePublishRate(namespacePolicies: Policies, cluster: String)</TD></TR>
<TR><TD ALIGN="LEFT" >- updateNamespaceSubscriptionDispatchRate(namespacePolicies: Policies, cluster: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ updatePublishDispatcher()</TD></TR>
<TR><TD ALIGN="LEFT" >+ updateResourceGroupLimiter(optPolicies: Optional&lt;Policies&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >- updateSchemaCompatibilityStrategyNamespaceValue(namespacePolicies: Policies)</TD></TR>
<TR><TD ALIGN="LEFT" ># updateTopicPolicy(data: TopicPolicies)</TD></TR>
<TR><TD ALIGN="LEFT" >- updateTopicPolicyByBrokerConfig()</TD></TR>
<TR><TD ALIGN="LEFT" ># updateTopicPolicyByNamespacePolicy(namespacePolicies: Policies)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

AddEntryMetadataException1254029274[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)AddEntryMetadataException</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

AdminResource2119895947[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)AdminResource</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   namespaceName: NamespaceName [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   topicName: TopicName [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># bookKeeper(): BookKeeper</TD></TR>
<TR><TD ALIGN="LEFT" ># checkArgument(b: boolean, errorMessage: String)</TD></TR>
<TR><TD ALIGN="LEFT" ># checkBacklogQuota(quota: BacklogQuota, retention: RetentionPolicies): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ checkNotNull(reference: T): T</TD></TR>
<TR><TD ALIGN="LEFT" ># checkNotNull(o: Object, errorMessage: String)</TD></TR>
<TR><TD ALIGN="LEFT" ># checkTopicExistsAsync(topicName: TopicName): CompletableFuture&lt;Boolean&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># checkTopicLevelPolicyEnable()</TD></TR>
<TR><TD ALIGN="LEFT" ># clusters(): Set&lt;String&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># dispatchRate(): DispatchRateImpl</TD></TR>
<TR><TD ALIGN="LEFT" ># domain(): String</TD></TR>
<TR><TD ALIGN="LEFT" ># fetchPartitionedTopicMetadata(pulsar: PulsarService, topicName: TopicName): PartitionedTopicMetadata</TD></TR>
<TR><TD ALIGN="LEFT" ># fetchPartitionedTopicMetadataCheckAllowAutoCreation(pulsar: PulsarService, topicName: TopicName): PartitionedTopicMetadata</TD></TR>
<TR><TD ALIGN="LEFT" ># getNamespacePolicies(namespaceName: NamespaceName): Policies</TD></TR>
<TR><TD ALIGN="LEFT" ># getNamespacePolicies(tenant: String, cluster: String, namespace: String): Policies</TD></TR>
<TR><TD ALIGN="LEFT" ># getNamespacePoliciesAsync(namespaceName: NamespaceName): CompletableFuture&lt;Policies&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># getNamespaceReplicatedClusters(namespaceName: NamespaceName): Set&lt;String&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># getPartitionedTopicList(topicDomain: TopicDomain): List&lt;String&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># getPartitionedTopicMetadata(topicName: TopicName, authoritative: boolean, checkAllowAutoCreation: boolean): PartitionedTopicMetadata</TD></TR>
<TR><TD ALIGN="LEFT" ># getPartitionedTopicMetadataAsync(topicName: TopicName, authoritative: boolean, checkAllowAutoCreation: boolean): CompletableFuture&lt;PartitionedTopicMetadata&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># getTopicPartitionList(topicDomain: TopicDomain): List&lt;String&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># getTopicPoliciesAsyncWithRetry(topicName: TopicName): CompletableFuture&lt;Optional&lt;TopicPolicies&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># getTopicPoliciesAsyncWithRetry(topicName: TopicName, isGlobal: boolean): CompletableFuture&lt;Optional&lt;TopicPolicies&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># internalCreatePartitionedTopic(asyncResponse: AsyncResponse, numPartitions: int, createLocalTopicOnly: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" ># internalCreatePartitionedTopic(asyncResponse: AsyncResponse, numPartitions: int, createLocalTopicOnly: boolean, properties: Map&lt;String, String&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" ># isManagedLedgerNotFoundException(e: Exception): boolean</TD></TR>
<TR><TD ALIGN="LEFT" ># isNamespaceReplicated(namespaceName: NamespaceName): boolean</TD></TR>
<TR><TD ALIGN="LEFT" ># isRedirectException(ex: Throwable): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ jsonMapper(): ObjectMapper</TD></TR>
<TR><TD ALIGN="LEFT" ># namespaceBacklogQuota(namespace: NamespaceName, backlogQuotaType: BacklogQuotaType): BacklogQuota</TD></TR>
<TR><TD ALIGN="LEFT" >- provisionPartitionedTopicPath(asyncResponse: AsyncResponse, numPartitions: int, createLocalTopicOnly: boolean, properties: Map&lt;String, String&gt;): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># replicatorDispatchRate(): DispatchRateImpl</TD></TR>
<TR><TD ALIGN="LEFT" ># resumeAsyncResponseExceptionally(asyncResponse: AsyncResponse, exception: Throwable)</TD></TR>
<TR><TD ALIGN="LEFT" ># subscribeRate(): SubscribeRate</TD></TR>
<TR><TD ALIGN="LEFT" ># subscriptionDispatchRate(): DispatchRateImpl</TD></TR>
<TR><TD ALIGN="LEFT" >- tryCreatePartitionAsync(partition: int, reuseFuture: CompletableFuture&lt;Void&gt;): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># tryCreatePartitionsAsync(numPartitions: int): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># validateAdminAccessForTenant(property: String)</TD></TR>
<TR><TD ALIGN="LEFT" ># validateBundleOwnership(property: String, cluster: String, namespace: String, authoritative: boolean, readOnly: boolean, bundle: NamespaceBundle)</TD></TR>
<TR><TD ALIGN="LEFT" ># validateClusterExists(cluster: String)</TD></TR>
<TR><TD ALIGN="LEFT" ># validateGlobalNamespaceOwnership()</TD></TR>
<TR><TD ALIGN="LEFT" ># validateNamespaceName(property: String, namespace: String)</TD></TR>
<TR><TD ALIGN="LEFT" ># validateNamespaceName(property: String, cluster: String, namespace: String)</TD></TR>
<TR><TD ALIGN="LEFT" ># validatePartitionedTopicMetadata(tenant: String, namespace: String, encodedTopic: String)</TD></TR>
<TR><TD ALIGN="LEFT" ># validatePartitionedTopicName(tenant: String, namespace: String, encodedTopic: String)</TD></TR>
<TR><TD ALIGN="LEFT" ># validatePersistencePolicies(persistence: PersistencePolicies)</TD></TR>
<TR><TD ALIGN="LEFT" ># validatePersistentTopicName(property: String, namespace: String, encodedTopic: String)</TD></TR>
<TR><TD ALIGN="LEFT" ># validatePersistentTopicName(property: String, cluster: String, namespace: String, encodedTopic: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ validatePoliciesReadOnlyAccess()</TD></TR>
<TR><TD ALIGN="LEFT" >+ validatePoliciesReadOnlyAccessAsync(): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ validateSuperUserAccess()</TD></TR>
<TR><TD ALIGN="LEFT" ># validateTopicName(property: String, namespace: String, encodedTopic: String)</TD></TR>
<TR><TD ALIGN="LEFT" ># validateTopicName(property: String, cluster: String, namespace: String, encodedTopic: String)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

AirliftUtils917667102[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)AirliftUtils</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># ensureAirliftSupported(encodedNio: ByteBuffer): ByteBuffer</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

AlreadyRunningException1254029274[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)AlreadyRunningException</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

AppendBrokerTimestampMetadataInterceptor2014195078[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)AppendBrokerTimestampMetadataInterceptor</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ intercept(brokerMetadata: BrokerEntryMetadata): BrokerEntryMetadata</TD></TR>
<TR><TD ALIGN="LEFT" >+ interceptWithNumberOfMessages(brokerMetadata: BrokerEntryMetadata, numberOfMessages: int): BrokerEntryMetadata</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

AppendIndexMetadataInterceptor2014195078[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)AppendIndexMetadataInterceptor</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   indexGenerator: AtomicLong [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ intercept(brokerMetadata: BrokerEntryMetadata): BrokerEntryMetadata</TD></TR>
<TR><TD ALIGN="LEFT" >+ interceptWithNumberOfMessages(brokerMetadata: BrokerEntryMetadata, numberOfMessages: int): BrokerEntryMetadata</TD></TR>
<TR><TD ALIGN="LEFT" >+ recoveryIndexGenerator(index: long)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

AuthData1605686738[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)AuthData</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   bytes: byte[] [0..*]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ of(bytes: byte[]): AuthData</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

AuthData297559756[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)AuthData</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   _authDataIdx: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _authDataLen: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _authMethodNameBufferIdx: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _authMethodNameBufferLen: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _bitField0: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _cachedSize: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _parsedBuffer: ByteBuf [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   authData: ByteBuf [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   authMethodName: String [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ clear(): AuthData</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearAuthData(): AuthData</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearAuthMethodName(): AuthData</TD></TR>
<TR><TD ALIGN="LEFT" >+ copyFrom(_other: AuthData): AuthData</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(_buffer: ByteBuf, _size: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(a: byte[])</TD></TR>
<TR><TD ALIGN="LEFT" >+ setAuthData(authData: byte[]): AuthData</TD></TR>
<TR><TD ALIGN="LEFT" >+ setAuthData(authData: ByteBuf): AuthData</TD></TR>
<TR><TD ALIGN="LEFT" >+ setAuthMethodName(authMethodName: String): AuthData</TD></TR>
<TR><TD ALIGN="LEFT" >+ toByteArray(): byte[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeTo(_b: ByteBuf): int</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

AuthPoliciesImpl480042356[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)AuthPoliciesImpl</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   namespaceAuthentication: Map&lt;String, Set&lt;AuthAction&gt;&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   subscriptionAuthentication: Map&lt;String, Set&lt;String&gt;&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   topicAuthentication: Map&lt;String, Map&lt;String, Set&lt;AuthAction&gt;&gt;&gt; [0..*]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ builder(): Builder</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

AuthenticationAthenz1053578162[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)AuthenticationAthenz</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   autoPrefetchEnabled: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   cachedRoleTokenLock: ReadWriteLock [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   cachedRoleTokenTimestamp: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   keyId: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   privateKey: PrivateKey [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   providerDomain: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   roleHeader: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   roleToken: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   tenantDomain: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   tenantService: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   ztsClient: ZTSClient [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   ztsUrl: String [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- cachedRoleTokenIsValid(): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ configure(encodedAuthParamString: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ configure(authParams: Map&lt;String, String&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >- loadPrivateKey(privateKeyURL: String): PrivateKey</TD></TR>
<TR><TD ALIGN="LEFT" >+ start()</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

AuthenticationBasic1053578162[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)AuthenticationBasic</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   password: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   userId: String [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ configure(authParams: Map&lt;String, String&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ configure(encodedAuthParamString: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ start()</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

AuthenticationDataAthenz1053578162[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)AuthenticationDataAthenz</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   httpHeaderName: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   roleToken: String [0..1]</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

AuthenticationDataBasic1053578162[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)AuthenticationDataBasic</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   commandAuthToken: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   httpAuthToken: String [0..1]</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

AuthenticationDataCommand978396142[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)AuthenticationDataCommand</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   authData: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   remoteAddress: SocketAddress [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   sslSession: SSLSession [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   subscription: String [0..1]</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

AuthenticationDataHttp978396142[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)AuthenticationDataHttp</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   remoteAddress: SocketAddress [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   request: HttpServletRequest [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   subscription: String [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ getHttpHeader(name: String): String</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

AuthenticationDataKeyStoreTls1053578162[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)AuthenticationDataKeyStoreTls</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   keyStoreParams: KeyStoreParams [0..1]</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

AuthenticationDataNull1053578162[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)AuthenticationDataNull</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

AuthenticationDataOAuth21149561371[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)AuthenticationDataOAuth2</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   accessToken: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   headers: Set&lt;Entry&lt;String, String&gt;&gt; [0..*]</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

AuthenticationDataTls1053578162[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)AuthenticationDataTls</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   certFile: FileModifiedTimeUpdater [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   certStream: InputStream [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   certStreamProvider: Supplier&lt;ByteArrayInputStream&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   keyFile: FileModifiedTimeUpdater [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   keyStream: InputStream [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   keyStreamProvider: Supplier&lt;ByteArrayInputStream&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   tlsCertificates: X509Certificate[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >#   tlsPrivateKey: PrivateKey [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   trustStoreStreamProvider: Supplier&lt;ByteArrayInputStream&gt; [0..1]</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

AuthenticationDataToken1053578162[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)AuthenticationDataToken</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   tokenSupplier: Supplier&lt;String&gt; [0..1]</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

AuthenticationDisabled1053578162[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)AuthenticationDisabled</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   nullData: AuthenticationDataProvider [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ configure(encodedAuthParamString: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ configure(authParams: Map&lt;String, String&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ start()</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

AuthenticationFactory1523625906[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)AuthenticationFactory</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ TLS(certFilePath: String, keyFilePath: String): Authentication</TD></TR>
<TR><TD ALIGN="LEFT" >+ create(authPluginClassName: String, authParamsString: String): Authentication</TD></TR>
<TR><TD ALIGN="LEFT" >+ create(authPluginClassName: String, authParams: Map&lt;String, String&gt;): Authentication</TD></TR>
<TR><TD ALIGN="LEFT" >+ token(token: String): Authentication</TD></TR>
<TR><TD ALIGN="LEFT" >+ token(tokenSupplier: Supplier&lt;String&gt;): Authentication</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

AuthenticationKeyStoreTls1053578162[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)AuthenticationKeyStoreTls</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   keyStoreParams: KeyStoreParams [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ configure(paramsString: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ configure(params: Map&lt;String, String&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ mapToString(map: Map&lt;String, String&gt;): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ start()</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

AuthenticationListState18732099[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)AuthenticationListState</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   authState: AuthenticationState [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   states: List&lt;AuthenticationState&gt; [0..*]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ authenticate(authData: AuthData): AuthData</TD></TR>
<TR><TD ALIGN="LEFT" >+ refreshAuthentication(): AuthData</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

AuthenticationOAuth21149561371[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)AuthenticationOAuth2</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   cachedToken: CachedToken [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   clock: Clock [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   flow: Flow [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ configure(encodedAuthParamString: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ configure(authParams: Map&lt;String, String&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ start()</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

AuthenticationProviderAthenz978396142[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)AuthenticationProviderAthenz</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   allowedOffset: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   domainNameList: List&lt;String&gt; [0..*]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ authenticate(authData: AuthenticationDataSource): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ initialize(config: ServiceConfiguration)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

AuthenticationProviderBasic978396142[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)AuthenticationProviderBasic</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   users: Map&lt;String, String&gt; [0..*]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ authenticate(authData: AuthenticationDataSource): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ initialize(config: ServiceConfiguration)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

AuthenticationProviderList978396142[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)AuthenticationProviderList</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   providers: List&lt;AuthenticationProvider&gt; [0..*]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># applyAuthProcessor(processors: List&lt;W&gt;, authFunc: AuthProcessor&lt;T, W&gt;): T</TD></TR>
<TR><TD ALIGN="LEFT" >+ authenticate(authData: AuthenticationDataSource): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ authenticateHttpRequest(request: HttpServletRequest, response: HttpServletResponse): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ initialize(config: ServiceConfiguration)</TD></TR>
<TR><TD ALIGN="LEFT" >+ newAuthState(authData: AuthData, remoteAddress: SocketAddress, sslSession: SSLSession): AuthenticationState</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

AuthenticationProviderSasl978396142[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)AuthenticationProviderSasl</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   allowedIdsPattern: Pattern [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   authStates: ConcurrentHashMap&lt;Long, AuthenticationState&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   configuration: Map&lt;String, String&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   jaasCredentialsContainer: JAASCredentialsContainer [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   loginContextName: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   signer: SaslRoleTokenSigner [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ authRoleFromHttpRequest(httpRequest: HttpServletRequest): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ authenticateHttpRequest(request: HttpServletRequest, response: HttpServletResponse): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >- createAuthRoleToken(role: String, sessionId: String): String</TD></TR>
<TR><TD ALIGN="LEFT" >- getAuthState(request: HttpServletRequest): AuthenticationState</TD></TR>
<TR><TD ALIGN="LEFT" >+ initialize(config: ServiceConfiguration)</TD></TR>
<TR><TD ALIGN="LEFT" >+ newAuthState(authData: AuthData, remoteAddress: SocketAddress, sslSession: SSLSession): AuthenticationState</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

AuthenticationProviderTls978396142[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)AuthenticationProviderTls</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ authenticate(authData: AuthenticationDataSource): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ initialize(config: ServiceConfiguration)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

AuthenticationProviderToken978396142[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)AuthenticationProviderToken</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   audience: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   audienceClaim: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   confTokenAudienceClaimSettingName: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   confTokenAudienceSettingName: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   confTokenAuthClaimSettingName: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   confTokenPublicAlgSettingName: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   confTokenPublicKeySettingName: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   confTokenSecretKeySettingName: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   parser: JwtParser [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   publicKeyAlg: SignatureAlgorithm [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   roleClaim: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   validationKey: Key [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ authenticate(authData: AuthenticationDataSource): String</TD></TR>
<TR><TD ALIGN="LEFT" >- authenticateToken(token: String): Jwt&lt;?, Claims&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >- getPrincipal(jwt: Jwt&lt;?, Claims&gt;): String</TD></TR>
<TR><TD ALIGN="LEFT" >- getPublicKeyAlgType(conf: ServiceConfiguration): SignatureAlgorithm</TD></TR>
<TR><TD ALIGN="LEFT" >+ getToken(authData: AuthenticationDataSource): String</TD></TR>
<TR><TD ALIGN="LEFT" >- getTokenAudience(conf: ServiceConfiguration): String</TD></TR>
<TR><TD ALIGN="LEFT" >- getTokenAudienceClaim(conf: ServiceConfiguration): String</TD></TR>
<TR><TD ALIGN="LEFT" >- getTokenRoleClaim(conf: ServiceConfiguration): String</TD></TR>
<TR><TD ALIGN="LEFT" >- getValidationKey(conf: ServiceConfiguration): Key</TD></TR>
<TR><TD ALIGN="LEFT" >+ initialize(config: ServiceConfiguration)</TD></TR>
<TR><TD ALIGN="LEFT" >+ newAuthState(authData: AuthData, remoteAddress: SocketAddress, sslSession: SSLSession): AuthenticationState</TD></TR>
<TR><TD ALIGN="LEFT" >+ resetMetrics()</TD></TR>
<TR><TD ALIGN="LEFT" >- validateToken(token: String): String</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

AuthenticationSasl1053578162[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)AuthenticationSasl</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   client: Client [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   configuration: Map&lt;String, String&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   loginContextName: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   saslRoleToken: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   serverType: String [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ authenticationStage(requestUrl: String, authData: AuthenticationDataProvider, previousResHeaders: Map&lt;String, String&gt;, authFuture: CompletableFuture&lt;Map&lt;String, String&gt;&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ configure(encodedAuthParamString: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ configure(authParams: Map&lt;String, String&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ getAuthData(serverHostname: String): AuthenticationDataProvider</TD></TR>
<TR><TD ALIGN="LEFT" >- getHeaders(response: Response): Map&lt;String, String&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- isRoleTokenExpired(responseHeaders: Map&lt;String, String&gt;): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >- newRequestBuilder(target: WebTarget, authData: AuthenticationDataProvider, previousResHeaders: Map&lt;String, String&gt;): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ newRequestHeader(hostName: String, authData: AuthenticationDataProvider, previousRespHeaders: Map&lt;String, String&gt;): Set&lt;Entry&lt;String, String&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ start()</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

AuthenticationService978396142[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)AuthenticationService</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   anonymousUserRole: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   providers: Map&lt;String, AuthenticationProvider&gt; [0..*]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ authenticateHttpRequest(request: HttpServletRequest): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ getAuthenticationProvider(authMethodName: String): AuthenticationProvider</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

AuthenticationTls1053578162[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)AuthenticationTls</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   certFilePath: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   certStreamProvider: Supplier&lt;ByteArrayInputStream&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   keyFilePath: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   keyStreamProvider: Supplier&lt;ByteArrayInputStream&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   trustStoreStreamProvider: Supplier&lt;ByteArrayInputStream&gt; [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ configure(encodedAuthParamString: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ configure(authParams: Map&lt;String, String&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ start()</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

AuthenticationToken1053578162[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)AuthenticationToken</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   tokenSupplier: Supplier&lt;String&gt; [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ configure(encodedAuthParamString: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ configure(authParams: Map&lt;String, String&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ start()</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

AuthorizationService1708110945[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)AuthorizationService</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   conf: ServiceConfiguration [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   provider: AuthorizationProvider [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ allowFunctionOpsAsync(namespaceName: NamespaceName, role: String, authenticationData: AuthenticationDataSource): CompletableFuture&lt;Boolean&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ allowNamespaceOperationAsync(namespaceName: NamespaceName, operation: NamespaceOperation, role: String, authData: AuthenticationDataSource): CompletableFuture&lt;Boolean&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ allowNamespaceOperationAsync(namespaceName: NamespaceName, operation: NamespaceOperation, originalRole: String, role: String, authData: AuthenticationDataSource): CompletableFuture&lt;Boolean&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ allowNamespacePolicyOperation(namespaceName: NamespaceName, policy: PolicyName, operation: PolicyOperation, originalRole: String, role: String, authData: AuthenticationDataSource): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ allowNamespacePolicyOperationAsync(namespaceName: NamespaceName, policy: PolicyName, operation: PolicyOperation, role: String, authData: AuthenticationDataSource): CompletableFuture&lt;Boolean&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ allowNamespacePolicyOperationAsync(namespaceName: NamespaceName, policy: PolicyName, operation: PolicyOperation, originalRole: String, role: String, authData: AuthenticationDataSource): CompletableFuture&lt;Boolean&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ allowSinkOpsAsync(namespaceName: NamespaceName, role: String, authenticationData: AuthenticationDataSource): CompletableFuture&lt;Boolean&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ allowSourceOpsAsync(namespaceName: NamespaceName, role: String, authenticationData: AuthenticationDataSource): CompletableFuture&lt;Boolean&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ allowTenantOperation(tenantName: String, operation: TenantOperation, originalRole: String, role: String, authData: AuthenticationDataSource): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ allowTenantOperationAsync(tenantName: String, operation: TenantOperation, role: String, authData: AuthenticationDataSource): CompletableFuture&lt;Boolean&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ allowTenantOperationAsync(tenantName: String, operation: TenantOperation, originalRole: String, role: String, authData: AuthenticationDataSource): CompletableFuture&lt;Boolean&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ allowTopicOperation(topicName: TopicName, operation: TopicOperation, originalRole: String, role: String, authData: AuthenticationDataSource): Boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ allowTopicOperationAsync(topicName: TopicName, operation: TopicOperation, role: String, authData: AuthenticationDataSource): CompletableFuture&lt;Boolean&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ allowTopicOperationAsync(topicName: TopicName, operation: TopicOperation, originalRole: String, role: String, authData: AuthenticationDataSource): CompletableFuture&lt;Boolean&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ allowTopicPolicyOperation(topicName: TopicName, policy: PolicyName, operation: PolicyOperation, originalRole: String, role: String, authData: AuthenticationDataSource): Boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ allowTopicPolicyOperationAsync(topicName: TopicName, policy: PolicyName, operation: PolicyOperation, role: String, authData: AuthenticationDataSource): CompletableFuture&lt;Boolean&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ allowTopicPolicyOperationAsync(topicName: TopicName, policy: PolicyName, operation: PolicyOperation, originalRole: String, role: String, authData: AuthenticationDataSource): CompletableFuture&lt;Boolean&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ canConsume(topicName: TopicName, role: String, authenticationData: AuthenticationDataSource, subscription: String): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ canConsumeAsync(topicName: TopicName, role: String, authenticationData: AuthenticationDataSource, subscription: String): CompletableFuture&lt;Boolean&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ canLookup(topicName: TopicName, role: String, authenticationData: AuthenticationDataSource): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ canLookupAsync(topicName: TopicName, role: String, authenticationData: AuthenticationDataSource): CompletableFuture&lt;Boolean&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ canProduce(topicName: TopicName, role: String, authenticationData: AuthenticationDataSource): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ canProduceAsync(topicName: TopicName, role: String, authenticationData: AuthenticationDataSource): CompletableFuture&lt;Boolean&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ grantPermissionAsync(namespace: NamespaceName, actions: Set&lt;AuthAction&gt;, role: String, authDataJson: String): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ grantPermissionAsync(topicname: TopicName, actions: Set&lt;AuthAction&gt;, role: String, authDataJson: String): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ grantSubscriptionPermissionAsync(namespace: NamespaceName, subscriptionName: String, roles: Set&lt;String&gt;, authDataJson: String): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- isProxyRole(role: String): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ isSuperUser(user: String, authenticationData: AuthenticationDataSource): CompletableFuture&lt;Boolean&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ isTenantAdmin(tenant: String, role: String, tenantInfo: TenantInfo, authenticationData: AuthenticationDataSource): CompletableFuture&lt;Boolean&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ revokeSubscriptionPermissionAsync(namespace: NamespaceName, subscriptionName: String, role: String, authDataJson: String): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- validateOriginalPrincipal(proxyRoles: Set&lt;String&gt;, authenticatedPrincipal: String, originalPrincipal: String)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

AutoClusterFailover12001400[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)AutoClusterFailover</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   currentPulsarServiceUrl: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   executor: ScheduledExecutorService [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   failedTimestamp: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   failoverDelayNs: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   failoverPolicy: FailoverPolicy [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   intervalMs: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   primary: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   primaryAuthentication: Authentication [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   primaryTlsTrustCertsFilePath: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   primaryTlsTrustStorePassword: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   primaryTlsTrustStorePath: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   pulsarClient: PulsarClientImpl [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   recoverTimestamp: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   resolver: PulsarServiceNameResolver [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   secondary: List&lt;String&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   secondaryAuthentications: Map&lt;String, Authentication&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   secondaryTlsTrustCertsFilePaths: Map&lt;String, String&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   secondaryTlsTrustStorePasswords: Map&lt;String, String&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   secondaryTlsTrustStorePaths: Map&lt;String, String&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   switchBackDelayNs: long [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ builder(): AutoClusterFailoverBuilder</TD></TR>
<TR><TD ALIGN="LEFT" ># canEqual(other: Object): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ initialize(client: PulsarClient)</TD></TR>
<TR><TD ALIGN="LEFT" >- nanosToMillis(nanos: long): long</TD></TR>
<TR><TD ALIGN="LEFT" >- probeAndCheckSwitchBack(target: String, authentication: Authentication, tlsTrustCertsFilePath: String, tlsTrustStorePath: String, tlsTrustStorePassword: String)</TD></TR>
<TR><TD ALIGN="LEFT" >- probeAndUpdateServiceUrl(targetServiceUrls: List&lt;String&gt;, authentications: Map&lt;String, Authentication&gt;, tlsTrustCertsFilePaths: Map&lt;String, String&gt;, tlsTrustStorePaths: Map&lt;String, String&gt;, tlsTrustStorePasswords: Map&lt;String, String&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >- probeAndUpdateServiceUrl(targetServiceUrl: String, authentication: Authentication, tlsTrustCertsFilePath: String, tlsTrustStorePath: String, tlsTrustStorePassword: String)</TD></TR>
<TR><TD ALIGN="LEFT" ># probeAvailable(url: String): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >- updateServiceUrl(target: String, authentication: Authentication, tlsTrustCertsFilePath: String, tlsTrustStorePath: String, tlsTrustStorePassword: String)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

AutoConsumeSchema1622012615[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)AutoConsumeSchema</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   componentName: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   schemaInfoProvider: SchemaInfoProvider [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   schemaMap: ConcurrentMap&lt;SchemaVersion, Schema&lt;?&gt;&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   topicName: String [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># adapt(value: Object, schemaVersion: byte[]): GenericRecord</TD></TR>
<TR><TD ALIGN="LEFT" >+ atSchemaVersion(schemaVersion: byte[]): Schema&lt;?&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ clone(): Schema&lt;GenericRecord&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ configureSchemaInfo(topicName: String, componentName: String, schemaInfo: SchemaInfo)</TD></TR>
<TR><TD ALIGN="LEFT" >+ decode(bytes: byte[], schemaVersion: byte[]): GenericRecord</TD></TR>
<TR><TD ALIGN="LEFT" >+ encode(message: GenericRecord): byte[]</TD></TR>
<TR><TD ALIGN="LEFT" >- ensureSchemaInitialized(schemaVersion: SchemaVersion)</TD></TR>
<TR><TD ALIGN="LEFT" >- extractFromAvroSchema(schemaInfo: SchemaInfo, useProvidedSchemaAsReaderSchema: boolean): Schema&lt;?&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ fetchSchemaIfNeeded(schemaVersion: SchemaVersion)</TD></TR>
<TR><TD ALIGN="LEFT" >- generateSchema(schemaInfo: SchemaInfo): Schema&lt;?&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getInternalSchema(schemaVersion: byte[]): Schema&lt;?&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getSchema(schemaInfo: SchemaInfo): Schema&lt;?&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getSchemaInfo(schemaVersion: byte[]): SchemaInfo</TD></TR>
<TR><TD ALIGN="LEFT" >- getSchemaVersion(schemaVersion: byte[]): SchemaVersion</TD></TR>
<TR><TD ALIGN="LEFT" >- initSchemaMap(): ConcurrentMap&lt;SchemaVersion, Schema&lt;?&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ requireFetchingSchemaInfo(): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ supportSchemaVersioning(): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ validate(message: byte[])</TD></TR>
<TR><TD ALIGN="LEFT" >+ validate(message: byte[], schemaVersion: byte[])</TD></TR>
<TR><TD ALIGN="LEFT" >+ wrapPrimitiveObject(value: Object, type: SchemaType, schemaVersion: byte[]): GenericRecord</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

AutoProduceBytesSchema1622012615[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)AutoProduceBytesSchema&lt;T&gt;</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   requireSchemaValidation: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   schema: Schema&lt;T&gt; [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ clone(): Schema&lt;byte[]&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ decode(bytes: byte[], schemaVersion: byte[]): byte[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ encode(message: byte[]): byte[]</TD></TR>
<TR><TD ALIGN="LEFT" >- ensureSchemaInitialized()</TD></TR>
<TR><TD ALIGN="LEFT" >+ schemaInitialized(): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ validate(message: byte[])</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

AutoSubscriptionCreationOverrideImpl1043561458[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)AutoSubscriptionCreationOverrideImpl</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   allowAutoSubscriptionCreation: boolean [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ builder(): AutoSubscriptionCreationOverrideImplBuilder</TD></TR>
<TR><TD ALIGN="LEFT" ># canEqual(other: Object): boolean</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

AutoTopicCreationOverrideImpl1043561458[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)AutoTopicCreationOverrideImpl</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   allowAutoTopicCreation: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   defaultNumPartitions: Integer [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   topicType: String [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ builder(): AutoTopicCreationOverrideImplBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ isValidOverride(override: AutoTopicCreationOverride): boolean</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

AvroBaseStructSchema1622012615[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)AvroBaseStructSchema&lt;T&gt;</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   schema: Schema [0..1]</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

AvroReader657740342[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)AvroReader&lt;T&gt;</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   reader: ReflectDatumReader&lt;T&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   schema: Schema [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ read(bytes: byte[], offset: int, length: int): T</TD></TR>
<TR><TD ALIGN="LEFT" >+ read(inputStream: InputStream): T</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

AvroSchema1622012615[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)AvroSchema&lt;T&gt;</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   isCustomReaderAndWriter: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   pojoClassLoader: ClassLoader [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ addLogicalTypeConversions(reflectData: ReflectData, jsr310ConversionEnabled: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ addLogicalTypeConversions(reflectData: ReflectData, jsr310ConversionEnabled: boolean, decimalConversionEnabled: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ clone(): Schema&lt;T&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ of(schemaDefinition: SchemaDefinition&lt;T&gt;): AvroSchema&lt;T&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ of(pojo: Class&lt;T&gt;): AvroSchema&lt;T&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ of(pojo: Class&lt;T&gt;, properties: Map&lt;String, String&gt;): AvroSchema&lt;T&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ supportSchemaVersioning(): boolean</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

AvroSchemaBasedCompatibilityCheck445450388[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)AvroSchemaBasedCompatibilityCheck</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ checkCompatible(from: SchemaData, to: SchemaData, strategy: SchemaCompatibilityStrategy)</TD></TR>
<TR><TD ALIGN="LEFT" >+ checkCompatible(from: Iterable&lt;SchemaData&gt;, to: SchemaData, strategy: SchemaCompatibilityStrategy)</TD></TR>
<TR><TD ALIGN="LEFT" ># createLatestOrAllValidator(validatorBuilder: SchemaValidatorBuilder, onlyLatest: boolean): SchemaValidator</TD></TR>
<TR><TD ALIGN="LEFT" ># createSchemaValidator(compatibilityStrategy: SchemaCompatibilityStrategy): SchemaValidator</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

AvroSchemaCompatibilityCheck445450388[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)AvroSchemaCompatibilityCheck</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

AvroWriter502335110[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)AvroWriter&lt;T&gt;</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   byteArrayOutputStream: ByteArrayOutputStream [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   encoder: BinaryEncoder [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   writer: ReflectDatumWriter&lt;T&gt; [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ write(message: T): byte[]</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

BacklogQuotaImpl1043561458[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)BacklogQuotaImpl</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   limit: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   limitSize: Long [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   limitTime: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   policy: RetentionPolicy [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ builder(): BacklogQuotaImplBuilder</TD></TR>
<TR><TD ALIGN="LEFT" ># canEqual(other: Object): boolean</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

BacklogQuotaManager1718290011[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)BacklogQuotaManager</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   defaultQuota: BacklogQuotaImpl [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   namespaceResources: NamespaceResources [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- disconnectProducers(persistentTopic: PersistentTopic)</TD></TR>
<TR><TD ALIGN="LEFT" >- dropBacklogForSizeLimit(persistentTopic: PersistentTopic, quota: BacklogQuota)</TD></TR>
<TR><TD ALIGN="LEFT" >- dropBacklogForTimeLimit(persistentTopic: PersistentTopic, quota: BacklogQuota, preciseTimeBasedBacklogQuotaCheck: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ getBacklogQuota(namespace: NamespaceName, backlogQuotaType: BacklogQuotaType): BacklogQuotaImpl</TD></TR>
<TR><TD ALIGN="LEFT" >+ handleExceededBacklogQuota(persistentTopic: PersistentTopic, backlogQuotaType: BacklogQuotaType, preciseTimeBasedBacklogQuotaCheck: boolean)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

Backoff12001400[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)Backoff</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   clock: Clock [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   firstBackoffTimeInMillis: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   initial: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   mandatoryStop: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   mandatoryStopMade: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   max: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   next: long [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># canEqual(other: Object): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ next(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ reduceToHalf()</TD></TR>
<TR><TD ALIGN="LEFT" >+ reset()</TD></TR>
<TR><TD ALIGN="LEFT" >+ shouldBackoff(initialTimestamp: long, unitInitial: TimeUnit, failedAttempts: int, defaultInterval: long, maxBackoffInterval: long): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ shouldBackoff(initialTimestamp: long, unitInitial: TimeUnit, failedAttempts: int): boolean</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

BackoffBuilder12001400[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)BackoffBuilder</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   clock: Clock [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   initial: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   mandatoryStop: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   max: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   unitInitial: TimeUnit [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   unitMandatoryStop: TimeUnit [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   unitMax: TimeUnit [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ create(): Backoff</TD></TR>
<TR><TD ALIGN="LEFT" >+ setInitialTime(initial: long, unitInitial: TimeUnit): BackoffBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ setMandatoryStop(mandatoryStop: long, unitMandatoryStop: TimeUnit): BackoffBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ setMax(max: long, unitMax: TimeUnit): BackoffBuilder</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

BaseCommand297559756[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)BaseCommand</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   _bitField0: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _bitField1: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _cachedSize: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _parsedBuffer: ByteBuf [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   ack: CommandAck [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   ackResponse: CommandAckResponse [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   activeConsumerChange: CommandActiveConsumerChange [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   addPartitionToTxn: CommandAddPartitionToTxn [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   addPartitionToTxnResponse: CommandAddPartitionToTxnResponse [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   addSubscriptionToTxn: CommandAddSubscriptionToTxn [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   addSubscriptionToTxnResponse: CommandAddSubscriptionToTxnResponse [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   authChallenge: CommandAuthChallenge [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   authResponse: CommandAuthResponse [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   closeConsumer: CommandCloseConsumer [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   closeProducer: CommandCloseProducer [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   connect: CommandConnect [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   connected: CommandConnected [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   consumerStats: CommandConsumerStats [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   consumerStatsResponse: CommandConsumerStatsResponse [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   endTxn: CommandEndTxn [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   endTxnOnPartition: CommandEndTxnOnPartition [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   endTxnOnPartitionResponse: CommandEndTxnOnPartitionResponse [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   endTxnOnSubscription: CommandEndTxnOnSubscription [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   endTxnOnSubscriptionResponse: CommandEndTxnOnSubscriptionResponse [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   endTxnResponse: CommandEndTxnResponse [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   error: CommandError [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   flow: CommandFlow [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   getLastMessageId: CommandGetLastMessageId [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   getLastMessageIdResponse: CommandGetLastMessageIdResponse [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   getOrCreateSchema: CommandGetOrCreateSchema [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   getOrCreateSchemaResponse: CommandGetOrCreateSchemaResponse [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   getSchema: CommandGetSchema [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   getSchemaResponse: CommandGetSchemaResponse [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   getTopicsOfNamespace: CommandGetTopicsOfNamespace [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   getTopicsOfNamespaceResponse: CommandGetTopicsOfNamespaceResponse [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   lookupTopic: CommandLookupTopic [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   lookupTopicResponse: CommandLookupTopicResponse [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   message: CommandMessage [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   newTxn: CommandNewTxn [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   newTxnResponse: CommandNewTxnResponse [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   partitionMetadata: CommandPartitionedTopicMetadata [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   partitionMetadataResponse: CommandPartitionedTopicMetadataResponse [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   ping: CommandPing [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   pong: CommandPong [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   producer: CommandProducer [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   producerSuccess: CommandProducerSuccess [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   reachedEndOfTopic: CommandReachedEndOfTopic [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   redeliverUnacknowledgedMessages: CommandRedeliverUnacknowledgedMessages [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   seek: CommandSeek [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   send: CommandSend [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   sendError: CommandSendError [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   sendReceipt: CommandSendReceipt [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   subscribe: CommandSubscribe [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   success: CommandSuccess [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   tcClientConnectRequest: CommandTcClientConnectRequest [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   tcClientConnectResponse: CommandTcClientConnectResponse [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   type: Type [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   unsubscribe: CommandUnsubscribe [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- checkRequiredFields()</TD></TR>
<TR><TD ALIGN="LEFT" >+ clear(): BaseCommand</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearAck(): BaseCommand</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearAckResponse(): BaseCommand</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearActiveConsumerChange(): BaseCommand</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearAddPartitionToTxn(): BaseCommand</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearAddPartitionToTxnResponse(): BaseCommand</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearAddSubscriptionToTxn(): BaseCommand</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearAddSubscriptionToTxnResponse(): BaseCommand</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearAuthChallenge(): BaseCommand</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearAuthResponse(): BaseCommand</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearCloseConsumer(): BaseCommand</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearCloseProducer(): BaseCommand</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearConnect(): BaseCommand</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearConnected(): BaseCommand</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearConsumerStats(): BaseCommand</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearConsumerStatsResponse(): BaseCommand</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearEndTxn(): BaseCommand</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearEndTxnOnPartition(): BaseCommand</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearEndTxnOnPartitionResponse(): BaseCommand</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearEndTxnOnSubscription(): BaseCommand</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearEndTxnOnSubscriptionResponse(): BaseCommand</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearEndTxnResponse(): BaseCommand</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearError(): BaseCommand</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearFlow(): BaseCommand</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearGetLastMessageId(): BaseCommand</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearGetLastMessageIdResponse(): BaseCommand</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearGetOrCreateSchema(): BaseCommand</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearGetOrCreateSchemaResponse(): BaseCommand</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearGetSchema(): BaseCommand</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearGetSchemaResponse(): BaseCommand</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearGetTopicsOfNamespace(): BaseCommand</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearGetTopicsOfNamespaceResponse(): BaseCommand</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearLookupTopic(): BaseCommand</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearLookupTopicResponse(): BaseCommand</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearMessage(): BaseCommand</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearNewTxn(): BaseCommand</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearNewTxnResponse(): BaseCommand</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearPartitionMetadata(): BaseCommand</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearPartitionMetadataResponse(): BaseCommand</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearPing(): BaseCommand</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearPong(): BaseCommand</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearProducer(): BaseCommand</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearProducerSuccess(): BaseCommand</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearReachedEndOfTopic(): BaseCommand</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearRedeliverUnacknowledgedMessages(): BaseCommand</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearSeek(): BaseCommand</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearSend(): BaseCommand</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearSendError(): BaseCommand</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearSendReceipt(): BaseCommand</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearSubscribe(): BaseCommand</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearSuccess(): BaseCommand</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearTcClientConnectRequest(): BaseCommand</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearTcClientConnectResponse(): BaseCommand</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearType(): BaseCommand</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearUnsubscribe(): BaseCommand</TD></TR>
<TR><TD ALIGN="LEFT" >+ copyFrom(_other: BaseCommand): BaseCommand</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(_buffer: ByteBuf, _size: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(a: byte[])</TD></TR>
<TR><TD ALIGN="LEFT" >+ setAck(): CommandAck</TD></TR>
<TR><TD ALIGN="LEFT" >+ setAckResponse(): CommandAckResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ setActiveConsumerChange(): CommandActiveConsumerChange</TD></TR>
<TR><TD ALIGN="LEFT" >+ setAddPartitionToTxn(): CommandAddPartitionToTxn</TD></TR>
<TR><TD ALIGN="LEFT" >+ setAddPartitionToTxnResponse(): CommandAddPartitionToTxnResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ setAddSubscriptionToTxn(): CommandAddSubscriptionToTxn</TD></TR>
<TR><TD ALIGN="LEFT" >+ setAddSubscriptionToTxnResponse(): CommandAddSubscriptionToTxnResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ setAuthChallenge(): CommandAuthChallenge</TD></TR>
<TR><TD ALIGN="LEFT" >+ setAuthResponse(): CommandAuthResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ setCloseConsumer(): CommandCloseConsumer</TD></TR>
<TR><TD ALIGN="LEFT" >+ setCloseProducer(): CommandCloseProducer</TD></TR>
<TR><TD ALIGN="LEFT" >+ setConnect(): CommandConnect</TD></TR>
<TR><TD ALIGN="LEFT" >+ setConnected(): CommandConnected</TD></TR>
<TR><TD ALIGN="LEFT" >+ setConsumerStats(): CommandConsumerStats</TD></TR>
<TR><TD ALIGN="LEFT" >+ setConsumerStatsResponse(): CommandConsumerStatsResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ setEndTxn(): CommandEndTxn</TD></TR>
<TR><TD ALIGN="LEFT" >+ setEndTxnOnPartition(): CommandEndTxnOnPartition</TD></TR>
<TR><TD ALIGN="LEFT" >+ setEndTxnOnPartitionResponse(): CommandEndTxnOnPartitionResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ setEndTxnOnSubscription(): CommandEndTxnOnSubscription</TD></TR>
<TR><TD ALIGN="LEFT" >+ setEndTxnOnSubscriptionResponse(): CommandEndTxnOnSubscriptionResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ setEndTxnResponse(): CommandEndTxnResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ setError(): CommandError</TD></TR>
<TR><TD ALIGN="LEFT" >+ setFlow(): CommandFlow</TD></TR>
<TR><TD ALIGN="LEFT" >+ setGetLastMessageId(): CommandGetLastMessageId</TD></TR>
<TR><TD ALIGN="LEFT" >+ setGetLastMessageIdResponse(): CommandGetLastMessageIdResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ setGetOrCreateSchema(): CommandGetOrCreateSchema</TD></TR>
<TR><TD ALIGN="LEFT" >+ setGetOrCreateSchemaResponse(): CommandGetOrCreateSchemaResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ setGetSchema(): CommandGetSchema</TD></TR>
<TR><TD ALIGN="LEFT" >+ setGetSchemaResponse(): CommandGetSchemaResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ setGetTopicsOfNamespace(): CommandGetTopicsOfNamespace</TD></TR>
<TR><TD ALIGN="LEFT" >+ setGetTopicsOfNamespaceResponse(): CommandGetTopicsOfNamespaceResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ setLookupTopic(): CommandLookupTopic</TD></TR>
<TR><TD ALIGN="LEFT" >+ setLookupTopicResponse(): CommandLookupTopicResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ setMessage(): CommandMessage</TD></TR>
<TR><TD ALIGN="LEFT" >+ setNewTxn(): CommandNewTxn</TD></TR>
<TR><TD ALIGN="LEFT" >+ setNewTxnResponse(): CommandNewTxnResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ setPartitionMetadata(): CommandPartitionedTopicMetadata</TD></TR>
<TR><TD ALIGN="LEFT" >+ setPartitionMetadataResponse(): CommandPartitionedTopicMetadataResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ setPing(): CommandPing</TD></TR>
<TR><TD ALIGN="LEFT" >+ setPong(): CommandPong</TD></TR>
<TR><TD ALIGN="LEFT" >+ setProducer(): CommandProducer</TD></TR>
<TR><TD ALIGN="LEFT" >+ setProducerSuccess(): CommandProducerSuccess</TD></TR>
<TR><TD ALIGN="LEFT" >+ setReachedEndOfTopic(): CommandReachedEndOfTopic</TD></TR>
<TR><TD ALIGN="LEFT" >+ setRedeliverUnacknowledgedMessages(): CommandRedeliverUnacknowledgedMessages</TD></TR>
<TR><TD ALIGN="LEFT" >+ setSeek(): CommandSeek</TD></TR>
<TR><TD ALIGN="LEFT" >+ setSend(): CommandSend</TD></TR>
<TR><TD ALIGN="LEFT" >+ setSendError(): CommandSendError</TD></TR>
<TR><TD ALIGN="LEFT" >+ setSendReceipt(): CommandSendReceipt</TD></TR>
<TR><TD ALIGN="LEFT" >+ setSubscribe(): CommandSubscribe</TD></TR>
<TR><TD ALIGN="LEFT" >+ setSuccess(): CommandSuccess</TD></TR>
<TR><TD ALIGN="LEFT" >+ setTcClientConnectRequest(): CommandTcClientConnectRequest</TD></TR>
<TR><TD ALIGN="LEFT" >+ setTcClientConnectResponse(): CommandTcClientConnectResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ setType(type: Type): BaseCommand</TD></TR>
<TR><TD ALIGN="LEFT" >+ setUnsubscribe(): CommandUnsubscribe</TD></TR>
<TR><TD ALIGN="LEFT" >+ toByteArray(): byte[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeTo(_b: ByteBuf): int</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

BaseResource1292556772[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)BaseResource</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   auth: Authentication [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   readTimeoutMs: long [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ asyncDeleteRequest(target: WebTarget): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ asyncDeleteRequest(target: WebTarget, callback: InvocationCallback&lt;T&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ asyncGetRequest(target: WebTarget, callback: InvocationCallback&lt;T&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ asyncPostRequest(target: WebTarget, entity: Entity&lt;T&gt;): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ asyncPutRequest(target: WebTarget, entity: Entity&lt;T&gt;): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getApiException(e: Throwable): PulsarAdminException</TD></TR>
<TR><TD ALIGN="LEFT" >+ getApiException(response: Response): PulsarAdminException</TD></TR>
<TR><TD ALIGN="LEFT" >+ getReasonFromServer(e: WebApplicationException): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ request(target: WebTarget): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ requestAsync(target: WebTarget): CompletableFuture&lt;Builder&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># sync(executor: Supplier&lt;CompletableFuture&lt;T&gt;&gt;): T</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

BaseResources220376139[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)BaseResources&lt;T&gt;</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   cache: MetadataCache&lt;T&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   operationTimeoutSec: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   store: MetadataStore [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># create(path: String, data: T)</TD></TR>
<TR><TD ALIGN="LEFT" ># createAsync(path: String, data: T): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># delete(path: String)</TD></TR>
<TR><TD ALIGN="LEFT" ># deleteAsync(path: String): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># deleteIfExistsAsync(path: String): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># exists(path: String): boolean</TD></TR>
<TR><TD ALIGN="LEFT" ># existsAsync(path: String): CompletableFuture&lt;Boolean&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># get(path: String): Optional&lt;T&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># getAsync(path: String): CompletableFuture&lt;Optional&lt;T&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># getChildren(path: String): List&lt;String&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># getChildrenAsync(path: String): CompletableFuture&lt;List&lt;String&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># joinPath(parts: String...): String</TD></TR>
<TR><TD ALIGN="LEFT" ># setAsync(path: String, modifyFunction: Function&lt;T, T&gt;): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># setWithCreateAsync(path: String, createFunction: Function&lt;Optional&lt;T&gt;, T&gt;): CompletableFuture&lt;Void&gt;</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

BatchMessageAcker12001400[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)BatchMessageAcker</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   batchSize: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   bitSet: BitSet [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   prevBatchCumulativelyAcked: boolean [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ ackCumulative(batchIndex: int): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ ackIndividual(batchIndex: int): boolean</TD></TR>
<TR><TD ALIGN="LEFT" ># newAcker(batchSize: int): BatchMessageAcker</TD></TR>
<TR><TD ALIGN="LEFT" ># newAcker(bitSet: BitSet): BatchMessageAcker</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

BatchMessageAckerDisabled12001400[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)BatchMessageAckerDisabled</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ ackCumulative(batchIndex: int): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ ackIndividual(batchIndex: int): boolean</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

BatchMessageIdImpl12001400[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)BatchMessageIdImpl</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   acker: BatchMessageAcker [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   batchIndex: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   batchSize: int [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ ackCumulative(): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ ackIndividual(): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ compareTo(o: MessageId): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ prevBatchMessageId(): MessageIdImpl</TD></TR>
<TR><TD ALIGN="LEFT" >+ toByteArray(): byte[]</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

BatchSourceExecutor1311590187[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)BatchSourceExecutor&lt;T&gt;</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   batchSource: BatchSource&lt;T&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   batchSourceClassName: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   batchSourceConfig: BatchSourceConfig [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   config: Map&lt;String, Object&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   currentError: Exception [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   currentTask: Message&lt;byte[]&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   discoverInProgress: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   discoveryThread: ExecutorService [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   discoveryTriggerer: BatchSourceTriggerer [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   intermediateTopicConsumer: Consumer&lt;byte[]&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   intermediateTopicName: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   isRunning: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   sourceContext: SourceContext [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >- createIntermediateTopicConsumer()</TD></TR>
<TR><TD ALIGN="LEFT" >- getBatchSourceConfigs(config: Map&lt;String, Object&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >- initializeBatchSource()</TD></TR>
<TR><TD ALIGN="LEFT" >+ open(config: Map&lt;String, Object&gt;, sourceContext: SourceContext)</TD></TR>
<TR><TD ALIGN="LEFT" >- prepareInternal(task: Message&lt;byte[]&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ read(): Record&lt;T&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- retrieveNextTask(): Message&lt;byte[]&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- start()</TD></TR>
<TR><TD ALIGN="LEFT" >- stop()</TD></TR>
<TR><TD ALIGN="LEFT" >- taskEater(discoveredEvent: String, task: byte[])</TD></TR>
<TR><TD ALIGN="LEFT" >- triggerDiscover(discoveredEvent: String)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

BindAddressValidator1093663096[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)BindAddressValidator</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- migrateBindAddresses(config: ServiceConfiguration): List&lt;BindAddress&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ validateBindAddresses(config: ServiceConfiguration, schemes: Collection&lt;String&gt;): List&lt;BindAddress&gt;</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

BitSetRecyclable201476337[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)BitSetRecyclable</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   recyclerHandle: Handle&lt;BitSetRecyclable&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   sizeIsSticky: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   words: long[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   wordsInUse: int [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ and(set: BitSetRecyclable)</TD></TR>
<TR><TD ALIGN="LEFT" >+ andNot(set: BitSetRecyclable)</TD></TR>
<TR><TD ALIGN="LEFT" >+ cardinality(): int</TD></TR>
<TR><TD ALIGN="LEFT" >- checkInvariants()</TD></TR>
<TR><TD ALIGN="LEFT" >- checkRange(fromIndex: int, toIndex: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ clear(bitIndex: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ clear(fromIndex: int, toIndex: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ clear()</TD></TR>
<TR><TD ALIGN="LEFT" >+ clone(): Object</TD></TR>
<TR><TD ALIGN="LEFT" >+ create(): BitSetRecyclable</TD></TR>
<TR><TD ALIGN="LEFT" >- ensureCapacity(wordsRequired: int)</TD></TR>
<TR><TD ALIGN="LEFT" >- expandTo(wordIndex: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ flip(bitIndex: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ flip(fromIndex: int, toIndex: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ get(bitIndex: int): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ get(fromIndex: int, toIndex: int): BitSetRecyclable</TD></TR>
<TR><TD ALIGN="LEFT" >- initWords(nbits: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ intersects(set: BitSetRecyclable): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ length(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ nextClearBit(fromIndex: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ nextSetBit(fromIndex: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ or(set: BitSetRecyclable)</TD></TR>
<TR><TD ALIGN="LEFT" >+ previousClearBit(fromIndex: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ previousSetBit(fromIndex: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >- readObject(s: ObjectInputStream)</TD></TR>
<TR><TD ALIGN="LEFT" >- recalculateWordsInUse()</TD></TR>
<TR><TD ALIGN="LEFT" >+ recycle()</TD></TR>
<TR><TD ALIGN="LEFT" >+ resetWords(words: long[]): BitSetRecyclable</TD></TR>
<TR><TD ALIGN="LEFT" >+ size(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ toByteArray(): byte[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ toLongArray(): long[]</TD></TR>
<TR><TD ALIGN="LEFT" >- trimToSize()</TD></TR>
<TR><TD ALIGN="LEFT" >+ valueOf(longs: long[]): BitSetRecyclable</TD></TR>
<TR><TD ALIGN="LEFT" >+ valueOf(lb: LongBuffer): BitSetRecyclable</TD></TR>
<TR><TD ALIGN="LEFT" >+ valueOf(bytes: byte[]): BitSetRecyclable</TD></TR>
<TR><TD ALIGN="LEFT" >+ valueOf(bb: ByteBuffer): BitSetRecyclable</TD></TR>
<TR><TD ALIGN="LEFT" >- wordIndex(bitIndex: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >- writeObject(s: ObjectOutputStream)</TD></TR>
<TR><TD ALIGN="LEFT" >+ xor(set: BitSetRecyclable)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

BookKeeperClientFactoryImpl724302956[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)BookKeeperClientFactoryImpl</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ create(conf: ServiceConfiguration, store: MetadataStoreExtended, eventLoopGroup: EventLoopGroup, ensemblePlacementPolicyClass: Optional&lt;Class&lt;? extends EnsemblePlacementPolicy&gt;&gt;, properties: Map&lt;String, Object&gt;): BookKeeper</TD></TR>
<TR><TD ALIGN="LEFT" >+ create(conf: ServiceConfiguration, store: MetadataStoreExtended, eventLoopGroup: EventLoopGroup, ensemblePlacementPolicyClass: Optional&lt;Class&lt;? extends EnsemblePlacementPolicy&gt;&gt;, properties: Map&lt;String, Object&gt;, statsLogger: StatsLogger): BookKeeper</TD></TR>
<TR><TD ALIGN="LEFT" ># createBkClientConfiguration(store: MetadataStoreExtended, conf: ServiceConfiguration): ClientConfiguration</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

BookieAffinityGroupDataImpl1043561458[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)BookieAffinityGroupDataImpl</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   bookkeeperAffinityGroupPrimary: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   bookkeeperAffinityGroupSecondary: String [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ builder(): BookieAffinityGroupDataImplBuilder</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

Bookies620988779[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)Bookies</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ deleteBookieRackInfo(asyncResponse: AsyncResponse, bookieAddress: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ getBookieRackInfo(asyncResponse: AsyncResponse, bookieAddress: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ getBookiesRackInfo(asyncResponse: AsyncResponse)</TD></TR>
<TR><TD ALIGN="LEFT" >+ updateBookieRackInfo(asyncResponse: AsyncResponse, bookieAddress: String, group: String, bookieInfo: BookieInfo)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

BookkeeperSchemaStorage445450388[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)BookkeeperSchemaStorage</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   bookKeeper: BookKeeper [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   config: ServiceConfiguration [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   locatorEntryCache: MetadataCache&lt;SchemaLocator&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   pulsar: PulsarService [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   readSchemaOperations: ConcurrentMap&lt;String, CompletableFuture&lt;StoredSchema&gt;&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   store: MetadataStoreExtended [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- addEntry(ledgerHandle: LedgerHandle, entry: SchemaEntry): CompletableFuture&lt;Long&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- addNewSchemaEntryToStore(schemaId: String, index: List&lt;IndexEntry&gt;, data: byte[]): CompletableFuture&lt;PositionInfo&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ bkException(operation: String, rc: int, ledgerId: long, entryId: long): Exception</TD></TR>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >- closeLedger(ledgerHandle: LedgerHandle): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- createLedger(schemaId: String): CompletableFuture&lt;LedgerHandle&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- createNewSchema(schemaId: String, data: byte[], hash: byte[]): CompletableFuture&lt;Long&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- createSchemaLocator(id: String, locator: SchemaLocator): CompletableFuture&lt;LocatorEntry&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ delete(key: String, forcefully: boolean): CompletableFuture&lt;SchemaVersion&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ delete(key: String): CompletableFuture&lt;SchemaVersion&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- deleteSchema(schemaId: String, forcefully: boolean): CompletableFuture&lt;Long&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- findSchemaEntryByVersion(index: List&lt;IndexEntry&gt;, version: long): CompletableFuture&lt;SchemaEntry&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ get(key: String, version: SchemaVersion): CompletableFuture&lt;StoredSchema&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getAll(key: String): CompletableFuture&lt;List&lt;CompletableFuture&lt;StoredSchema&gt;&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># getLocator(key: String): CompletableFuture&lt;Optional&lt;LocatorEntry&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- getSchema(schemaId: String): CompletableFuture&lt;StoredSchema&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- getSchema(schemaId: String, version: long): CompletableFuture&lt;StoredSchema&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getSchemaLedgerList(key: String): List&lt;Long&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- getSchemaLocator(schema: String): CompletableFuture&lt;Optional&lt;LocatorEntry&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- getSchemaPath(schemaId: String): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ getStoreLedgerIdsBySchemaId(schemaId: String): CompletableFuture&lt;List&lt;Long&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ ignoreUnrecoverableBKException(source: CompletableFuture&lt;T&gt;): CompletableFuture&lt;T&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- openLedger(ledgerId: Long): CompletableFuture&lt;LedgerHandle&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ put(key: String, value: byte[], hash: byte[]): CompletableFuture&lt;SchemaVersion&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- putSchema(schemaId: String, data: byte[], hash: byte[]): CompletableFuture&lt;Long&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- readSchemaEntry(position: PositionInfo): CompletableFuture&lt;SchemaEntry&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ start()</TD></TR>
<TR><TD ALIGN="LEFT" >- updateSchemaLocator(schemaId: String, locatorEntry: LocatorEntry, position: PositionInfo, hash: byte[]): CompletableFuture&lt;Long&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- updateSchemaLocator(id: String, schema: SchemaLocator, version: long): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ versionFromBytes(version: byte[]): SchemaVersion</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

BooleanSchema1622012615[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)BooleanSchema</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ decode(bytes: byte[]): Boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ decode(byteBuf: ByteBuf): Boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ encode(message: Boolean): byte[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ of(): BooleanSchema</TD></TR>
<TR><TD ALIGN="LEFT" >+ validate(message: byte[])</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

BrokerDiscoveryProvider79518146[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)BrokerDiscoveryProvider</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   counter: AtomicInteger [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   metadataStoreCacheLoader: MetadataStoreCacheLoader [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   orderedExecutor: OrderedScheduler [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   pulsarResources: PulsarResources [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   scheduledExecutorScheduler: ScheduledExecutorService [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># checkAuthorization(service: ProxyService, topicName: TopicName, role: String, authenticationData: AuthenticationDataSource)</TD></TR>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" ># getPartitionedTopicMetadata(service: ProxyService, topicName: TopicName, role: String, authenticationData: AuthenticationDataSource): CompletableFuture&lt;PartitionedTopicMetadata&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># nextBroker(): LoadManagerReport</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

BrokerEntryMetadata297559756[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)BrokerEntryMetadata</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   _bitField0: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _cachedSize: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _parsedBuffer: ByteBuf [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   brokerTimestamp: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   index: long [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ clear(): BrokerEntryMetadata</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearBrokerTimestamp(): BrokerEntryMetadata</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearIndex(): BrokerEntryMetadata</TD></TR>
<TR><TD ALIGN="LEFT" >+ copyFrom(_other: BrokerEntryMetadata): BrokerEntryMetadata</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(_buffer: ByteBuf, _size: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(a: byte[])</TD></TR>
<TR><TD ALIGN="LEFT" >+ setBrokerTimestamp(brokerTimestamp: long): BrokerEntryMetadata</TD></TR>
<TR><TD ALIGN="LEFT" >+ setIndex(index: long): BrokerEntryMetadata</TD></TR>
<TR><TD ALIGN="LEFT" >+ toByteArray(): byte[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeTo(_b: ByteBuf): int</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

BrokerInterceptorDefinitions1588982040[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)BrokerInterceptorDefinitions</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   interceptors: Map&lt;String, BrokerInterceptorMetadata&gt; [0..*]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># canEqual(other: Object): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ interceptors(): Map&lt;String, BrokerInterceptorMetadata&gt;</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

BrokerInterceptorDisabled1593963802[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)BrokerInterceptorDisabled</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ initialize(pulsarService: PulsarService)</TD></TR>
<TR><TD ALIGN="LEFT" >+ onConnectionClosed(cnx: ServerCnx)</TD></TR>
<TR><TD ALIGN="LEFT" >+ onPulsarCommand(command: BaseCommand, cnx: ServerCnx)</TD></TR>
<TR><TD ALIGN="LEFT" >+ onWebserviceRequest(request: ServletRequest)</TD></TR>
<TR><TD ALIGN="LEFT" >+ onWebserviceResponse(request: ServletRequest, response: ServletResponse)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

BrokerInterceptorUtils1588982040[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)BrokerInterceptorUtils</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ getBrokerInterceptorDefinition(narPath: String, narExtractionDirectory: String): BrokerInterceptorDefinition</TD></TR>
<TR><TD ALIGN="LEFT" >- getBrokerInterceptorDefinition(ncl: NarClassLoader): BrokerInterceptorDefinition</TD></TR>
<TR><TD ALIGN="LEFT" ># load(metadata: BrokerInterceptorMetadata, narExtractionDirectory: String): BrokerInterceptorWithClassLoader</TD></TR>
<TR><TD ALIGN="LEFT" >- rethrowIOException(cause: Throwable)</TD></TR>
<TR><TD ALIGN="LEFT" >+ searchForInterceptors(interceptorsDirectory: String, narExtractionDirectory: String): BrokerInterceptorDefinitions</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

BrokerInterceptorWithClassLoader1588982040[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)BrokerInterceptorWithClassLoader</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   classLoader: NarClassLoader [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   interceptor: BrokerInterceptor [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ beforeSendMessage(subscription: Subscription, entry: Entry, ackSet: long[], msgMetadata: MessageMetadata)</TD></TR>
<TR><TD ALIGN="LEFT" ># canEqual(other: Object): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ consumerCreated(cnx: ServerCnx, consumer: Consumer, metadata: Map&lt;String, String&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ initialize(pulsarService: PulsarService)</TD></TR>
<TR><TD ALIGN="LEFT" >+ messageAcked(cnx: ServerCnx, consumer: Consumer, ackCmd: CommandAck)</TD></TR>
<TR><TD ALIGN="LEFT" >+ messageDispatched(cnx: ServerCnx, consumer: Consumer, ledgerId: long, entryId: long, headersAndPayload: ByteBuf)</TD></TR>
<TR><TD ALIGN="LEFT" >+ messageProduced(cnx: ServerCnx, producer: Producer, startTimeNs: long, ledgerId: long, entryId: long, publishContext: PublishContext)</TD></TR>
<TR><TD ALIGN="LEFT" >+ onConnectionClosed(cnx: ServerCnx)</TD></TR>
<TR><TD ALIGN="LEFT" >+ onConnectionCreated(cnx: ServerCnx)</TD></TR>
<TR><TD ALIGN="LEFT" >+ onPulsarCommand(command: BaseCommand, cnx: ServerCnx)</TD></TR>
<TR><TD ALIGN="LEFT" >+ onWebserviceRequest(request: ServletRequest)</TD></TR>
<TR><TD ALIGN="LEFT" >+ onWebserviceResponse(request: ServletRequest, response: ServletResponse)</TD></TR>
<TR><TD ALIGN="LEFT" >+ producerCreated(cnx: ServerCnx, producer: Producer, metadata: Map&lt;String, String&gt;)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

BrokerInterceptors1588982040[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)BrokerInterceptors</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   interceptors: Map&lt;String, BrokerInterceptorWithClassLoader&gt; [0..*]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ beforeSendMessage(subscription: Subscription, entry: Entry, ackSet: long[], msgMetadata: MessageMetadata)</TD></TR>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ consumerCreated(cnx: ServerCnx, consumer: Consumer, metadata: Map&lt;String, String&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ initialize(pulsarService: PulsarService)</TD></TR>
<TR><TD ALIGN="LEFT" >+ load(conf: ServiceConfiguration): BrokerInterceptor</TD></TR>
<TR><TD ALIGN="LEFT" >+ messageAcked(cnx: ServerCnx, consumer: Consumer, ackCmd: CommandAck)</TD></TR>
<TR><TD ALIGN="LEFT" >+ messageDispatched(cnx: ServerCnx, consumer: Consumer, ledgerId: long, entryId: long, headersAndPayload: ByteBuf)</TD></TR>
<TR><TD ALIGN="LEFT" >+ messageProduced(cnx: ServerCnx, producer: Producer, startTimeNs: long, ledgerId: long, entryId: long, publishContext: PublishContext)</TD></TR>
<TR><TD ALIGN="LEFT" >+ onConnectionClosed(cnx: ServerCnx)</TD></TR>
<TR><TD ALIGN="LEFT" >+ onConnectionCreated(cnx: ServerCnx)</TD></TR>
<TR><TD ALIGN="LEFT" >+ onPulsarCommand(command: BaseCommand, cnx: ServerCnx)</TD></TR>
<TR><TD ALIGN="LEFT" >+ onWebserviceRequest(request: ServletRequest)</TD></TR>
<TR><TD ALIGN="LEFT" >+ onWebserviceResponse(request: ServletRequest, response: ServletResponse)</TD></TR>
<TR><TD ALIGN="LEFT" >+ producerCreated(cnx: ServerCnx, producer: Producer, metadata: Map&lt;String, String&gt;)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

BrokerNamespaceIsolationDataImpl896442176[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)BrokerNamespaceIsolationDataImpl</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   brokerName: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   isPrimary: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   namespaceRegex: List&lt;String&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   policyName: String [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ builder(): BrokerNamespaceIsolationDataImplBuilder</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

BrokerNamespaceIsolationDataImplBuilder1788550532[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)BrokerNamespaceIsolationDataImplBuilder</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   brokerName: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   isPrimary: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   namespaceRegex: List&lt;String&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   policyName: String [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ brokerName(brokerName: String): BrokerNamespaceIsolationDataImplBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ build(): BrokerNamespaceIsolationDataImpl</TD></TR>
<TR><TD ALIGN="LEFT" >+ namespaceRegex(namespaceRegex: List&lt;String&gt;): BrokerNamespaceIsolationDataImplBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ policyName(policyName: String): BrokerNamespaceIsolationDataImplBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ primary(isPrimary: boolean): BrokerNamespaceIsolationDataImplBuilder</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

BrokerOperabilityMetrics2102807099[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)BrokerOperabilityMetrics</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   brokerName: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   connectionActive: LongAdder [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   connectionCreateFailCount: LongAdder [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   connectionCreateSuccessCount: LongAdder [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   connectionTotalClosedCount: LongAdder [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   connectionTotalCreatedCount: LongAdder [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   localCluster: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   metricsList: List&lt;Metrics&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   topicLoadStats: DimensionStats [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   zkReadLatencyStats: DimensionStats [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   zkWriteLatencyStats: DimensionStats [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- generate()</TD></TR>
<TR><TD ALIGN="LEFT" >+ generateConnectionMetrics(): Metrics</TD></TR>
<TR><TD ALIGN="LEFT" ># getDimensionMap(metricsName: String): Map&lt;String, String&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># getDimensionMetrics(metricsName: String, dimensionName: String, stats: DimensionStats): Metrics</TD></TR>
<TR><TD ALIGN="LEFT" >+ recordConnectionClose()</TD></TR>
<TR><TD ALIGN="LEFT" >+ recordConnectionCreate()</TD></TR>
<TR><TD ALIGN="LEFT" >+ recordConnectionCreateFail()</TD></TR>
<TR><TD ALIGN="LEFT" >+ recordConnectionCreateSuccess()</TD></TR>
<TR><TD ALIGN="LEFT" >+ recordTopicLoadTimeValue(topicLoadLatencyMs: long)</TD></TR>
<TR><TD ALIGN="LEFT" >+ recordZkReadLatencyTimeValue(topicLoadLatencyMs: long)</TD></TR>
<TR><TD ALIGN="LEFT" >+ recordZkWriteLatencyTimeValue(topicLoadLatencyMs: long)</TD></TR>
<TR><TD ALIGN="LEFT" >+ reset()</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

BrokerProxyValidator79518146[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)BrokerProxyValidator</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   allowAnyHostName: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   allowAnyIPAddress: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   allowAnyTargetPort: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   allowedHostNames: List&lt;Pattern&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   allowedIPAddresses: List&lt;IPAddress&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   allowedTargetPorts: int[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   inetSocketAddressResolver: AddressResolver&lt;InetSocketAddress&gt; [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- isHostAllowed(host: String): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >- isIPAddressAllowed(resolvedAddress: InetSocketAddress): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >- isPortAllowed(port: int): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >- parseCommaSeparatedConfigValue(configValue: String): List&lt;String&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- parseWildcardPattern(wildcardPattern: String): Pattern</TD></TR>
<TR><TD ALIGN="LEFT" >+ resolveAndCheckTargetAddress(hostAndPort: String): CompletableFuture&lt;InetSocketAddress&gt;</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

BrokerService1718290011[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)BrokerService</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   acceptorGroup: EventLoopGroup [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   authenticationService: AuthenticationService [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   authorizationService: AuthorizationService [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   backlogQuotaChecker: ScheduledExecutorService [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   backlogQuotaManager: BacklogQuotaManager [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   blockedDispatchers: ConcurrentOpenHashSet&lt;PersistentDispatcherMultipleConsumers&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   brokerDispatchRateLimiter: DispatchRateLimiter [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   brokerEntryMetadataInterceptors: Set&lt;BrokerEntryMetadataInterceptor&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   brokerEntryPayloadProcessors: Set&lt;ManagedLedgerPayloadProcessor&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >#   brokerPublishRateLimiter: PublishRateLimiter [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   brokerPublishRateLimiterMonitor: ScheduledExecutorService [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   bundlesQuotas: BundlesQuotas [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   clusterAdmins: ConcurrentOpenHashMap&lt;String, PulsarAdmin&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   compactionMonitor: ScheduledExecutorService [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   configRegisteredListeners: ConcurrentOpenHashMap&lt;String, Consumer&lt;?&gt;&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   consumedLedgersMonitor: ScheduledExecutorService [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   deduplicationSnapshotMonitor: ScheduledExecutorService [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   defaultServerBootstrap: ServerBootstrap [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   delayedDeliveryTrackerFactory: DelayedDeliveryTrackerFactory [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   entryFilters: ImmutableMap&lt;String, EntryFilterWithClassLoader&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   inactivityMonitor: ScheduledExecutorService [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   interceptor: BrokerInterceptor [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   keepAliveIntervalSeconds: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   listenChannel: Channel [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   listenChannelTls: Channel [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   listenChannels: List&lt;Channel&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   lock: ReadWriteLock [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   lookupRequestSemaphore: AtomicReference&lt;Semaphore&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   managedLedgerFactory: ManagedLedgerFactory [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   maxUnackedMessages: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   maxUnackedMsgsPerDispatcher: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   messageExpiryMonitor: ScheduledExecutorService [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   multiLayerTopicsMap: ConcurrentOpenHashMap&lt;String, ConcurrentOpenHashMap&lt;String, ConcurrentOpenHashMap&lt;String, Topic&gt;&gt;&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   numberOfNamespaceBundles: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   offlineTopicStatCache: ConcurrentOpenHashMap&lt;TopicName, PersistentOfflineTopicStats&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   owningTopics: ConcurrentOpenHashMap&lt;String, ConcurrentOpenHashSet&lt;Integer&gt;&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   pausedConnections: LongAdder [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   pendingLookupRequests: ObserverGauge [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   pendingTopicLoadRequests: ObserverGauge [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   pendingTopicLoadingQueue: ConcurrentLinkedQueue&lt;TopicLoadingContext&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   preciseTopicPublishRateLimitingEnable: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   producerNameGenerator: DistributedIdGenerator [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   protocolHandlersWorkerGroups: List&lt;EventLoopGroup&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   pulsar: PulsarService [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   pulsarChannelInitFactory: Factory [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   pulsarStats: PulsarStats [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   replicationClients: ConcurrentOpenHashMap&lt;String, PulsarClient&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   statsUpdater: ScheduledExecutorService [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   topicLoadRequestSemaphore: AtomicReference&lt;Semaphore&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   topicOrderedExecutor: OrderedExecutor [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   topicPublishRateLimiterMonitor: ScheduledExecutorService [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   topics: ConcurrentOpenHashMap&lt;String, CompletableFuture&lt;Optional&lt;Topic&gt;&gt;&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   workerGroup: EventLoopGroup [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- addDynamicConfigValidator(key: String, validator: Predicate&lt;String&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >- addTopicToStatsMaps(topicName: TopicName, topic: Topic)</TD></TR>
<TR><TD ALIGN="LEFT" >+ addUnAckedMessages(dispatcher: PersistentDispatcherMultipleConsumers, numberOfMessages: int)</TD></TR>
<TR><TD ALIGN="LEFT" >- blockDispatchersWithLargeUnAckMessages()</TD></TR>
<TR><TD ALIGN="LEFT" >+ cacheOfflineTopicStats(topicName: TopicName, offlineTopicStats: PersistentOfflineTopicStats)</TD></TR>
<TR><TD ALIGN="LEFT" >+ checkBrokerPublishThrottlingRate()</TD></TR>
<TR><TD ALIGN="LEFT" >+ checkCompaction()</TD></TR>
<TR><TD ALIGN="LEFT" >- checkConsumedLedgers()</TD></TR>
<TR><TD ALIGN="LEFT" >+ checkGC()</TD></TR>
<TR><TD ALIGN="LEFT" >+ checkInactiveSubscriptions()</TD></TR>
<TR><TD ALIGN="LEFT" >- checkMaxTopicsPerNamespace(topicName: TopicName, numPartitions: int): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ checkMessageDeduplicationInfo()</TD></TR>
<TR><TD ALIGN="LEFT" >+ checkMessageExpiry()</TD></TR>
<TR><TD ALIGN="LEFT" >+ checkReplicationPolicies()</TD></TR>
<TR><TD ALIGN="LEFT" >+ checkTopicNsOwnership(topic: String): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ checkTopicPublishThrottlingRate()</TD></TR>
<TR><TD ALIGN="LEFT" >+ checkUnAckMessageDispatching()</TD></TR>
<TR><TD ALIGN="LEFT" >+ cleanUnloadedTopicFromCache(serviceUnit: NamespaceBundle)</TD></TR>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ closeAndRemoveReplicationClient(clusterName: String): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ closeAsync(): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- closeChannel(channel: Channel): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- configTlsSettings(clientBuilder: ClientBuilder, serviceUrl: String, brokerClientTlsEnabledWithKeyStore: boolean, isTlsAllowInsecureConnection: boolean, brokerClientTlsTrustStoreType: String, brokerClientTlsTrustStore: String, brokerClientTlsTrustStorePassword: String, brokerClientTrustCertsFilePath: String)</TD></TR>
<TR><TD ALIGN="LEFT" >- createDefaultPartitionedTopicAsync(topicName: TopicName): CompletableFuture&lt;PartitionedTopicMetadata&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- createNonPersistentTopic(topic: String): CompletableFuture&lt;Optional&lt;Topic&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- createPendingLoadTopic()</TD></TR>
<TR><TD ALIGN="LEFT" >- createPersistentTopic(topic: String, createIfMissing: boolean, topicFuture: CompletableFuture&lt;Optional&lt;Topic&gt;&gt;, properties: Map&lt;String, String&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >- defaultServerBootstrap(): ServerBootstrap</TD></TR>
<TR><TD ALIGN="LEFT" >+ deleteSchemaStorage(topic: String): CompletableFuture&lt;SchemaVersion&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ deleteTopic(topic: String, forceDelete: boolean): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ deleteTopic(topic: String, forceDelete: boolean, deleteSchema: boolean): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ deleteTopicAuthenticationWithRetry(topic: String, future: CompletableFuture&lt;Void&gt;, count: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ deleteTopicPolicies(topicName: TopicName): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ executor(): EventLoopGroup</TD></TR>
<TR><TD ALIGN="LEFT" >+ extractTopic(topicFuture: CompletableFuture&lt;Optional&lt;Topic&gt;&gt;): Optional&lt;Topic&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ fetchPartitionedTopicMetadataAsync(topicName: TopicName): CompletableFuture&lt;PartitionedTopicMetadata&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ fetchPartitionedTopicMetadataCheckAllowAutoCreationAsync(topicName: TopicName): CompletableFuture&lt;PartitionedTopicMetadata&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ forEachTopic(consumer: Consumer&lt;Topic&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >- foreachCnx(consumer: Consumer&lt;TransportCnx&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >- futureWithDeadline(): CompletableFuture&lt;T&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ generateUniqueProducerName(): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ getAllTopicsFromNamespaceBundle(namespace: String, bundle: String): List&lt;Topic&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- getAutoSubscriptionCreationOverride(topicName: TopicName): AutoSubscriptionCreationOverride</TD></TR>
<TR><TD ALIGN="LEFT" >- getAutoTopicCreationOverride(topicName: TopicName): AutoTopicCreationOverride</TD></TR>
<TR><TD ALIGN="LEFT" >+ getClusterPulsarAdmin(cluster: String, clusterDataOp: Optional&lt;ClusterData&gt;): PulsarAdmin</TD></TR>
<TR><TD ALIGN="LEFT" >+ getDefaultNumPartitions(topicName: TopicName): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ getDimensionMetrics(consumer: Consumer&lt;ByteBuf&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ getManagedLedgerConfig(topicName: TopicName): CompletableFuture&lt;ManagedLedgerConfig&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getOfflineTopicStat(topicName: TopicName): PersistentOfflineTopicStats</TD></TR>
<TR><TD ALIGN="LEFT" >+ getOrCreateTopic(topic: String): CompletableFuture&lt;Topic&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getReplicationClient(cluster: String, clusterDataOp: Optional&lt;ClusterData&gt;): PulsarClient</TD></TR>
<TR><TD ALIGN="LEFT" >+ getTopic(topic: String, createIfMissing: boolean): CompletableFuture&lt;Optional&lt;Topic&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getTopic(topic: String, createIfMissing: boolean, properties: Map&lt;String, String&gt;): CompletableFuture&lt;Optional&lt;Topic&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getTopicIfExists(topic: String): CompletableFuture&lt;Optional&lt;Topic&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getTopicPolicies(topicName: TopicName): Optional&lt;TopicPolicies&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getTopicReference(topic: String): Optional&lt;Topic&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- handleDynamicConfigurationUpdates()</TD></TR>
<TR><TD ALIGN="LEFT" >- handleMetadataChanges(n: Notification)</TD></TR>
<TR><TD ALIGN="LEFT" >- handlePoliciesUpdates(namespace: NamespaceName)</TD></TR>
<TR><TD ALIGN="LEFT" >+ invalidateOfflineTopicStatCache(topicName: TopicName)</TD></TR>
<TR><TD ALIGN="LEFT" >+ isAllowAutoSubscriptionCreation(topic: String): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ isAllowAutoSubscriptionCreation(topicName: TopicName): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ isAllowAutoTopicCreation(topic: String): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ isAllowAutoTopicCreation(topicName: TopicName): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ isDefaultTopicTypePartitioned(topicName: TopicName): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ isDynamicConfiguration(key: String): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >- isSystemTopic(topic: String): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ isTopicNsOwnedByBroker(topicName: TopicName): boolean</TD></TR>
<TR><TD ALIGN="LEFT" ># loadOrCreatePersistentTopic(topic: String, createIfMissing: boolean, properties: Map&lt;String, String&gt;): CompletableFuture&lt;Optional&lt;Topic&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ monitorBacklogQuota()</TD></TR>
<TR><TD ALIGN="LEFT" >+ pausedConnections(numberOfConnections: int)</TD></TR>
<TR><TD ALIGN="LEFT" >- prepareDynamicConfigurationMap(): ConcurrentOpenHashMap&lt;String, ConfigField&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ pulsar(): PulsarService</TD></TR>
<TR><TD ALIGN="LEFT" >- refreshBrokerPublishRate()</TD></TR>
<TR><TD ALIGN="LEFT" >- refreshTopicPublishRate()</TD></TR>
<TR><TD ALIGN="LEFT" >+ refreshTopicToStatsMaps(oldBundle: NamespaceBundle)</TD></TR>
<TR><TD ALIGN="LEFT" >+ registerConfigurationListener(configKey: String, listener: Consumer&lt;T&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ removeTopicFromCache(topic: String): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ removeTopicFromCache(topic: String, namespaceBundle: NamespaceBundle)</TD></TR>
<TR><TD ALIGN="LEFT" >+ resumedConnections(numberOfConnections: int)</TD></TR>
<TR><TD ALIGN="LEFT" ># shutdownEventLoopGracefully(eventLoopGroup: EventLoopGroup): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ start()</TD></TR>
<TR><TD ALIGN="LEFT" ># startBacklogQuotaChecker()</TD></TR>
<TR><TD ALIGN="LEFT" ># startCheckReplicationPolicies()</TD></TR>
<TR><TD ALIGN="LEFT" ># startCompactionMonitor()</TD></TR>
<TR><TD ALIGN="LEFT" ># startConsumedLedgersMonitor()</TD></TR>
<TR><TD ALIGN="LEFT" ># startDeduplicationSnapshotMonitor()</TD></TR>
<TR><TD ALIGN="LEFT" ># startInactivityMonitor()</TD></TR>
<TR><TD ALIGN="LEFT" ># startMessageExpiryMonitor()</TD></TR>
<TR><TD ALIGN="LEFT" >- startProtocolHandler(protocol: String, address: SocketAddress, initializer: ChannelInitializer&lt;SocketChannel&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ startProtocolHandlers(protocolHandlers: Map&lt;String, Map&lt;InetSocketAddress, ChannelInitializer&lt;SocketChannel&gt;&gt;&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" ># startStatsUpdater(statsUpdateInitialDelayInSecs: int, statsUpdateFrequencyInSecs: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ unblockDispatchersOnUnAckMessages(dispatcherList: List&lt;PersistentDispatcherMultipleConsumers&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >- unloadDeletedReplNamespace(data: Policies, namespace: NamespaceName)</TD></TR>
<TR><TD ALIGN="LEFT" >+ unloadNamespaceBundlesGracefully()</TD></TR>
<TR><TD ALIGN="LEFT" >+ unloadNamespaceBundlesGracefully(maxConcurrentUnload: int, closeWithoutWaitingClientDisconnect: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ unloadServiceUnit(serviceUnit: NamespaceBundle, closeWithoutWaitingClientDisconnect: boolean, timeout: long, unit: TimeUnit): CompletableFuture&lt;Integer&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- unloadServiceUnit(serviceUnit: NamespaceBundle, closeWithoutWaitingClientDisconnect: boolean): CompletableFuture&lt;Integer&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- updateBrokerDispatchThrottlingMaxRate()</TD></TR>
<TR><TD ALIGN="LEFT" >- updateBrokerPublisherThrottlingMaxRate()</TD></TR>
<TR><TD ALIGN="LEFT" >- updateBrokerSubscriptionTypesEnabled(subscriptionTypesEnabled: Object)</TD></TR>
<TR><TD ALIGN="LEFT" >- updateConfigurationAndRegisterListeners()</TD></TR>
<TR><TD ALIGN="LEFT" >- updateDynamicServiceConfiguration()</TD></TR>
<TR><TD ALIGN="LEFT" >- updateManagedLedgerConfig()</TD></TR>
<TR><TD ALIGN="LEFT" >+ updateRates()</TD></TR>
<TR><TD ALIGN="LEFT" >- updateReplicatorMessageDispatchRate()</TD></TR>
<TR><TD ALIGN="LEFT" >- updateSubscriptionMessageDispatchRate()</TD></TR>
<TR><TD ALIGN="LEFT" >- updateTopicMessageDispatchRate()</TD></TR>
<TR><TD ALIGN="LEFT" >- validateConfigKey(key: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ validateDynamicConfiguration(key: String, value: String): boolean</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

BrokerServiceException1718290011[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)BrokerServiceException</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ getClientErrorCode(t: Throwable): ServerError</TD></TR>
<TR><TD ALIGN="LEFT" >- getClientErrorCode(t: Throwable, checkCauseIfUnknown: boolean): ServerError</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

BrokerStatsBase229910521[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)BrokerStatsBase</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ getAllocatorStats(allocatorName: String): AllocatorStats</TD></TR>
<TR><TD ALIGN="LEFT" ># internalBrokerResourceAvailability(namespace: NamespaceName): Map&lt;Long, Collection&lt;ResourceUnit&gt;&gt;</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

BrokersBase229910521[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)BrokersBase</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ backlogQuotaCheck(asyncResponse: AsyncResponse)</TD></TR>
<TR><TD ALIGN="LEFT" >- closeAndReCheck(producer: Producer&lt;String&gt;, reader: Reader&lt;String&gt;, topic: Topic, subscriptionName: String): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ deleteDynamicConfiguration(asyncResponse: AsyncResponse, configName: String)</TD></TR>
<TR><TD ALIGN="LEFT" >- doShutDownBrokerGracefully(maxConcurrentUnloadPerSec: int, forcedTerminateTopic: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ getActiveBrokers(asyncResponse: AsyncResponse, cluster: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ getLeaderBroker(asyncResponse: AsyncResponse)</TD></TR>
<TR><TD ALIGN="LEFT" >+ getOwnedNamespaces(cluster: String, broker: String): Map&lt;String, NamespaceOwnershipStatus&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ healthCheck(asyncResponse: AsyncResponse, topicVersion: TopicVersion)</TD></TR>
<TR><TD ALIGN="LEFT" >- healthCheckRecursiveReadNext(reader: Reader&lt;String&gt;, content: String): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- internalDeleteDynamicConfigurationOnMetadataAsync(configName: String): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- internalRunHealthCheck(topicVersion: TopicVersion): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ isReady(asyncResponse: AsyncResponse)</TD></TR>
<TR><TD ALIGN="LEFT" >- persistDynamicConfigurationAsync(configName: String, configValue: String): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ shutDownBrokerGracefully(maxConcurrentUnloadPerSec: int, forcedTerminateTopic: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ updateDynamicConfiguration(asyncResponse: AsyncResponse, configName: String, configValue: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ version(): String</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

Builder156898441[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)Builder</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   bitField0_: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   hash_: ByteString [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   positionBuilder_: SingleFieldBuilderV3&lt;PositionInfo, Builder, PositionInfoOrBuilder&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   position_: PositionInfo [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   version_: long [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ addRepeatedField(field: FieldDescriptor, value: Object): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ build(): IndexEntry</TD></TR>
<TR><TD ALIGN="LEFT" >+ buildPartial(): IndexEntry</TD></TR>
<TR><TD ALIGN="LEFT" >+ clear(): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearField(field: FieldDescriptor): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearHash(): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearOneof(oneof: OneofDescriptor): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearPosition(): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearVersion(): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ clone(): Builder</TD></TR>
<TR><TD ALIGN="LEFT" ># internalGetFieldAccessorTable(): FieldAccessorTable</TD></TR>
<TR><TD ALIGN="LEFT" >- maybeForceBuilderInitialization()</TD></TR>
<TR><TD ALIGN="LEFT" >+ mergeFrom(other: Message): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ mergeFrom(other: IndexEntry): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ mergeFrom(input: CodedInputStream, extensionRegistry: ExtensionRegistryLite): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ mergePosition(value: PositionInfo): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ mergeUnknownFields(unknownFields: UnknownFieldSet): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ setField(field: FieldDescriptor, value: Object): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ setHash(value: ByteString): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ setPosition(value: PositionInfo): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ setPosition(builderForValue: Builder): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ setRepeatedField(field: FieldDescriptor, index: int, value: Object): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ setUnknownFields(unknownFields: UnknownFieldSet): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ setVersion(value: long): Builder</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

Builder1754205562[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)Builder</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   bitField0_: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   indexBuilder_: RepeatedFieldBuilderV3&lt;IndexEntry, Builder, IndexEntryOrBuilder&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   index_: List&lt;IndexEntry&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   schemaData_: ByteString [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ addAllIndex(values: Iterable&lt;? extends IndexEntry&gt;): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ addIndex(value: IndexEntry): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ addIndex(index: int, value: IndexEntry): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ addIndex(builderForValue: Builder): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ addIndex(index: int, builderForValue: Builder): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ addIndexBuilder(): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ addIndexBuilder(index: int): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ addRepeatedField(field: FieldDescriptor, value: Object): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ build(): SchemaEntry</TD></TR>
<TR><TD ALIGN="LEFT" >+ buildPartial(): SchemaEntry</TD></TR>
<TR><TD ALIGN="LEFT" >+ clear(): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearField(field: FieldDescriptor): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearIndex(): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearOneof(oneof: OneofDescriptor): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearSchemaData(): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ clone(): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >- ensureIndexIsMutable()</TD></TR>
<TR><TD ALIGN="LEFT" >+ getIndex(index: int): IndexEntry</TD></TR>
<TR><TD ALIGN="LEFT" >+ getIndexBuilder(index: int): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ getIndexOrBuilder(index: int): IndexEntryOrBuilder</TD></TR>
<TR><TD ALIGN="LEFT" ># internalGetFieldAccessorTable(): FieldAccessorTable</TD></TR>
<TR><TD ALIGN="LEFT" >- maybeForceBuilderInitialization()</TD></TR>
<TR><TD ALIGN="LEFT" >+ mergeFrom(other: Message): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ mergeFrom(other: SchemaEntry): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ mergeFrom(input: CodedInputStream, extensionRegistry: ExtensionRegistryLite): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ mergeUnknownFields(unknownFields: UnknownFieldSet): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ removeIndex(index: int): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ setField(field: FieldDescriptor, value: Object): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ setIndex(index: int, value: IndexEntry): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ setIndex(index: int, builderForValue: Builder): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ setRepeatedField(field: FieldDescriptor, index: int, value: Object): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ setSchemaData(value: ByteString): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ setUnknownFields(unknownFields: UnknownFieldSet): Builder</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

Builder200622178[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)Builder</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   bitField0_: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   indexBuilder_: RepeatedFieldBuilderV3&lt;IndexEntry, Builder, IndexEntryOrBuilder&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   index_: List&lt;IndexEntry&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   infoBuilder_: SingleFieldBuilderV3&lt;IndexEntry, Builder, IndexEntryOrBuilder&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   info_: IndexEntry [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ addAllIndex(values: Iterable&lt;? extends IndexEntry&gt;): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ addIndex(value: IndexEntry): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ addIndex(index: int, value: IndexEntry): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ addIndex(builderForValue: Builder): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ addIndex(index: int, builderForValue: Builder): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ addIndexBuilder(): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ addIndexBuilder(index: int): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ addRepeatedField(field: FieldDescriptor, value: Object): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ build(): SchemaLocator</TD></TR>
<TR><TD ALIGN="LEFT" >+ buildPartial(): SchemaLocator</TD></TR>
<TR><TD ALIGN="LEFT" >+ clear(): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearField(field: FieldDescriptor): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearIndex(): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearInfo(): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearOneof(oneof: OneofDescriptor): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ clone(): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >- ensureIndexIsMutable()</TD></TR>
<TR><TD ALIGN="LEFT" >+ getIndex(index: int): IndexEntry</TD></TR>
<TR><TD ALIGN="LEFT" >+ getIndexBuilder(index: int): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ getIndexOrBuilder(index: int): IndexEntryOrBuilder</TD></TR>
<TR><TD ALIGN="LEFT" ># internalGetFieldAccessorTable(): FieldAccessorTable</TD></TR>
<TR><TD ALIGN="LEFT" >- maybeForceBuilderInitialization()</TD></TR>
<TR><TD ALIGN="LEFT" >+ mergeFrom(other: Message): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ mergeFrom(other: SchemaLocator): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ mergeFrom(input: CodedInputStream, extensionRegistry: ExtensionRegistryLite): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ mergeInfo(value: IndexEntry): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ mergeUnknownFields(unknownFields: UnknownFieldSet): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ removeIndex(index: int): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ setField(field: FieldDescriptor, value: Object): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ setIndex(index: int, value: IndexEntry): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ setIndex(index: int, builderForValue: Builder): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ setInfo(value: IndexEntry): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ setInfo(builderForValue: Builder): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ setRepeatedField(field: FieldDescriptor, index: int, value: Object): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ setUnknownFields(unknownFields: UnknownFieldSet): Builder</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

Builder268846344[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)Builder</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   bitField0_: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   deleted_: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   propsBuilder_: RepeatedFieldBuilderV3&lt;KeyValuePair, Builder, KeyValuePairOrBuilder&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   props_: List&lt;KeyValuePair&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   schemaId_: Object [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   schema_: ByteString [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   timestamp_: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   type_: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   user_: Object [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ addAllProps(values: Iterable&lt;? extends KeyValuePair&gt;): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ addProps(value: KeyValuePair): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ addProps(index: int, value: KeyValuePair): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ addProps(builderForValue: Builder): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ addProps(index: int, builderForValue: Builder): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ addPropsBuilder(): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ addPropsBuilder(index: int): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ addRepeatedField(field: FieldDescriptor, value: Object): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ build(): SchemaInfo</TD></TR>
<TR><TD ALIGN="LEFT" >+ buildPartial(): SchemaInfo</TD></TR>
<TR><TD ALIGN="LEFT" >+ clear(): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearDeleted(): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearField(field: FieldDescriptor): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearOneof(oneof: OneofDescriptor): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearProps(): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearSchema(): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearSchemaId(): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearTimestamp(): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearType(): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearUser(): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ clone(): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >- ensurePropsIsMutable()</TD></TR>
<TR><TD ALIGN="LEFT" >+ getProps(index: int): KeyValuePair</TD></TR>
<TR><TD ALIGN="LEFT" >+ getPropsBuilder(index: int): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ getPropsOrBuilder(index: int): KeyValuePairOrBuilder</TD></TR>
<TR><TD ALIGN="LEFT" ># internalGetFieldAccessorTable(): FieldAccessorTable</TD></TR>
<TR><TD ALIGN="LEFT" >- maybeForceBuilderInitialization()</TD></TR>
<TR><TD ALIGN="LEFT" >+ mergeFrom(other: Message): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ mergeFrom(other: SchemaInfo): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ mergeFrom(input: CodedInputStream, extensionRegistry: ExtensionRegistryLite): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ mergeUnknownFields(unknownFields: UnknownFieldSet): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ removeProps(index: int): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ setDeleted(value: boolean): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ setField(field: FieldDescriptor, value: Object): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ setProps(index: int, value: KeyValuePair): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ setProps(index: int, builderForValue: Builder): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ setRepeatedField(field: FieldDescriptor, index: int, value: Object): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ setSchema(value: ByteString): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ setSchemaId(value: String): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ setSchemaIdBytes(value: ByteString): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ setTimestamp(value: long): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ setType(value: SchemaType): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ setUnknownFields(unknownFields: UnknownFieldSet): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ setUser(value: String): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ setUserBytes(value: ByteString): Builder</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

Builder458501010[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)Builder</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   bitField0_: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   key_: Object [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   value_: Object [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ addRepeatedField(field: FieldDescriptor, value: Object): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ build(): KeyValuePair</TD></TR>
<TR><TD ALIGN="LEFT" >+ buildPartial(): KeyValuePair</TD></TR>
<TR><TD ALIGN="LEFT" >+ clear(): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearField(field: FieldDescriptor): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearKey(): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearOneof(oneof: OneofDescriptor): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearValue(): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ clone(): Builder</TD></TR>
<TR><TD ALIGN="LEFT" ># internalGetFieldAccessorTable(): FieldAccessorTable</TD></TR>
<TR><TD ALIGN="LEFT" >- maybeForceBuilderInitialization()</TD></TR>
<TR><TD ALIGN="LEFT" >+ mergeFrom(other: Message): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ mergeFrom(other: KeyValuePair): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ mergeFrom(input: CodedInputStream, extensionRegistry: ExtensionRegistryLite): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ mergeUnknownFields(unknownFields: UnknownFieldSet): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ setField(field: FieldDescriptor, value: Object): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ setKey(value: String): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ setKeyBytes(value: ByteString): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ setRepeatedField(field: FieldDescriptor, index: int, value: Object): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ setUnknownFields(unknownFields: UnknownFieldSet): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ setValue(value: String): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ setValueBytes(value: ByteString): Builder</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

Builder589409390[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)Builder</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   bitField0_: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   entryId_: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   ledgerId_: long [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ addRepeatedField(field: FieldDescriptor, value: Object): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ build(): PositionInfo</TD></TR>
<TR><TD ALIGN="LEFT" >+ buildPartial(): PositionInfo</TD></TR>
<TR><TD ALIGN="LEFT" >+ clear(): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearEntryId(): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearField(field: FieldDescriptor): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearLedgerId(): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearOneof(oneof: OneofDescriptor): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ clone(): Builder</TD></TR>
<TR><TD ALIGN="LEFT" ># internalGetFieldAccessorTable(): FieldAccessorTable</TD></TR>
<TR><TD ALIGN="LEFT" >- maybeForceBuilderInitialization()</TD></TR>
<TR><TD ALIGN="LEFT" >+ mergeFrom(other: Message): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ mergeFrom(other: PositionInfo): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ mergeFrom(input: CodedInputStream, extensionRegistry: ExtensionRegistryLite): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ mergeUnknownFields(unknownFields: UnknownFieldSet): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ setEntryId(value: long): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ setField(field: FieldDescriptor, value: Object): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ setLedgerId(value: long): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ setRepeatedField(field: FieldDescriptor, index: int, value: Object): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ setUnknownFields(unknownFields: UnknownFieldSet): Builder</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

BundlesDataImpl1043561458[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)BundlesDataImpl</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   boundaries: List&lt;String&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   numBundles: int [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ builder(): BundlesDataImplBuilder</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

BundlesDataImplBuilder1326424635[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)BundlesDataImplBuilder</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   boundaries: List&lt;String&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   numBundles: int [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ boundaries(boundaries: List&lt;String&gt;): BundlesDataImplBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ build(): BundlesDataImpl</TD></TR>
<TR><TD ALIGN="LEFT" >+ numBundles(numBundles: int): BundlesDataImplBuilder</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

BundlesQuotas2118147928[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)BundlesQuotas</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   resourceQuotaCache: MetadataCache&lt;ResourceQuota&gt; [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ getResourceQuota(bundle: NamespaceBundle): CompletableFuture&lt;ResourceQuota&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getResourceQuota(bundle: String): CompletableFuture&lt;ResourceQuota&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ resetResourceQuota(bundle: NamespaceBundle): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ setDefaultResourceQuota(quota: ResourceQuota): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ setResourceQuota(bundle: String, quota: ResourceQuota): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ setResourceQuota(bundle: NamespaceBundle, quota: ResourceQuota): CompletableFuture&lt;Void&gt;</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

ByteBufPair1070348832[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)ByteBufPair</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   b1: ByteBuf [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   b2: ByteBuf [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   recyclerHandle: Handle&lt;ByteBufPair&gt; [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ coalesce(pair: ByteBufPair): ByteBuf</TD></TR>
<TR><TD ALIGN="LEFT" ># deallocate()</TD></TR>
<TR><TD ALIGN="LEFT" >+ get(b1: ByteBuf, b2: ByteBuf): ByteBufPair</TD></TR>
<TR><TD ALIGN="LEFT" >+ readableBytes(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ touch(hint: Object): ReferenceCounted</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

ByteBufSchema1622012615[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)ByteBufSchema</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ decode(bytes: byte[]): ByteBuf</TD></TR>
<TR><TD ALIGN="LEFT" >+ decode(byteBuf: ByteBuf): ByteBuf</TD></TR>
<TR><TD ALIGN="LEFT" >+ encode(message: ByteBuf): byte[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ of(): ByteBufSchema</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

ByteBufferSchema1622012615[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)ByteBufferSchema</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ decode(data: byte[]): ByteBuffer</TD></TR>
<TR><TD ALIGN="LEFT" >+ decode(byteBuffer: ByteBuf): ByteBuffer</TD></TR>
<TR><TD ALIGN="LEFT" >+ decode(byteBuffer: ByteBuffer, schemaVersion: byte[]): ByteBuffer</TD></TR>
<TR><TD ALIGN="LEFT" >+ encode(data: ByteBuffer): byte[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ of(): ByteBufferSchema</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

ByteBufferSchemaWrapper1184234151[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)ByteBufferSchemaWrapper</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   original: Supplier&lt;SchemaInfo&gt; [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ clone(): Schema&lt;ByteBuffer&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ decode(bytes: byte[], schemaVersion: byte[]): ByteBuffer</TD></TR>
<TR><TD ALIGN="LEFT" >+ encode(message: ByteBuffer): byte[]</TD></TR>
<TR><TD ALIGN="LEFT" ># getBytes(buffer: ByteBuffer): byte[]</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

ByteBufferSerDe82010421[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)ByteBufferSerDe</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ deserialize(bytes: byte[]): Integer</TD></TR>
<TR><TD ALIGN="LEFT" >+ serialize(integer: Integer): byte[]</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

ByteSchema1622012615[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)ByteSchema</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ decode(bytes: byte[]): Byte</TD></TR>
<TR><TD ALIGN="LEFT" >+ decode(byteBuf: ByteBuf): Byte</TD></TR>
<TR><TD ALIGN="LEFT" >+ encode(message: Byte): byte[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ of(): ByteSchema</TD></TR>
<TR><TD ALIGN="LEFT" >+ validate(message: byte[])</TD></TR>
<TR><TD ALIGN="LEFT" >+ validate(message: ByteBuf)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

BytesSchema1622012615[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)BytesSchema</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ decode(bytes: byte[]): byte[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ decode(byteBuf: ByteBuf): byte[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ encode(message: byte[]): byte[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ of(): BytesSchema</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

BytesSchemaVersion1472480913[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)BytesSchemaVersion</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   bytes: byte[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   hashCode: int [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ bytes(): byte[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ compareTo(that: BytesSchemaVersion): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ of(bytes: byte[]): BytesSchemaVersion</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

ChannelFutures343630530[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)ChannelFutures</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ toCompletableFuture(channelFuture: ChannelFuture): CompletableFuture&lt;Channel&gt;</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

Child1346619936[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)Child</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   logger: DataSketchesSummaryLogger [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   quantiles: List&lt;Double&gt; [0..*]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ observe(eventLatency: long, unit: TimeUnit)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

ChunkMessageIdImpl12001400[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)ChunkMessageIdImpl</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   firstChunkMsgId: MessageIdImpl [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ toByteArray(): byte[]</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

ClientBuilderImpl12001400[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)ClientBuilderImpl</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   conf: ClientConfigurationData [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ allowTlsInsecureConnection(tlsAllowInsecureConnection: boolean): ClientBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ authentication(authentication: Authentication): ClientBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ authentication(authPluginClassName: String, authParamsString: String): ClientBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ authentication(authPluginClassName: String, authParams: Map&lt;String, String&gt;): ClientBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ build(): PulsarClient</TD></TR>
<TR><TD ALIGN="LEFT" >+ clock(clock: Clock): ClientBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ clone(): ClientBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ connectionTimeout(duration: int, unit: TimeUnit): ClientBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ connectionsPerBroker(connectionsPerBroker: int): ClientBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ dnsLookupBind(address: String, port: int): ClientBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ enableBusyWait(enableBusyWait: boolean): ClientBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ enableTcpNoDelay(useTcpNoDelay: boolean): ClientBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ enableTls(useTls: boolean): ClientBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ enableTlsHostnameVerification(enableTlsHostnameVerification: boolean): ClientBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ enableTransaction(enableTransaction: boolean): ClientBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ ioThreads(numIoThreads: int): ClientBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ keepAliveInterval(keepAliveInterval: int, unit: TimeUnit): ClientBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ listenerName(listenerName: String): ClientBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ listenerThreads(numListenerThreads: int): ClientBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ loadConf(config: Map&lt;String, Object&gt;): ClientBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ lookupTimeout(lookupTimeout: int, unit: TimeUnit): ClientBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ maxBackoffInterval(duration: long, unit: TimeUnit): ClientBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ maxConcurrentLookupRequests(concurrentLookupRequests: int): ClientBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ maxLookupRedirects(maxLookupRedirects: int): ClientBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ maxLookupRequests(maxLookupRequests: int): ClientBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ maxNumberOfRejectedRequestPerConnection(maxNumberOfRejectedRequestPerConnection: int): ClientBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ memoryLimit(memoryLimit: long, unit: SizeUnit): ClientBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ operationTimeout(operationTimeout: int, unit: TimeUnit): ClientBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ proxyServiceUrl(proxyServiceUrl: String, proxyProtocol: ProxyProtocol): ClientBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ serviceUrl(serviceUrl: String): ClientBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ serviceUrlProvider(serviceUrlProvider: ServiceUrlProvider): ClientBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ socks5ProxyAddress(socks5ProxyAddress: InetSocketAddress): ClientBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ socks5ProxyPassword(socks5ProxyPassword: String): ClientBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ socks5ProxyUsername(socks5ProxyUsername: String): ClientBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ sslProvider(sslProvider: String): ClientBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ startingBackoffInterval(duration: long, unit: TimeUnit): ClientBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ statsInterval(statsInterval: long, unit: TimeUnit): ClientBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ tlsCiphers(tlsCiphers: Set&lt;String&gt;): ClientBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ tlsProtocols(tlsProtocols: Set&lt;String&gt;): ClientBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ tlsTrustCertsFilePath(tlsTrustCertsFilePath: String): ClientBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ tlsTrustStorePassword(tlsTrustStorePassword: String): ClientBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ tlsTrustStorePath(tlsTrustStorePath: String): ClientBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ tlsTrustStoreType(tlsTrustStoreType: String): ClientBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ useKeyStoreTls(useKeyStoreTls: boolean): ClientBuilder</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

ClientCnx12001400[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)ClientCnx</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   authentication: Authentication [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   authenticationDataProvider: AuthenticationDataProvider [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   connectionFuture: CompletableFuture&lt;Void&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   consumers: ConcurrentLongHashMap&lt;ConsumerImpl&lt;?&gt;&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   eventLoopGroup: EventLoopGroup [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   isTlsHostnameVerificationEnable: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   localAddress: SocketAddress [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   maxLookupRequestSemaphore: Semaphore [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   maxNumberOfRejectedRequestPerConnection: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   numberOfRejectRequests: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   operationTimeoutMs: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   pendingLookupRequestSemaphore: Semaphore [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   pendingRequests: ConcurrentLongHashMap&lt;TimedCompletableFuture&lt;? extends Object&gt;&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   producers: ConcurrentLongHashMap&lt;ProducerImpl&lt;?&gt;&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   protocolVersion: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   proxyToTargetBrokerAddress: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   rejectedRequestResetTimeSec: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   remoteAddress: SocketAddress [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   remoteHostName: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   requestTimeoutQueue: ConcurrentLinkedQueue&lt;RequestTime&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   state: State [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   timeoutTask: ScheduledFuture&lt;?&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   transactionBufferHandler: TransactionBufferHandler [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   transactionMetaStoreHandlers: ConcurrentLongHashMap&lt;TransactionMetaStoreHandler&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   waitingLookupRequests: Queue&lt;Pair&lt;Long, Pair&lt;ByteBuf, TimedCompletableFuture&lt;LookupDataResult&gt;&gt;&gt;&gt; [0..*]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- addPendingLookupRequests(requestId: long, future: TimedCompletableFuture&lt;LookupDataResult&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >- buildError(requestId: long, errorMsg: String): String</TD></TR>
<TR><TD ALIGN="LEFT" ># channel(): Channel</TD></TR>
<TR><TD ALIGN="LEFT" >+ channelActive(ctx: ChannelHandlerContext)</TD></TR>
<TR><TD ALIGN="LEFT" >+ channelInactive(ctx: ChannelHandlerContext)</TD></TR>
<TR><TD ALIGN="LEFT" >- checkAndGetTransactionBufferHandler(): TransactionBufferHandler</TD></TR>
<TR><TD ALIGN="LEFT" >- checkAndGetTransactionMetaStoreHandler(tcId: long): TransactionMetaStoreHandler</TD></TR>
<TR><TD ALIGN="LEFT" >- checkRequestTimeout()</TD></TR>
<TR><TD ALIGN="LEFT" >- checkServerError(error: ServerError, errMsg: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" ># connectionFuture(): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ ctx(): ChannelHandlerContext</TD></TR>
<TR><TD ALIGN="LEFT" >+ exceptionCaught(ctx: ChannelHandlerContext, cause: Throwable)</TD></TR>
<TR><TD ALIGN="LEFT" >- getAndRemovePendingLookupRequest(requestId: long): CompletableFuture&lt;LookupDataResult&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getPulsarClientException(error: ServerError, errorMsg: String): PulsarClientException</TD></TR>
<TR><TD ALIGN="LEFT" ># handleAckResponse(ackResponse: CommandAckResponse)</TD></TR>
<TR><TD ALIGN="LEFT" ># handleActiveConsumerChange(change: CommandActiveConsumerChange)</TD></TR>
<TR><TD ALIGN="LEFT" ># handleAddPartitionToTxnResponse(command: CommandAddPartitionToTxnResponse)</TD></TR>
<TR><TD ALIGN="LEFT" ># handleAddSubscriptionToTxnResponse(command: CommandAddSubscriptionToTxnResponse)</TD></TR>
<TR><TD ALIGN="LEFT" ># handleAuthChallenge(authChallenge: CommandAuthChallenge)</TD></TR>
<TR><TD ALIGN="LEFT" ># handleCloseConsumer(closeConsumer: CommandCloseConsumer)</TD></TR>
<TR><TD ALIGN="LEFT" ># handleCloseProducer(closeProducer: CommandCloseProducer)</TD></TR>
<TR><TD ALIGN="LEFT" ># handleConnected(connected: CommandConnected)</TD></TR>
<TR><TD ALIGN="LEFT" ># handleEndTxnOnPartitionResponse(command: CommandEndTxnOnPartitionResponse)</TD></TR>
<TR><TD ALIGN="LEFT" ># handleEndTxnOnSubscriptionResponse(command: CommandEndTxnOnSubscriptionResponse)</TD></TR>
<TR><TD ALIGN="LEFT" ># handleEndTxnResponse(command: CommandEndTxnResponse)</TD></TR>
<TR><TD ALIGN="LEFT" ># handleError(error: CommandError)</TD></TR>
<TR><TD ALIGN="LEFT" ># handleGetLastMessageIdSuccess(success: CommandGetLastMessageIdResponse)</TD></TR>
<TR><TD ALIGN="LEFT" ># handleGetOrCreateSchemaResponse(commandGetOrCreateSchemaResponse: CommandGetOrCreateSchemaResponse)</TD></TR>
<TR><TD ALIGN="LEFT" ># handleGetSchemaResponse(commandGetSchemaResponse: CommandGetSchemaResponse)</TD></TR>
<TR><TD ALIGN="LEFT" ># handleGetTopicsOfNamespaceSuccess(success: CommandGetTopicsOfNamespaceResponse)</TD></TR>
<TR><TD ALIGN="LEFT" ># handleLookupResponse(lookupResult: CommandLookupTopicResponse)</TD></TR>
<TR><TD ALIGN="LEFT" ># handleMessage(cmdMessage: CommandMessage, headersAndPayload: ByteBuf)</TD></TR>
<TR><TD ALIGN="LEFT" ># handleNewTxnResponse(command: CommandNewTxnResponse)</TD></TR>
<TR><TD ALIGN="LEFT" ># handlePartitionResponse(lookupResult: CommandPartitionedTopicMetadataResponse)</TD></TR>
<TR><TD ALIGN="LEFT" ># handleProducerSuccess(success: CommandProducerSuccess)</TD></TR>
<TR><TD ALIGN="LEFT" ># handleReachedEndOfTopic(commandReachedEndOfTopic: CommandReachedEndOfTopic)</TD></TR>
<TR><TD ALIGN="LEFT" ># handleSendError(sendError: CommandSendError)</TD></TR>
<TR><TD ALIGN="LEFT" ># handleSendReceipt(sendReceipt: CommandSendReceipt)</TD></TR>
<TR><TD ALIGN="LEFT" ># handleSuccess(success: CommandSuccess)</TD></TR>
<TR><TD ALIGN="LEFT" ># handleTcClientConnectResponse(response: CommandTcClientConnectResponse)</TD></TR>
<TR><TD ALIGN="LEFT" >- incrementRejectsAndMaybeClose()</TD></TR>
<TR><TD ALIGN="LEFT" >+ isKnownException(t: Throwable): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ newAckForReceipt(request: ByteBuf, requestId: long): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ newAckForReceiptWithFuture(request: ByteBuf, requestId: long, future: TimedCompletableFuture&lt;Void&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" ># newConnectCommand(): ByteBuf</TD></TR>
<TR><TD ALIGN="LEFT" >+ newGetTopicsOfNamespace(request: ByteBuf, requestId: long): CompletableFuture&lt;List&lt;String&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ newLookup(request: ByteBuf, requestId: long): CompletableFuture&lt;LookupDataResult&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># newPromise(): Promise&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># registerConsumer(consumerId: long, consumer: ConsumerImpl&lt;?&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" ># registerProducer(producerId: long, producer: ProducerImpl&lt;?&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ registerTransactionBufferHandler(handler: TransactionBufferHandler)</TD></TR>
<TR><TD ALIGN="LEFT" ># registerTransactionMetaStoreHandler(transactionMetaStoreId: long, handler: TransactionMetaStoreHandler)</TD></TR>
<TR><TD ALIGN="LEFT" ># removeConsumer(consumerId: long)</TD></TR>
<TR><TD ALIGN="LEFT" ># removeProducer(producerId: long)</TD></TR>
<TR><TD ALIGN="LEFT" >+ sendGetLastMessageId(request: ByteBuf, requestId: long): CompletableFuture&lt;CommandGetLastMessageIdResponse&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ sendGetOrCreateSchema(request: ByteBuf, requestId: long): CompletableFuture&lt;byte[]&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ sendGetRawSchema(request: ByteBuf, requestId: long): CompletableFuture&lt;CommandGetSchemaResponse&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ sendGetSchema(request: ByteBuf, requestId: long): CompletableFuture&lt;Optional&lt;SchemaInfo&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- sendRequestAndHandleTimeout(requestMessage: ByteBuf, requestId: long, requestType: RequestType, flush: boolean, future: TimedCompletableFuture&lt;T&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >- sendRequestAndHandleTimeout(requestMessage: ByteBuf, requestId: long, requestType: RequestType, flush: boolean): CompletableFuture&lt;T&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># sendRequestWithId(cmd: ByteBuf, requestId: long): CompletableFuture&lt;ProducerResponse&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># serverAddrees(): SocketAddress</TD></TR>
<TR><TD ALIGN="LEFT" >- verifyTlsHostName(hostname: String, ctx: ChannelHandlerContext): boolean</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

ClientConfigurationData1053524534[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)ClientConfigurationData</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   authParamMap: Map&lt;String, String&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   authParams: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   authPluginClassName: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   authentication: Authentication [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   clock: Clock [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   concurrentLookupRequest: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   connectionTimeoutMs: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   connectionsPerBroker: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   dnsLookupBindAddress: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   dnsLookupBindPort: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   enableBusyWait: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   enableTransaction: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   initialBackoffIntervalNanos: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   keepAliveIntervalSeconds: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   listenerName: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   lookupTimeoutMs: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   maxBackoffIntervalNanos: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   maxLookupRedirects: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   maxLookupRequest: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   maxNumberOfRejectedRequestPerConnection: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   memoryLimitBytes: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   numIoThreads: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   numListenerThreads: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   operationTimeoutMs: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   proxyProtocol: ProxyProtocol [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   proxyServiceUrl: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   requestTimeoutMs: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   serviceUrl: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   serviceUrlProvider: ServiceUrlProvider [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   socks5ProxyAddress: InetSocketAddress [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   socks5ProxyPassword: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   socks5ProxyUsername: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   sslProvider: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   statsIntervalSeconds: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   tlsAllowInsecureConnection: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   tlsCiphers: Set&lt;String&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   tlsHostnameVerificationEnable: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   tlsProtocols: Set&lt;String&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   tlsTrustCertsFilePath: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   tlsTrustStorePassword: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   tlsTrustStorePath: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   tlsTrustStoreType: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   useKeyStoreTls: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   useTcpNoDelay: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   useTls: boolean [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># canEqual(other: Object): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ clone(): ClientConfigurationData</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

ClusterDataImpl896442176[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)ClusterDataImpl</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   authenticationParameters: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   authenticationPlugin: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   brokerClientTlsEnabled: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   brokerClientTlsEnabledWithKeyStore: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   brokerClientTlsTrustStore: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   brokerClientTlsTrustStorePassword: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   brokerClientTlsTrustStoreType: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   brokerClientTrustCertsFilePath: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   brokerServiceUrl: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   brokerServiceUrlTls: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   listenerName: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   peerClusterNames: LinkedHashSet&lt;String&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   proxyProtocol: ProxyProtocol [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   proxyServiceUrl: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   serviceUrl: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   serviceUrlTls: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   tlsAllowInsecureConnection: boolean [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ builder(): ClusterDataImplBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ clone(): ClusterDataImplBuilder</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

ClusterDataImplBuilder1597469238[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)ClusterDataImplBuilder</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   authenticationParameters: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   authenticationPlugin: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   brokerClientTlsEnabled: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   brokerClientTlsEnabledWithKeyStore: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   brokerClientTlsTrustStore: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   brokerClientTlsTrustStorePassword: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   brokerClientTlsTrustStoreType: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   brokerClientTrustCertsFilePath: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   brokerServiceUrl: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   brokerServiceUrlTls: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   listenerName: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   peerClusterNames: LinkedHashSet&lt;String&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   proxyProtocol: ProxyProtocol [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   proxyServiceUrl: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   serviceUrl: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   serviceUrlTls: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   tlsAllowInsecureConnection: boolean [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ authenticationParameters(authenticationParameters: String): ClusterDataImplBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ authenticationPlugin(authenticationPlugin: String): ClusterDataImplBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ brokerClientTlsEnabled(brokerClientTlsEnabled: boolean): ClusterDataImplBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ brokerClientTlsEnabledWithKeyStore(brokerClientTlsEnabledWithKeyStore: boolean): ClusterDataImplBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ brokerClientTlsTrustStore(brokerClientTlsTrustStore: String): ClusterDataImplBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ brokerClientTlsTrustStorePassword(brokerClientTlsTrustStorePassword: String): ClusterDataImplBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ brokerClientTlsTrustStoreType(brokerClientTlsTrustStoreType: String): ClusterDataImplBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ brokerClientTrustCertsFilePath(brokerClientTrustCertsFilePath: String): ClusterDataImplBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ brokerServiceUrl(brokerServiceUrl: String): ClusterDataImplBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ brokerServiceUrlTls(brokerServiceUrlTls: String): ClusterDataImplBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ build(): ClusterDataImpl</TD></TR>
<TR><TD ALIGN="LEFT" ># canEqual(other: Object): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ listenerName(listenerName: String): ClusterDataImplBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ peerClusterNames(peerClusterNames: LinkedHashSet&lt;String&gt;): ClusterDataImplBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ proxyProtocol(proxyProtocol: ProxyProtocol): ClusterDataImplBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ proxyServiceUrl(proxyServiceUrl: String): ClusterDataImplBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ serviceUrl(serviceUrl: String): ClusterDataImplBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ serviceUrlTls(serviceUrlTls: String): ClusterDataImplBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ tlsAllowInsecureConnection(tlsAllowInsecureConnection: boolean): ClusterDataImplBuilder</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

ClusterReplicationMetrics2102807099[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)ClusterReplicationMetrics</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   localCluster: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   metricsEnabled: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   metricsList: List&lt;Metrics&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   metricsMap: ConcurrentOpenHashMap&lt;String, ReplicationMetrics&gt; [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- add(namespace: String, remote: String, replicationMetrics: ReplicationMetrics)</TD></TR>
<TR><TD ALIGN="LEFT" >- generate()</TD></TR>
<TR><TD ALIGN="LEFT" >+ get(namespaceCluster: String): ReplicationMetrics</TD></TR>
<TR><TD ALIGN="LEFT" >+ getKeyName(namespace: String, cluster: String): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ put(namespaceCluster: String, replicationMetrics: ReplicationMetrics)</TD></TR>
<TR><TD ALIGN="LEFT" >+ remove(namespaceCluster: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ reset()</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

ClusterResources220376139[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)ClusterResources</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   failureDomainResources: FailureDomainResources [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ clusterExists(clusterName: String): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ clusterExistsAsync(clusterName: String): CompletableFuture&lt;Boolean&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ clusterNameFromPath(path: String): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ createCluster(clusterName: String, clusterData: ClusterData)</TD></TR>
<TR><TD ALIGN="LEFT" >+ deleteCluster(clusterName: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ getCluster(clusterName: String): Optional&lt;ClusterData&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getClusterAsync(clusterName: String): CompletableFuture&lt;Optional&lt;ClusterData&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getNamespacesForCluster(tenant: String, clusterName: String): List&lt;String&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ isClusterUsed(clusterName: String): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ list(): Set&lt;String&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ listAsync(): CompletableFuture&lt;Set&lt;String&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ pathRepresentsClusterName(path: String): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ updateCluster(clusterName: String, modifyFunction: Function&lt;ClusterData, ClusterData&gt;)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

ClusterServiceCoordinator1316119764[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)ClusterServiceCoordinator</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   executor: ScheduledExecutorService [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   isLeader: Supplier&lt;Boolean&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   leaderService: LeaderService [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   tasks: Map&lt;String, TimerTaskInfo&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   workerId: String [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ addTask(taskName: String, interval: long, task: Runnable)</TD></TR>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ start()</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

Clusters620988779[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)Clusters</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

ClustersBase229910521[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)ClustersBase</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ createCluster(cluster: String, clusterData: ClusterDataImpl)</TD></TR>
<TR><TD ALIGN="LEFT" >+ deleteCluster(cluster: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ deleteFailureDomain(cluster: String, domainName: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ deleteNamespaceIsolationPolicy(cluster: String, policyName: String)</TD></TR>
<TR><TD ALIGN="LEFT" >- filterAndUnloadMatchedNameSpaces(asyncResponse: AsyncResponse, policyData: NamespaceIsolationDataImpl)</TD></TR>
<TR><TD ALIGN="LEFT" >+ getBrokerWithNamespaceIsolationPolicy(cluster: String, broker: String): BrokerNamespaceIsolationData</TD></TR>
<TR><TD ALIGN="LEFT" >+ getBrokersWithNamespaceIsolationPolicy(cluster: String): List&lt;BrokerNamespaceIsolationData&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getCluster(cluster: String): ClusterData</TD></TR>
<TR><TD ALIGN="LEFT" >+ getDomain(cluster: String, domainName: String): FailureDomainImpl</TD></TR>
<TR><TD ALIGN="LEFT" >+ getFailureDomains(cluster: String): Map&lt;String, FailureDomainImpl&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getNamespaceIsolationPolicies(cluster: String): Map&lt;String, ? extends NamespaceIsolationData&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getNamespaceIsolationPolicy(cluster: String, policyName: String): NamespaceIsolationData</TD></TR>
<TR><TD ALIGN="LEFT" >+ getPeerCluster(cluster: String): Set&lt;String&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- unloadMatchedNamespacesList(asyncResponse: AsyncResponse, nssToUnload: List&lt;String&gt;, namespaces: Namespaces)</TD></TR>
<TR><TD ALIGN="LEFT" >+ updateCluster(cluster: String, clusterData: ClusterDataImpl)</TD></TR>
<TR><TD ALIGN="LEFT" >- validateBrokerExistsInOtherDomain(cluster: String, inputDomainName: String, inputDomain: FailureDomainImpl)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

Codec1762718902[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)Codec</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ decode(s: String): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ encode(s: String): String</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

CommandAck297559756[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)CommandAck</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   _bitField0: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _cachedSize: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _messageIdsCount: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _parsedBuffer: ByteBuf [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _propertiesCount: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   ackType: AckType [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   consumerId: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   messageIds: List&lt;MessageIdData&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   properties: List&lt;KeyLongValue&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   requestId: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   txnidLeastBits: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   txnidMostBits: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   validationError: ValidationError [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ addAllMessageIds(messageIds: Iterable&lt;MessageIdData&gt;): CommandAck</TD></TR>
<TR><TD ALIGN="LEFT" >+ addAllProperties(properties: Iterable&lt;KeyLongValue&gt;): CommandAck</TD></TR>
<TR><TD ALIGN="LEFT" >+ addMessageId(): MessageIdData</TD></TR>
<TR><TD ALIGN="LEFT" >+ addProperty(): KeyLongValue</TD></TR>
<TR><TD ALIGN="LEFT" >- checkRequiredFields()</TD></TR>
<TR><TD ALIGN="LEFT" >+ clear(): CommandAck</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearAckType(): CommandAck</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearConsumerId(): CommandAck</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearMessageId(): CommandAck</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearProperties(): CommandAck</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearRequestId(): CommandAck</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearTxnidLeastBits(): CommandAck</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearTxnidMostBits(): CommandAck</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearValidationError(): CommandAck</TD></TR>
<TR><TD ALIGN="LEFT" >+ copyFrom(_other: CommandAck): CommandAck</TD></TR>
<TR><TD ALIGN="LEFT" >+ getMessageIdAt(idx: int): MessageIdData</TD></TR>
<TR><TD ALIGN="LEFT" >+ getPropertyAt(idx: int): KeyLongValue</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(_buffer: ByteBuf, _size: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(a: byte[])</TD></TR>
<TR><TD ALIGN="LEFT" >+ setAckType(ackType: AckType): CommandAck</TD></TR>
<TR><TD ALIGN="LEFT" >+ setConsumerId(consumerId: long): CommandAck</TD></TR>
<TR><TD ALIGN="LEFT" >+ setRequestId(requestId: long): CommandAck</TD></TR>
<TR><TD ALIGN="LEFT" >+ setTxnidLeastBits(txnidLeastBits: long): CommandAck</TD></TR>
<TR><TD ALIGN="LEFT" >+ setTxnidMostBits(txnidMostBits: long): CommandAck</TD></TR>
<TR><TD ALIGN="LEFT" >+ setValidationError(validationError: ValidationError): CommandAck</TD></TR>
<TR><TD ALIGN="LEFT" >+ toByteArray(): byte[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeTo(_b: ByteBuf): int</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

CommandAckResponse297559756[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)CommandAckResponse</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   _bitField0: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _cachedSize: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _messageBufferIdx: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _messageBufferLen: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _parsedBuffer: ByteBuf [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   consumerId: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   error: ServerError [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   message: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   requestId: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   txnidLeastBits: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   txnidMostBits: long [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- checkRequiredFields()</TD></TR>
<TR><TD ALIGN="LEFT" >+ clear(): CommandAckResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearConsumerId(): CommandAckResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearError(): CommandAckResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearMessage(): CommandAckResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearRequestId(): CommandAckResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearTxnidLeastBits(): CommandAckResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearTxnidMostBits(): CommandAckResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ copyFrom(_other: CommandAckResponse): CommandAckResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(_buffer: ByteBuf, _size: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(a: byte[])</TD></TR>
<TR><TD ALIGN="LEFT" >+ setConsumerId(consumerId: long): CommandAckResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ setError(error: ServerError): CommandAckResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ setMessage(message: String): CommandAckResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ setRequestId(requestId: long): CommandAckResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ setTxnidLeastBits(txnidLeastBits: long): CommandAckResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ setTxnidMostBits(txnidMostBits: long): CommandAckResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ toByteArray(): byte[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeTo(_b: ByteBuf): int</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

CommandActiveConsumerChange297559756[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)CommandActiveConsumerChange</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   _bitField0: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _cachedSize: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _parsedBuffer: ByteBuf [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   consumerId: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   isActive: boolean [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- checkRequiredFields()</TD></TR>
<TR><TD ALIGN="LEFT" >+ clear(): CommandActiveConsumerChange</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearConsumerId(): CommandActiveConsumerChange</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearIsActive(): CommandActiveConsumerChange</TD></TR>
<TR><TD ALIGN="LEFT" >+ copyFrom(_other: CommandActiveConsumerChange): CommandActiveConsumerChange</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(_buffer: ByteBuf, _size: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(a: byte[])</TD></TR>
<TR><TD ALIGN="LEFT" >+ setConsumerId(consumerId: long): CommandActiveConsumerChange</TD></TR>
<TR><TD ALIGN="LEFT" >+ setIsActive(isActive: boolean): CommandActiveConsumerChange</TD></TR>
<TR><TD ALIGN="LEFT" >+ toByteArray(): byte[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeTo(_b: ByteBuf): int</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

CommandAddPartitionToTxn297559756[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)CommandAddPartitionToTxn</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   _bitField0: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _cachedSize: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _parsedBuffer: ByteBuf [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _partitionsCount: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   partitions: List&lt;StringHolder&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   requestId: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   txnidLeastBits: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   txnidMostBits: long [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- _newPartitionStringHolder(): StringHolder</TD></TR>
<TR><TD ALIGN="LEFT" >+ addAllPartitions(partitions: Iterable&lt;String&gt;): CommandAddPartitionToTxn</TD></TR>
<TR><TD ALIGN="LEFT" >+ addPartition(partition: String)</TD></TR>
<TR><TD ALIGN="LEFT" >- checkRequiredFields()</TD></TR>
<TR><TD ALIGN="LEFT" >+ clear(): CommandAddPartitionToTxn</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearPartitions(): CommandAddPartitionToTxn</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearRequestId(): CommandAddPartitionToTxn</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearTxnidLeastBits(): CommandAddPartitionToTxn</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearTxnidMostBits(): CommandAddPartitionToTxn</TD></TR>
<TR><TD ALIGN="LEFT" >+ copyFrom(_other: CommandAddPartitionToTxn): CommandAddPartitionToTxn</TD></TR>
<TR><TD ALIGN="LEFT" >+ getPartitionAt(idx: int): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(_buffer: ByteBuf, _size: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(a: byte[])</TD></TR>
<TR><TD ALIGN="LEFT" >+ setRequestId(requestId: long): CommandAddPartitionToTxn</TD></TR>
<TR><TD ALIGN="LEFT" >+ setTxnidLeastBits(txnidLeastBits: long): CommandAddPartitionToTxn</TD></TR>
<TR><TD ALIGN="LEFT" >+ setTxnidMostBits(txnidMostBits: long): CommandAddPartitionToTxn</TD></TR>
<TR><TD ALIGN="LEFT" >+ toByteArray(): byte[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeTo(_b: ByteBuf): int</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

CommandAddPartitionToTxnResponse297559756[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)CommandAddPartitionToTxnResponse</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   _bitField0: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _cachedSize: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _messageBufferIdx: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _messageBufferLen: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _parsedBuffer: ByteBuf [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   error: ServerError [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   message: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   requestId: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   txnidLeastBits: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   txnidMostBits: long [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- checkRequiredFields()</TD></TR>
<TR><TD ALIGN="LEFT" >+ clear(): CommandAddPartitionToTxnResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearError(): CommandAddPartitionToTxnResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearMessage(): CommandAddPartitionToTxnResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearRequestId(): CommandAddPartitionToTxnResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearTxnidLeastBits(): CommandAddPartitionToTxnResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearTxnidMostBits(): CommandAddPartitionToTxnResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ copyFrom(_other: CommandAddPartitionToTxnResponse): CommandAddPartitionToTxnResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(_buffer: ByteBuf, _size: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(a: byte[])</TD></TR>
<TR><TD ALIGN="LEFT" >+ setError(error: ServerError): CommandAddPartitionToTxnResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ setMessage(message: String): CommandAddPartitionToTxnResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ setRequestId(requestId: long): CommandAddPartitionToTxnResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ setTxnidLeastBits(txnidLeastBits: long): CommandAddPartitionToTxnResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ setTxnidMostBits(txnidMostBits: long): CommandAddPartitionToTxnResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ toByteArray(): byte[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeTo(_b: ByteBuf): int</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

CommandAddSubscriptionToTxn297559756[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)CommandAddSubscriptionToTxn</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   _bitField0: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _cachedSize: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _parsedBuffer: ByteBuf [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _subscriptionsCount: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   requestId: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   subscriptions: List&lt;Subscription&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   txnidLeastBits: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   txnidMostBits: long [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ addAllSubscriptions(subscriptions: Iterable&lt;Subscription&gt;): CommandAddSubscriptionToTxn</TD></TR>
<TR><TD ALIGN="LEFT" >+ addSubscription(): Subscription</TD></TR>
<TR><TD ALIGN="LEFT" >- checkRequiredFields()</TD></TR>
<TR><TD ALIGN="LEFT" >+ clear(): CommandAddSubscriptionToTxn</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearRequestId(): CommandAddSubscriptionToTxn</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearSubscription(): CommandAddSubscriptionToTxn</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearTxnidLeastBits(): CommandAddSubscriptionToTxn</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearTxnidMostBits(): CommandAddSubscriptionToTxn</TD></TR>
<TR><TD ALIGN="LEFT" >+ copyFrom(_other: CommandAddSubscriptionToTxn): CommandAddSubscriptionToTxn</TD></TR>
<TR><TD ALIGN="LEFT" >+ getSubscriptionAt(idx: int): Subscription</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(_buffer: ByteBuf, _size: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(a: byte[])</TD></TR>
<TR><TD ALIGN="LEFT" >+ setRequestId(requestId: long): CommandAddSubscriptionToTxn</TD></TR>
<TR><TD ALIGN="LEFT" >+ setTxnidLeastBits(txnidLeastBits: long): CommandAddSubscriptionToTxn</TD></TR>
<TR><TD ALIGN="LEFT" >+ setTxnidMostBits(txnidMostBits: long): CommandAddSubscriptionToTxn</TD></TR>
<TR><TD ALIGN="LEFT" >+ toByteArray(): byte[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeTo(_b: ByteBuf): int</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

CommandAddSubscriptionToTxnResponse297559756[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)CommandAddSubscriptionToTxnResponse</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   _bitField0: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _cachedSize: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _messageBufferIdx: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _messageBufferLen: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _parsedBuffer: ByteBuf [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   error: ServerError [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   message: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   requestId: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   txnidLeastBits: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   txnidMostBits: long [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- checkRequiredFields()</TD></TR>
<TR><TD ALIGN="LEFT" >+ clear(): CommandAddSubscriptionToTxnResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearError(): CommandAddSubscriptionToTxnResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearMessage(): CommandAddSubscriptionToTxnResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearRequestId(): CommandAddSubscriptionToTxnResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearTxnidLeastBits(): CommandAddSubscriptionToTxnResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearTxnidMostBits(): CommandAddSubscriptionToTxnResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ copyFrom(_other: CommandAddSubscriptionToTxnResponse): CommandAddSubscriptionToTxnResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(_buffer: ByteBuf, _size: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(a: byte[])</TD></TR>
<TR><TD ALIGN="LEFT" >+ setError(error: ServerError): CommandAddSubscriptionToTxnResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ setMessage(message: String): CommandAddSubscriptionToTxnResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ setRequestId(requestId: long): CommandAddSubscriptionToTxnResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ setTxnidLeastBits(txnidLeastBits: long): CommandAddSubscriptionToTxnResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ setTxnidMostBits(txnidMostBits: long): CommandAddSubscriptionToTxnResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ toByteArray(): byte[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeTo(_b: ByteBuf): int</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

CommandAuthChallenge297559756[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)CommandAuthChallenge</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   _bitField0: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _cachedSize: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _parsedBuffer: ByteBuf [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _serverVersionBufferIdx: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _serverVersionBufferLen: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   challenge: AuthData [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   protocolVersion: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   serverVersion: String [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ clear(): CommandAuthChallenge</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearChallenge(): CommandAuthChallenge</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearProtocolVersion(): CommandAuthChallenge</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearServerVersion(): CommandAuthChallenge</TD></TR>
<TR><TD ALIGN="LEFT" >+ copyFrom(_other: CommandAuthChallenge): CommandAuthChallenge</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(_buffer: ByteBuf, _size: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(a: byte[])</TD></TR>
<TR><TD ALIGN="LEFT" >+ setChallenge(): AuthData</TD></TR>
<TR><TD ALIGN="LEFT" >+ setProtocolVersion(protocolVersion: int): CommandAuthChallenge</TD></TR>
<TR><TD ALIGN="LEFT" >+ setServerVersion(serverVersion: String): CommandAuthChallenge</TD></TR>
<TR><TD ALIGN="LEFT" >+ toByteArray(): byte[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeTo(_b: ByteBuf): int</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

CommandAuthResponse297559756[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)CommandAuthResponse</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   _bitField0: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _cachedSize: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _clientVersionBufferIdx: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _clientVersionBufferLen: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _parsedBuffer: ByteBuf [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   clientVersion: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   protocolVersion: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   response: AuthData [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ clear(): CommandAuthResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearClientVersion(): CommandAuthResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearProtocolVersion(): CommandAuthResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearResponse(): CommandAuthResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ copyFrom(_other: CommandAuthResponse): CommandAuthResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(_buffer: ByteBuf, _size: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(a: byte[])</TD></TR>
<TR><TD ALIGN="LEFT" >+ setClientVersion(clientVersion: String): CommandAuthResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ setProtocolVersion(protocolVersion: int): CommandAuthResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ setResponse(): AuthData</TD></TR>
<TR><TD ALIGN="LEFT" >+ toByteArray(): byte[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeTo(_b: ByteBuf): int</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

CommandCloseConsumer297559756[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)CommandCloseConsumer</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   _bitField0: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _cachedSize: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _parsedBuffer: ByteBuf [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   consumerId: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   requestId: long [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- checkRequiredFields()</TD></TR>
<TR><TD ALIGN="LEFT" >+ clear(): CommandCloseConsumer</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearConsumerId(): CommandCloseConsumer</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearRequestId(): CommandCloseConsumer</TD></TR>
<TR><TD ALIGN="LEFT" >+ copyFrom(_other: CommandCloseConsumer): CommandCloseConsumer</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(_buffer: ByteBuf, _size: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(a: byte[])</TD></TR>
<TR><TD ALIGN="LEFT" >+ setConsumerId(consumerId: long): CommandCloseConsumer</TD></TR>
<TR><TD ALIGN="LEFT" >+ setRequestId(requestId: long): CommandCloseConsumer</TD></TR>
<TR><TD ALIGN="LEFT" >+ toByteArray(): byte[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeTo(_b: ByteBuf): int</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

CommandCloseProducer297559756[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)CommandCloseProducer</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   _bitField0: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _cachedSize: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _parsedBuffer: ByteBuf [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   producerId: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   requestId: long [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- checkRequiredFields()</TD></TR>
<TR><TD ALIGN="LEFT" >+ clear(): CommandCloseProducer</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearProducerId(): CommandCloseProducer</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearRequestId(): CommandCloseProducer</TD></TR>
<TR><TD ALIGN="LEFT" >+ copyFrom(_other: CommandCloseProducer): CommandCloseProducer</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(_buffer: ByteBuf, _size: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(a: byte[])</TD></TR>
<TR><TD ALIGN="LEFT" >+ setProducerId(producerId: long): CommandCloseProducer</TD></TR>
<TR><TD ALIGN="LEFT" >+ setRequestId(requestId: long): CommandCloseProducer</TD></TR>
<TR><TD ALIGN="LEFT" >+ toByteArray(): byte[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeTo(_b: ByteBuf): int</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

CommandConnect297559756[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)CommandConnect</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   _authDataIdx: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _authDataLen: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _authMethodNameBufferIdx: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _authMethodNameBufferLen: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _bitField0: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _cachedSize: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _clientVersionBufferIdx: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _clientVersionBufferLen: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _originalAuthDataBufferIdx: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _originalAuthDataBufferLen: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _originalAuthMethodBufferIdx: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _originalAuthMethodBufferLen: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _originalPrincipalBufferIdx: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _originalPrincipalBufferLen: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _parsedBuffer: ByteBuf [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _proxyToBrokerUrlBufferIdx: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _proxyToBrokerUrlBufferLen: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   authData: ByteBuf [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   authMethod: AuthMethod [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   authMethodName: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   clientVersion: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   featureFlags: FeatureFlags [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   originalAuthData: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   originalAuthMethod: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   originalPrincipal: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   protocolVersion: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   proxyToBrokerUrl: String [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- checkRequiredFields()</TD></TR>
<TR><TD ALIGN="LEFT" >+ clear(): CommandConnect</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearAuthData(): CommandConnect</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearAuthMethod(): CommandConnect</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearAuthMethodName(): CommandConnect</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearClientVersion(): CommandConnect</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearFeatureFlags(): CommandConnect</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearOriginalAuthData(): CommandConnect</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearOriginalAuthMethod(): CommandConnect</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearOriginalPrincipal(): CommandConnect</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearProtocolVersion(): CommandConnect</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearProxyToBrokerUrl(): CommandConnect</TD></TR>
<TR><TD ALIGN="LEFT" >+ copyFrom(_other: CommandConnect): CommandConnect</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(_buffer: ByteBuf, _size: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(a: byte[])</TD></TR>
<TR><TD ALIGN="LEFT" >+ setAuthData(authData: byte[]): CommandConnect</TD></TR>
<TR><TD ALIGN="LEFT" >+ setAuthData(authData: ByteBuf): CommandConnect</TD></TR>
<TR><TD ALIGN="LEFT" >+ setAuthMethod(authMethod: AuthMethod): CommandConnect</TD></TR>
<TR><TD ALIGN="LEFT" >+ setAuthMethodName(authMethodName: String): CommandConnect</TD></TR>
<TR><TD ALIGN="LEFT" >+ setClientVersion(clientVersion: String): CommandConnect</TD></TR>
<TR><TD ALIGN="LEFT" >+ setFeatureFlags(): FeatureFlags</TD></TR>
<TR><TD ALIGN="LEFT" >+ setOriginalAuthData(originalAuthData: String): CommandConnect</TD></TR>
<TR><TD ALIGN="LEFT" >+ setOriginalAuthMethod(originalAuthMethod: String): CommandConnect</TD></TR>
<TR><TD ALIGN="LEFT" >+ setOriginalPrincipal(originalPrincipal: String): CommandConnect</TD></TR>
<TR><TD ALIGN="LEFT" >+ setProtocolVersion(protocolVersion: int): CommandConnect</TD></TR>
<TR><TD ALIGN="LEFT" >+ setProxyToBrokerUrl(proxyToBrokerUrl: String): CommandConnect</TD></TR>
<TR><TD ALIGN="LEFT" >+ toByteArray(): byte[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeTo(_b: ByteBuf): int</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

CommandConnected297559756[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)CommandConnected</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   _bitField0: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _cachedSize: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _parsedBuffer: ByteBuf [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _serverVersionBufferIdx: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _serverVersionBufferLen: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   maxMessageSize: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   protocolVersion: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   serverVersion: String [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- checkRequiredFields()</TD></TR>
<TR><TD ALIGN="LEFT" >+ clear(): CommandConnected</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearMaxMessageSize(): CommandConnected</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearProtocolVersion(): CommandConnected</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearServerVersion(): CommandConnected</TD></TR>
<TR><TD ALIGN="LEFT" >+ copyFrom(_other: CommandConnected): CommandConnected</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(_buffer: ByteBuf, _size: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(a: byte[])</TD></TR>
<TR><TD ALIGN="LEFT" >+ setMaxMessageSize(maxMessageSize: int): CommandConnected</TD></TR>
<TR><TD ALIGN="LEFT" >+ setProtocolVersion(protocolVersion: int): CommandConnected</TD></TR>
<TR><TD ALIGN="LEFT" >+ setServerVersion(serverVersion: String): CommandConnected</TD></TR>
<TR><TD ALIGN="LEFT" >+ toByteArray(): byte[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeTo(_b: ByteBuf): int</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

CommandConsumerStats297559756[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)CommandConsumerStats</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   _bitField0: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _cachedSize: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _parsedBuffer: ByteBuf [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   consumerId: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   requestId: long [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- checkRequiredFields()</TD></TR>
<TR><TD ALIGN="LEFT" >+ clear(): CommandConsumerStats</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearConsumerId(): CommandConsumerStats</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearRequestId(): CommandConsumerStats</TD></TR>
<TR><TD ALIGN="LEFT" >+ copyFrom(_other: CommandConsumerStats): CommandConsumerStats</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(_buffer: ByteBuf, _size: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(a: byte[])</TD></TR>
<TR><TD ALIGN="LEFT" >+ setConsumerId(consumerId: long): CommandConsumerStats</TD></TR>
<TR><TD ALIGN="LEFT" >+ setRequestId(requestId: long): CommandConsumerStats</TD></TR>
<TR><TD ALIGN="LEFT" >+ toByteArray(): byte[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeTo(_b: ByteBuf): int</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

CommandConsumerStatsResponse297559756[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)CommandConsumerStatsResponse</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   _addressBufferIdx: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _addressBufferLen: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _bitField0: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _cachedSize: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _connectedSinceBufferIdx: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _connectedSinceBufferLen: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _consumerNameBufferIdx: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _consumerNameBufferLen: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _errorMessageBufferIdx: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _errorMessageBufferLen: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _parsedBuffer: ByteBuf [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _typeBufferIdx: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _typeBufferLen: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   address: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   availablePermits: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   blockedConsumerOnUnackedMsgs: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   connectedSince: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   consumerName: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   errorCode: ServerError [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   errorMessage: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   msgBacklog: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   msgRateExpired: double [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   msgRateOut: double [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   msgRateRedeliver: double [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   msgThroughputOut: double [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   requestId: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   type: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   unackedMessages: long [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- checkRequiredFields()</TD></TR>
<TR><TD ALIGN="LEFT" >+ clear(): CommandConsumerStatsResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearAddress(): CommandConsumerStatsResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearAvailablePermits(): CommandConsumerStatsResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearBlockedConsumerOnUnackedMsgs(): CommandConsumerStatsResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearConnectedSince(): CommandConsumerStatsResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearConsumerName(): CommandConsumerStatsResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearErrorCode(): CommandConsumerStatsResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearErrorMessage(): CommandConsumerStatsResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearMsgBacklog(): CommandConsumerStatsResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearMsgRateExpired(): CommandConsumerStatsResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearMsgRateOut(): CommandConsumerStatsResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearMsgRateRedeliver(): CommandConsumerStatsResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearMsgThroughputOut(): CommandConsumerStatsResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearRequestId(): CommandConsumerStatsResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearType(): CommandConsumerStatsResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearUnackedMessages(): CommandConsumerStatsResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ copyFrom(_other: CommandConsumerStatsResponse): CommandConsumerStatsResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(_buffer: ByteBuf, _size: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(a: byte[])</TD></TR>
<TR><TD ALIGN="LEFT" >+ setAddress(address: String): CommandConsumerStatsResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ setAvailablePermits(availablePermits: long): CommandConsumerStatsResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ setBlockedConsumerOnUnackedMsgs(blockedConsumerOnUnackedMsgs: boolean): CommandConsumerStatsResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ setConnectedSince(connectedSince: String): CommandConsumerStatsResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ setConsumerName(consumerName: String): CommandConsumerStatsResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ setErrorCode(errorCode: ServerError): CommandConsumerStatsResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ setErrorMessage(errorMessage: String): CommandConsumerStatsResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ setMsgBacklog(msgBacklog: long): CommandConsumerStatsResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ setMsgRateExpired(msgRateExpired: double): CommandConsumerStatsResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ setMsgRateOut(msgRateOut: double): CommandConsumerStatsResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ setMsgRateRedeliver(msgRateRedeliver: double): CommandConsumerStatsResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ setMsgThroughputOut(msgThroughputOut: double): CommandConsumerStatsResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ setRequestId(requestId: long): CommandConsumerStatsResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ setType(type: String): CommandConsumerStatsResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ setUnackedMessages(unackedMessages: long): CommandConsumerStatsResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ toByteArray(): byte[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeTo(_b: ByteBuf): int</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

CommandEndTxn297559756[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)CommandEndTxn</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   _bitField0: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _cachedSize: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _parsedBuffer: ByteBuf [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   requestId: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   txnAction: TxnAction [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   txnidLeastBits: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   txnidMostBits: long [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- checkRequiredFields()</TD></TR>
<TR><TD ALIGN="LEFT" >+ clear(): CommandEndTxn</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearRequestId(): CommandEndTxn</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearTxnAction(): CommandEndTxn</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearTxnidLeastBits(): CommandEndTxn</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearTxnidMostBits(): CommandEndTxn</TD></TR>
<TR><TD ALIGN="LEFT" >+ copyFrom(_other: CommandEndTxn): CommandEndTxn</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(_buffer: ByteBuf, _size: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(a: byte[])</TD></TR>
<TR><TD ALIGN="LEFT" >+ setRequestId(requestId: long): CommandEndTxn</TD></TR>
<TR><TD ALIGN="LEFT" >+ setTxnAction(txnAction: TxnAction): CommandEndTxn</TD></TR>
<TR><TD ALIGN="LEFT" >+ setTxnidLeastBits(txnidLeastBits: long): CommandEndTxn</TD></TR>
<TR><TD ALIGN="LEFT" >+ setTxnidMostBits(txnidMostBits: long): CommandEndTxn</TD></TR>
<TR><TD ALIGN="LEFT" >+ toByteArray(): byte[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeTo(_b: ByteBuf): int</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

CommandEndTxnOnPartition297559756[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)CommandEndTxnOnPartition</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   _bitField0: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _cachedSize: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _parsedBuffer: ByteBuf [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _topicBufferIdx: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _topicBufferLen: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   requestId: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   topic: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   txnAction: TxnAction [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   txnidLeastBits: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   txnidLeastBitsOfLowWatermark: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   txnidMostBits: long [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- checkRequiredFields()</TD></TR>
<TR><TD ALIGN="LEFT" >+ clear(): CommandEndTxnOnPartition</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearRequestId(): CommandEndTxnOnPartition</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearTopic(): CommandEndTxnOnPartition</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearTxnAction(): CommandEndTxnOnPartition</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearTxnidLeastBits(): CommandEndTxnOnPartition</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearTxnidLeastBitsOfLowWatermark(): CommandEndTxnOnPartition</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearTxnidMostBits(): CommandEndTxnOnPartition</TD></TR>
<TR><TD ALIGN="LEFT" >+ copyFrom(_other: CommandEndTxnOnPartition): CommandEndTxnOnPartition</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(_buffer: ByteBuf, _size: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(a: byte[])</TD></TR>
<TR><TD ALIGN="LEFT" >+ setRequestId(requestId: long): CommandEndTxnOnPartition</TD></TR>
<TR><TD ALIGN="LEFT" >+ setTopic(topic: String): CommandEndTxnOnPartition</TD></TR>
<TR><TD ALIGN="LEFT" >+ setTxnAction(txnAction: TxnAction): CommandEndTxnOnPartition</TD></TR>
<TR><TD ALIGN="LEFT" >+ setTxnidLeastBits(txnidLeastBits: long): CommandEndTxnOnPartition</TD></TR>
<TR><TD ALIGN="LEFT" >+ setTxnidLeastBitsOfLowWatermark(txnidLeastBitsOfLowWatermark: long): CommandEndTxnOnPartition</TD></TR>
<TR><TD ALIGN="LEFT" >+ setTxnidMostBits(txnidMostBits: long): CommandEndTxnOnPartition</TD></TR>
<TR><TD ALIGN="LEFT" >+ toByteArray(): byte[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeTo(_b: ByteBuf): int</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

CommandEndTxnOnPartitionResponse297559756[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)CommandEndTxnOnPartitionResponse</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   _bitField0: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _cachedSize: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _messageBufferIdx: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _messageBufferLen: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _parsedBuffer: ByteBuf [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   error: ServerError [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   message: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   requestId: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   txnidLeastBits: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   txnidMostBits: long [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- checkRequiredFields()</TD></TR>
<TR><TD ALIGN="LEFT" >+ clear(): CommandEndTxnOnPartitionResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearError(): CommandEndTxnOnPartitionResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearMessage(): CommandEndTxnOnPartitionResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearRequestId(): CommandEndTxnOnPartitionResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearTxnidLeastBits(): CommandEndTxnOnPartitionResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearTxnidMostBits(): CommandEndTxnOnPartitionResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ copyFrom(_other: CommandEndTxnOnPartitionResponse): CommandEndTxnOnPartitionResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(_buffer: ByteBuf, _size: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(a: byte[])</TD></TR>
<TR><TD ALIGN="LEFT" >+ setError(error: ServerError): CommandEndTxnOnPartitionResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ setMessage(message: String): CommandEndTxnOnPartitionResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ setRequestId(requestId: long): CommandEndTxnOnPartitionResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ setTxnidLeastBits(txnidLeastBits: long): CommandEndTxnOnPartitionResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ setTxnidMostBits(txnidMostBits: long): CommandEndTxnOnPartitionResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ toByteArray(): byte[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeTo(_b: ByteBuf): int</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

CommandEndTxnOnSubscription297559756[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)CommandEndTxnOnSubscription</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   _bitField0: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _cachedSize: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _parsedBuffer: ByteBuf [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   requestId: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   subscription: Subscription [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   txnAction: TxnAction [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   txnidLeastBits: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   txnidLeastBitsOfLowWatermark: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   txnidMostBits: long [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- checkRequiredFields()</TD></TR>
<TR><TD ALIGN="LEFT" >+ clear(): CommandEndTxnOnSubscription</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearRequestId(): CommandEndTxnOnSubscription</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearSubscription(): CommandEndTxnOnSubscription</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearTxnAction(): CommandEndTxnOnSubscription</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearTxnidLeastBits(): CommandEndTxnOnSubscription</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearTxnidLeastBitsOfLowWatermark(): CommandEndTxnOnSubscription</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearTxnidMostBits(): CommandEndTxnOnSubscription</TD></TR>
<TR><TD ALIGN="LEFT" >+ copyFrom(_other: CommandEndTxnOnSubscription): CommandEndTxnOnSubscription</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(_buffer: ByteBuf, _size: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(a: byte[])</TD></TR>
<TR><TD ALIGN="LEFT" >+ setRequestId(requestId: long): CommandEndTxnOnSubscription</TD></TR>
<TR><TD ALIGN="LEFT" >+ setSubscription(): Subscription</TD></TR>
<TR><TD ALIGN="LEFT" >+ setTxnAction(txnAction: TxnAction): CommandEndTxnOnSubscription</TD></TR>
<TR><TD ALIGN="LEFT" >+ setTxnidLeastBits(txnidLeastBits: long): CommandEndTxnOnSubscription</TD></TR>
<TR><TD ALIGN="LEFT" >+ setTxnidLeastBitsOfLowWatermark(txnidLeastBitsOfLowWatermark: long): CommandEndTxnOnSubscription</TD></TR>
<TR><TD ALIGN="LEFT" >+ setTxnidMostBits(txnidMostBits: long): CommandEndTxnOnSubscription</TD></TR>
<TR><TD ALIGN="LEFT" >+ toByteArray(): byte[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeTo(_b: ByteBuf): int</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

CommandEndTxnOnSubscriptionResponse297559756[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)CommandEndTxnOnSubscriptionResponse</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   _bitField0: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _cachedSize: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _messageBufferIdx: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _messageBufferLen: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _parsedBuffer: ByteBuf [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   error: ServerError [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   message: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   requestId: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   txnidLeastBits: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   txnidMostBits: long [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- checkRequiredFields()</TD></TR>
<TR><TD ALIGN="LEFT" >+ clear(): CommandEndTxnOnSubscriptionResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearError(): CommandEndTxnOnSubscriptionResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearMessage(): CommandEndTxnOnSubscriptionResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearRequestId(): CommandEndTxnOnSubscriptionResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearTxnidLeastBits(): CommandEndTxnOnSubscriptionResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearTxnidMostBits(): CommandEndTxnOnSubscriptionResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ copyFrom(_other: CommandEndTxnOnSubscriptionResponse): CommandEndTxnOnSubscriptionResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(_buffer: ByteBuf, _size: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(a: byte[])</TD></TR>
<TR><TD ALIGN="LEFT" >+ setError(error: ServerError): CommandEndTxnOnSubscriptionResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ setMessage(message: String): CommandEndTxnOnSubscriptionResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ setRequestId(requestId: long): CommandEndTxnOnSubscriptionResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ setTxnidLeastBits(txnidLeastBits: long): CommandEndTxnOnSubscriptionResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ setTxnidMostBits(txnidMostBits: long): CommandEndTxnOnSubscriptionResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ toByteArray(): byte[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeTo(_b: ByteBuf): int</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

CommandEndTxnResponse297559756[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)CommandEndTxnResponse</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   _bitField0: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _cachedSize: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _messageBufferIdx: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _messageBufferLen: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _parsedBuffer: ByteBuf [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   error: ServerError [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   message: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   requestId: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   txnidLeastBits: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   txnidMostBits: long [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- checkRequiredFields()</TD></TR>
<TR><TD ALIGN="LEFT" >+ clear(): CommandEndTxnResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearError(): CommandEndTxnResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearMessage(): CommandEndTxnResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearRequestId(): CommandEndTxnResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearTxnidLeastBits(): CommandEndTxnResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearTxnidMostBits(): CommandEndTxnResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ copyFrom(_other: CommandEndTxnResponse): CommandEndTxnResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(_buffer: ByteBuf, _size: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(a: byte[])</TD></TR>
<TR><TD ALIGN="LEFT" >+ setError(error: ServerError): CommandEndTxnResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ setMessage(message: String): CommandEndTxnResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ setRequestId(requestId: long): CommandEndTxnResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ setTxnidLeastBits(txnidLeastBits: long): CommandEndTxnResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ setTxnidMostBits(txnidMostBits: long): CommandEndTxnResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ toByteArray(): byte[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeTo(_b: ByteBuf): int</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

CommandError297559756[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)CommandError</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   _bitField0: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _cachedSize: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _messageBufferIdx: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _messageBufferLen: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _parsedBuffer: ByteBuf [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   error: ServerError [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   message: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   requestId: long [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- checkRequiredFields()</TD></TR>
<TR><TD ALIGN="LEFT" >+ clear(): CommandError</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearError(): CommandError</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearMessage(): CommandError</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearRequestId(): CommandError</TD></TR>
<TR><TD ALIGN="LEFT" >+ copyFrom(_other: CommandError): CommandError</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(_buffer: ByteBuf, _size: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(a: byte[])</TD></TR>
<TR><TD ALIGN="LEFT" >+ setError(error: ServerError): CommandError</TD></TR>
<TR><TD ALIGN="LEFT" >+ setMessage(message: String): CommandError</TD></TR>
<TR><TD ALIGN="LEFT" >+ setRequestId(requestId: long): CommandError</TD></TR>
<TR><TD ALIGN="LEFT" >+ toByteArray(): byte[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeTo(_b: ByteBuf): int</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

CommandFlow297559756[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)CommandFlow</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   _bitField0: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _cachedSize: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _parsedBuffer: ByteBuf [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   consumerId: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   messagePermits: int [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- checkRequiredFields()</TD></TR>
<TR><TD ALIGN="LEFT" >+ clear(): CommandFlow</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearConsumerId(): CommandFlow</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearMessagePermits(): CommandFlow</TD></TR>
<TR><TD ALIGN="LEFT" >+ copyFrom(_other: CommandFlow): CommandFlow</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(_buffer: ByteBuf, _size: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(a: byte[])</TD></TR>
<TR><TD ALIGN="LEFT" >+ setConsumerId(consumerId: long): CommandFlow</TD></TR>
<TR><TD ALIGN="LEFT" >+ setMessagePermits(messagePermits: int): CommandFlow</TD></TR>
<TR><TD ALIGN="LEFT" >+ toByteArray(): byte[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeTo(_b: ByteBuf): int</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

CommandGetLastMessageId297559756[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)CommandGetLastMessageId</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   _bitField0: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _cachedSize: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _parsedBuffer: ByteBuf [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   consumerId: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   requestId: long [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- checkRequiredFields()</TD></TR>
<TR><TD ALIGN="LEFT" >+ clear(): CommandGetLastMessageId</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearConsumerId(): CommandGetLastMessageId</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearRequestId(): CommandGetLastMessageId</TD></TR>
<TR><TD ALIGN="LEFT" >+ copyFrom(_other: CommandGetLastMessageId): CommandGetLastMessageId</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(_buffer: ByteBuf, _size: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(a: byte[])</TD></TR>
<TR><TD ALIGN="LEFT" >+ setConsumerId(consumerId: long): CommandGetLastMessageId</TD></TR>
<TR><TD ALIGN="LEFT" >+ setRequestId(requestId: long): CommandGetLastMessageId</TD></TR>
<TR><TD ALIGN="LEFT" >+ toByteArray(): byte[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeTo(_b: ByteBuf): int</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

CommandGetLastMessageIdResponse297559756[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)CommandGetLastMessageIdResponse</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   _bitField0: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _cachedSize: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _parsedBuffer: ByteBuf [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   consumerMarkDeletePosition: MessageIdData [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   lastMessageId: MessageIdData [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   requestId: long [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- checkRequiredFields()</TD></TR>
<TR><TD ALIGN="LEFT" >+ clear(): CommandGetLastMessageIdResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearConsumerMarkDeletePosition(): CommandGetLastMessageIdResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearLastMessageId(): CommandGetLastMessageIdResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearRequestId(): CommandGetLastMessageIdResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ copyFrom(_other: CommandGetLastMessageIdResponse): CommandGetLastMessageIdResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(_buffer: ByteBuf, _size: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(a: byte[])</TD></TR>
<TR><TD ALIGN="LEFT" >+ setConsumerMarkDeletePosition(): MessageIdData</TD></TR>
<TR><TD ALIGN="LEFT" >+ setLastMessageId(): MessageIdData</TD></TR>
<TR><TD ALIGN="LEFT" >+ setRequestId(requestId: long): CommandGetLastMessageIdResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ toByteArray(): byte[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeTo(_b: ByteBuf): int</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

CommandGetOrCreateSchema297559756[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)CommandGetOrCreateSchema</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   _bitField0: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _cachedSize: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _parsedBuffer: ByteBuf [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _topicBufferIdx: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _topicBufferLen: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   requestId: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   schema: Schema [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   topic: String [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- checkRequiredFields()</TD></TR>
<TR><TD ALIGN="LEFT" >+ clear(): CommandGetOrCreateSchema</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearRequestId(): CommandGetOrCreateSchema</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearSchema(): CommandGetOrCreateSchema</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearTopic(): CommandGetOrCreateSchema</TD></TR>
<TR><TD ALIGN="LEFT" >+ copyFrom(_other: CommandGetOrCreateSchema): CommandGetOrCreateSchema</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(_buffer: ByteBuf, _size: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(a: byte[])</TD></TR>
<TR><TD ALIGN="LEFT" >+ setRequestId(requestId: long): CommandGetOrCreateSchema</TD></TR>
<TR><TD ALIGN="LEFT" >+ setSchema(): Schema</TD></TR>
<TR><TD ALIGN="LEFT" >+ setTopic(topic: String): CommandGetOrCreateSchema</TD></TR>
<TR><TD ALIGN="LEFT" >+ toByteArray(): byte[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeTo(_b: ByteBuf): int</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

CommandGetOrCreateSchemaResponse297559756[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)CommandGetOrCreateSchemaResponse</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   _bitField0: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _cachedSize: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _errorMessageBufferIdx: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _errorMessageBufferLen: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _parsedBuffer: ByteBuf [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _schemaVersionIdx: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _schemaVersionLen: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   errorCode: ServerError [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   errorMessage: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   requestId: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   schemaVersion: ByteBuf [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- checkRequiredFields()</TD></TR>
<TR><TD ALIGN="LEFT" >+ clear(): CommandGetOrCreateSchemaResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearErrorCode(): CommandGetOrCreateSchemaResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearErrorMessage(): CommandGetOrCreateSchemaResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearRequestId(): CommandGetOrCreateSchemaResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearSchemaVersion(): CommandGetOrCreateSchemaResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ copyFrom(_other: CommandGetOrCreateSchemaResponse): CommandGetOrCreateSchemaResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(_buffer: ByteBuf, _size: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(a: byte[])</TD></TR>
<TR><TD ALIGN="LEFT" >+ setErrorCode(errorCode: ServerError): CommandGetOrCreateSchemaResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ setErrorMessage(errorMessage: String): CommandGetOrCreateSchemaResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ setRequestId(requestId: long): CommandGetOrCreateSchemaResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ setSchemaVersion(schemaVersion: byte[]): CommandGetOrCreateSchemaResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ setSchemaVersion(schemaVersion: ByteBuf): CommandGetOrCreateSchemaResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ toByteArray(): byte[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeTo(_b: ByteBuf): int</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

CommandGetSchema297559756[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)CommandGetSchema</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   _bitField0: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _cachedSize: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _parsedBuffer: ByteBuf [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _schemaVersionIdx: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _schemaVersionLen: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _topicBufferIdx: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _topicBufferLen: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   requestId: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   schemaVersion: ByteBuf [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   topic: String [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- checkRequiredFields()</TD></TR>
<TR><TD ALIGN="LEFT" >+ clear(): CommandGetSchema</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearRequestId(): CommandGetSchema</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearSchemaVersion(): CommandGetSchema</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearTopic(): CommandGetSchema</TD></TR>
<TR><TD ALIGN="LEFT" >+ copyFrom(_other: CommandGetSchema): CommandGetSchema</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(_buffer: ByteBuf, _size: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(a: byte[])</TD></TR>
<TR><TD ALIGN="LEFT" >+ setRequestId(requestId: long): CommandGetSchema</TD></TR>
<TR><TD ALIGN="LEFT" >+ setSchemaVersion(schemaVersion: byte[]): CommandGetSchema</TD></TR>
<TR><TD ALIGN="LEFT" >+ setSchemaVersion(schemaVersion: ByteBuf): CommandGetSchema</TD></TR>
<TR><TD ALIGN="LEFT" >+ setTopic(topic: String): CommandGetSchema</TD></TR>
<TR><TD ALIGN="LEFT" >+ toByteArray(): byte[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeTo(_b: ByteBuf): int</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

CommandGetSchemaResponse297559756[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)CommandGetSchemaResponse</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   _bitField0: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _cachedSize: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _errorMessageBufferIdx: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _errorMessageBufferLen: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _parsedBuffer: ByteBuf [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _schemaVersionIdx: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _schemaVersionLen: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   errorCode: ServerError [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   errorMessage: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   requestId: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   schema: Schema [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   schemaVersion: ByteBuf [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- checkRequiredFields()</TD></TR>
<TR><TD ALIGN="LEFT" >+ clear(): CommandGetSchemaResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearErrorCode(): CommandGetSchemaResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearErrorMessage(): CommandGetSchemaResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearRequestId(): CommandGetSchemaResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearSchema(): CommandGetSchemaResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearSchemaVersion(): CommandGetSchemaResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ copyFrom(_other: CommandGetSchemaResponse): CommandGetSchemaResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(_buffer: ByteBuf, _size: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(a: byte[])</TD></TR>
<TR><TD ALIGN="LEFT" >+ setErrorCode(errorCode: ServerError): CommandGetSchemaResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ setErrorMessage(errorMessage: String): CommandGetSchemaResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ setRequestId(requestId: long): CommandGetSchemaResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ setSchema(): Schema</TD></TR>
<TR><TD ALIGN="LEFT" >+ setSchemaVersion(schemaVersion: byte[]): CommandGetSchemaResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ setSchemaVersion(schemaVersion: ByteBuf): CommandGetSchemaResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ toByteArray(): byte[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeTo(_b: ByteBuf): int</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

CommandGetTopicsOfNamespace297559756[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)CommandGetTopicsOfNamespace</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   _bitField0: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _cachedSize: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _namespaceBufferIdx: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _namespaceBufferLen: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _parsedBuffer: ByteBuf [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   mode: Mode [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   namespace: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   requestId: long [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- checkRequiredFields()</TD></TR>
<TR><TD ALIGN="LEFT" >+ clear(): CommandGetTopicsOfNamespace</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearMode(): CommandGetTopicsOfNamespace</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearNamespace(): CommandGetTopicsOfNamespace</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearRequestId(): CommandGetTopicsOfNamespace</TD></TR>
<TR><TD ALIGN="LEFT" >+ copyFrom(_other: CommandGetTopicsOfNamespace): CommandGetTopicsOfNamespace</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(_buffer: ByteBuf, _size: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(a: byte[])</TD></TR>
<TR><TD ALIGN="LEFT" >+ setMode(mode: Mode): CommandGetTopicsOfNamespace</TD></TR>
<TR><TD ALIGN="LEFT" >+ setNamespace(namespace: String): CommandGetTopicsOfNamespace</TD></TR>
<TR><TD ALIGN="LEFT" >+ setRequestId(requestId: long): CommandGetTopicsOfNamespace</TD></TR>
<TR><TD ALIGN="LEFT" >+ toByteArray(): byte[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeTo(_b: ByteBuf): int</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

CommandGetTopicsOfNamespaceResponse297559756[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)CommandGetTopicsOfNamespaceResponse</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   _bitField0: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _cachedSize: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _parsedBuffer: ByteBuf [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _topicsCount: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   requestId: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   topics: List&lt;StringHolder&gt; [0..*]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- _newTopicStringHolder(): StringHolder</TD></TR>
<TR><TD ALIGN="LEFT" >+ addAllTopics(topics: Iterable&lt;String&gt;): CommandGetTopicsOfNamespaceResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ addTopic(topic: String)</TD></TR>
<TR><TD ALIGN="LEFT" >- checkRequiredFields()</TD></TR>
<TR><TD ALIGN="LEFT" >+ clear(): CommandGetTopicsOfNamespaceResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearRequestId(): CommandGetTopicsOfNamespaceResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearTopics(): CommandGetTopicsOfNamespaceResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ copyFrom(_other: CommandGetTopicsOfNamespaceResponse): CommandGetTopicsOfNamespaceResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ getTopicAt(idx: int): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(_buffer: ByteBuf, _size: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(a: byte[])</TD></TR>
<TR><TD ALIGN="LEFT" >+ setRequestId(requestId: long): CommandGetTopicsOfNamespaceResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ toByteArray(): byte[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeTo(_b: ByteBuf): int</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

CommandLookupTopic297559756[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)CommandLookupTopic</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   _advertisedListenerNameBufferIdx: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _advertisedListenerNameBufferLen: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _bitField0: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _cachedSize: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _originalAuthDataBufferIdx: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _originalAuthDataBufferLen: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _originalAuthMethodBufferIdx: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _originalAuthMethodBufferLen: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _originalPrincipalBufferIdx: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _originalPrincipalBufferLen: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _parsedBuffer: ByteBuf [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _topicBufferIdx: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _topicBufferLen: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   advertisedListenerName: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   authoritative: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   originalAuthData: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   originalAuthMethod: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   originalPrincipal: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   requestId: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   topic: String [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- checkRequiredFields()</TD></TR>
<TR><TD ALIGN="LEFT" >+ clear(): CommandLookupTopic</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearAdvertisedListenerName(): CommandLookupTopic</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearAuthoritative(): CommandLookupTopic</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearOriginalAuthData(): CommandLookupTopic</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearOriginalAuthMethod(): CommandLookupTopic</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearOriginalPrincipal(): CommandLookupTopic</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearRequestId(): CommandLookupTopic</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearTopic(): CommandLookupTopic</TD></TR>
<TR><TD ALIGN="LEFT" >+ copyFrom(_other: CommandLookupTopic): CommandLookupTopic</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(_buffer: ByteBuf, _size: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(a: byte[])</TD></TR>
<TR><TD ALIGN="LEFT" >+ setAdvertisedListenerName(advertisedListenerName: String): CommandLookupTopic</TD></TR>
<TR><TD ALIGN="LEFT" >+ setAuthoritative(authoritative: boolean): CommandLookupTopic</TD></TR>
<TR><TD ALIGN="LEFT" >+ setOriginalAuthData(originalAuthData: String): CommandLookupTopic</TD></TR>
<TR><TD ALIGN="LEFT" >+ setOriginalAuthMethod(originalAuthMethod: String): CommandLookupTopic</TD></TR>
<TR><TD ALIGN="LEFT" >+ setOriginalPrincipal(originalPrincipal: String): CommandLookupTopic</TD></TR>
<TR><TD ALIGN="LEFT" >+ setRequestId(requestId: long): CommandLookupTopic</TD></TR>
<TR><TD ALIGN="LEFT" >+ setTopic(topic: String): CommandLookupTopic</TD></TR>
<TR><TD ALIGN="LEFT" >+ toByteArray(): byte[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeTo(_b: ByteBuf): int</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

CommandLookupTopicResponse297559756[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)CommandLookupTopicResponse</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   _bitField0: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _brokerServiceUrlBufferIdx: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _brokerServiceUrlBufferLen: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _brokerServiceUrlTlsBufferIdx: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _brokerServiceUrlTlsBufferLen: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _cachedSize: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _messageBufferIdx: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _messageBufferLen: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _parsedBuffer: ByteBuf [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   authoritative: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   brokerServiceUrl: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   brokerServiceUrlTls: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   error: ServerError [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   message: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   proxyThroughServiceUrl: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   requestId: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   response: LookupType [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- checkRequiredFields()</TD></TR>
<TR><TD ALIGN="LEFT" >+ clear(): CommandLookupTopicResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearAuthoritative(): CommandLookupTopicResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearBrokerServiceUrl(): CommandLookupTopicResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearBrokerServiceUrlTls(): CommandLookupTopicResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearError(): CommandLookupTopicResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearMessage(): CommandLookupTopicResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearProxyThroughServiceUrl(): CommandLookupTopicResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearRequestId(): CommandLookupTopicResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearResponse(): CommandLookupTopicResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ copyFrom(_other: CommandLookupTopicResponse): CommandLookupTopicResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(_buffer: ByteBuf, _size: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(a: byte[])</TD></TR>
<TR><TD ALIGN="LEFT" >+ setAuthoritative(authoritative: boolean): CommandLookupTopicResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ setBrokerServiceUrl(brokerServiceUrl: String): CommandLookupTopicResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ setBrokerServiceUrlTls(brokerServiceUrlTls: String): CommandLookupTopicResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ setError(error: ServerError): CommandLookupTopicResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ setMessage(message: String): CommandLookupTopicResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ setProxyThroughServiceUrl(proxyThroughServiceUrl: boolean): CommandLookupTopicResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ setRequestId(requestId: long): CommandLookupTopicResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ setResponse(response: LookupType): CommandLookupTopicResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ toByteArray(): byte[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeTo(_b: ByteBuf): int</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

CommandMessage297559756[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)CommandMessage</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   _ackSetsCount: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _bitField0: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _cachedSize: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _parsedBuffer: ByteBuf [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   ackSets: long[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   consumerEpoch: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   consumerId: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   messageId: MessageIdData [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   redeliveryCount: int [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ addAckSet(ackSet: long)</TD></TR>
<TR><TD ALIGN="LEFT" >- checkRequiredFields()</TD></TR>
<TR><TD ALIGN="LEFT" >+ clear(): CommandMessage</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearAckSet(): CommandMessage</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearConsumerEpoch(): CommandMessage</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearConsumerId(): CommandMessage</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearMessageId(): CommandMessage</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearRedeliveryCount(): CommandMessage</TD></TR>
<TR><TD ALIGN="LEFT" >+ copyFrom(_other: CommandMessage): CommandMessage</TD></TR>
<TR><TD ALIGN="LEFT" >+ getAckSetAt(idx: int): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(_buffer: ByteBuf, _size: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(a: byte[])</TD></TR>
<TR><TD ALIGN="LEFT" >+ setConsumerEpoch(consumerEpoch: long): CommandMessage</TD></TR>
<TR><TD ALIGN="LEFT" >+ setConsumerId(consumerId: long): CommandMessage</TD></TR>
<TR><TD ALIGN="LEFT" >+ setMessageId(): MessageIdData</TD></TR>
<TR><TD ALIGN="LEFT" >+ setRedeliveryCount(redeliveryCount: int): CommandMessage</TD></TR>
<TR><TD ALIGN="LEFT" >+ toByteArray(): byte[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeTo(_b: ByteBuf): int</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

CommandNewTxn297559756[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)CommandNewTxn</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   _bitField0: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _cachedSize: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _parsedBuffer: ByteBuf [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   requestId: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   tcId: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   txnTtlSeconds: long [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- checkRequiredFields()</TD></TR>
<TR><TD ALIGN="LEFT" >+ clear(): CommandNewTxn</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearRequestId(): CommandNewTxn</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearTcId(): CommandNewTxn</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearTxnTtlSeconds(): CommandNewTxn</TD></TR>
<TR><TD ALIGN="LEFT" >+ copyFrom(_other: CommandNewTxn): CommandNewTxn</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(_buffer: ByteBuf, _size: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(a: byte[])</TD></TR>
<TR><TD ALIGN="LEFT" >+ setRequestId(requestId: long): CommandNewTxn</TD></TR>
<TR><TD ALIGN="LEFT" >+ setTcId(tcId: long): CommandNewTxn</TD></TR>
<TR><TD ALIGN="LEFT" >+ setTxnTtlSeconds(txnTtlSeconds: long): CommandNewTxn</TD></TR>
<TR><TD ALIGN="LEFT" >+ toByteArray(): byte[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeTo(_b: ByteBuf): int</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

CommandNewTxnResponse297559756[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)CommandNewTxnResponse</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   _bitField0: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _cachedSize: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _messageBufferIdx: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _messageBufferLen: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _parsedBuffer: ByteBuf [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   error: ServerError [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   message: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   requestId: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   txnidLeastBits: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   txnidMostBits: long [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- checkRequiredFields()</TD></TR>
<TR><TD ALIGN="LEFT" >+ clear(): CommandNewTxnResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearError(): CommandNewTxnResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearMessage(): CommandNewTxnResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearRequestId(): CommandNewTxnResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearTxnidLeastBits(): CommandNewTxnResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearTxnidMostBits(): CommandNewTxnResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ copyFrom(_other: CommandNewTxnResponse): CommandNewTxnResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(_buffer: ByteBuf, _size: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(a: byte[])</TD></TR>
<TR><TD ALIGN="LEFT" >+ setError(error: ServerError): CommandNewTxnResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ setMessage(message: String): CommandNewTxnResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ setRequestId(requestId: long): CommandNewTxnResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ setTxnidLeastBits(txnidLeastBits: long): CommandNewTxnResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ setTxnidMostBits(txnidMostBits: long): CommandNewTxnResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ toByteArray(): byte[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeTo(_b: ByteBuf): int</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

CommandPartitionedTopicMetadata297559756[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)CommandPartitionedTopicMetadata</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   _bitField0: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _cachedSize: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _originalAuthDataBufferIdx: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _originalAuthDataBufferLen: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _originalAuthMethodBufferIdx: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _originalAuthMethodBufferLen: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _originalPrincipalBufferIdx: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _originalPrincipalBufferLen: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _parsedBuffer: ByteBuf [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _topicBufferIdx: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _topicBufferLen: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   originalAuthData: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   originalAuthMethod: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   originalPrincipal: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   requestId: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   topic: String [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- checkRequiredFields()</TD></TR>
<TR><TD ALIGN="LEFT" >+ clear(): CommandPartitionedTopicMetadata</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearOriginalAuthData(): CommandPartitionedTopicMetadata</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearOriginalAuthMethod(): CommandPartitionedTopicMetadata</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearOriginalPrincipal(): CommandPartitionedTopicMetadata</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearRequestId(): CommandPartitionedTopicMetadata</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearTopic(): CommandPartitionedTopicMetadata</TD></TR>
<TR><TD ALIGN="LEFT" >+ copyFrom(_other: CommandPartitionedTopicMetadata): CommandPartitionedTopicMetadata</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(_buffer: ByteBuf, _size: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(a: byte[])</TD></TR>
<TR><TD ALIGN="LEFT" >+ setOriginalAuthData(originalAuthData: String): CommandPartitionedTopicMetadata</TD></TR>
<TR><TD ALIGN="LEFT" >+ setOriginalAuthMethod(originalAuthMethod: String): CommandPartitionedTopicMetadata</TD></TR>
<TR><TD ALIGN="LEFT" >+ setOriginalPrincipal(originalPrincipal: String): CommandPartitionedTopicMetadata</TD></TR>
<TR><TD ALIGN="LEFT" >+ setRequestId(requestId: long): CommandPartitionedTopicMetadata</TD></TR>
<TR><TD ALIGN="LEFT" >+ setTopic(topic: String): CommandPartitionedTopicMetadata</TD></TR>
<TR><TD ALIGN="LEFT" >+ toByteArray(): byte[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeTo(_b: ByteBuf): int</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

CommandPartitionedTopicMetadataResponse297559756[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)CommandPartitionedTopicMetadataResponse</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   _bitField0: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _cachedSize: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _messageBufferIdx: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _messageBufferLen: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _parsedBuffer: ByteBuf [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   error: ServerError [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   message: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   partitions: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   requestId: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   response: LookupType [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- checkRequiredFields()</TD></TR>
<TR><TD ALIGN="LEFT" >+ clear(): CommandPartitionedTopicMetadataResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearError(): CommandPartitionedTopicMetadataResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearMessage(): CommandPartitionedTopicMetadataResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearPartitions(): CommandPartitionedTopicMetadataResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearRequestId(): CommandPartitionedTopicMetadataResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearResponse(): CommandPartitionedTopicMetadataResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ copyFrom(_other: CommandPartitionedTopicMetadataResponse): CommandPartitionedTopicMetadataResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(_buffer: ByteBuf, _size: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(a: byte[])</TD></TR>
<TR><TD ALIGN="LEFT" >+ setError(error: ServerError): CommandPartitionedTopicMetadataResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ setMessage(message: String): CommandPartitionedTopicMetadataResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ setPartitions(partitions: int): CommandPartitionedTopicMetadataResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ setRequestId(requestId: long): CommandPartitionedTopicMetadataResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ setResponse(response: LookupType): CommandPartitionedTopicMetadataResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ toByteArray(): byte[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeTo(_b: ByteBuf): int</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

CommandPing297559756[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)CommandPing</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   _cachedSize: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _parsedBuffer: ByteBuf [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ clear(): CommandPing</TD></TR>
<TR><TD ALIGN="LEFT" >+ copyFrom(_other: CommandPing): CommandPing</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(_buffer: ByteBuf, _size: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(a: byte[])</TD></TR>
<TR><TD ALIGN="LEFT" >+ toByteArray(): byte[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeTo(_b: ByteBuf): int</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

CommandPong297559756[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)CommandPong</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   _cachedSize: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _parsedBuffer: ByteBuf [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ clear(): CommandPong</TD></TR>
<TR><TD ALIGN="LEFT" >+ copyFrom(_other: CommandPong): CommandPong</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(_buffer: ByteBuf, _size: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(a: byte[])</TD></TR>
<TR><TD ALIGN="LEFT" >+ toByteArray(): byte[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeTo(_b: ByteBuf): int</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

CommandProducer297559756[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)CommandProducer</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   _bitField0: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _cachedSize: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _initialSubscriptionNameBufferIdx: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _initialSubscriptionNameBufferLen: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _metadatasCount: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _parsedBuffer: ByteBuf [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _producerNameBufferIdx: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _producerNameBufferLen: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _topicBufferIdx: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _topicBufferLen: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   encrypted: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   epoch: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   initialSubscriptionName: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   metadatas: List&lt;KeyValue&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   producerAccessMode: ProducerAccessMode [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   producerId: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   producerName: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   requestId: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   schema: Schema [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   topic: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   topicEpoch: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   txnEnabled: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   userProvidedProducerName: boolean [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ addAllMetadatas(metadatas: Iterable&lt;KeyValue&gt;): CommandProducer</TD></TR>
<TR><TD ALIGN="LEFT" >+ addMetadata(): KeyValue</TD></TR>
<TR><TD ALIGN="LEFT" >- checkRequiredFields()</TD></TR>
<TR><TD ALIGN="LEFT" >+ clear(): CommandProducer</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearEncrypted(): CommandProducer</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearEpoch(): CommandProducer</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearInitialSubscriptionName(): CommandProducer</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearMetadata(): CommandProducer</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearProducerAccessMode(): CommandProducer</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearProducerId(): CommandProducer</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearProducerName(): CommandProducer</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearRequestId(): CommandProducer</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearSchema(): CommandProducer</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearTopic(): CommandProducer</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearTopicEpoch(): CommandProducer</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearTxnEnabled(): CommandProducer</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearUserProvidedProducerName(): CommandProducer</TD></TR>
<TR><TD ALIGN="LEFT" >+ copyFrom(_other: CommandProducer): CommandProducer</TD></TR>
<TR><TD ALIGN="LEFT" >+ getMetadataAt(idx: int): KeyValue</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(_buffer: ByteBuf, _size: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(a: byte[])</TD></TR>
<TR><TD ALIGN="LEFT" >+ setEncrypted(encrypted: boolean): CommandProducer</TD></TR>
<TR><TD ALIGN="LEFT" >+ setEpoch(epoch: long): CommandProducer</TD></TR>
<TR><TD ALIGN="LEFT" >+ setInitialSubscriptionName(initialSubscriptionName: String): CommandProducer</TD></TR>
<TR><TD ALIGN="LEFT" >+ setProducerAccessMode(producerAccessMode: ProducerAccessMode): CommandProducer</TD></TR>
<TR><TD ALIGN="LEFT" >+ setProducerId(producerId: long): CommandProducer</TD></TR>
<TR><TD ALIGN="LEFT" >+ setProducerName(producerName: String): CommandProducer</TD></TR>
<TR><TD ALIGN="LEFT" >+ setRequestId(requestId: long): CommandProducer</TD></TR>
<TR><TD ALIGN="LEFT" >+ setSchema(): Schema</TD></TR>
<TR><TD ALIGN="LEFT" >+ setTopic(topic: String): CommandProducer</TD></TR>
<TR><TD ALIGN="LEFT" >+ setTopicEpoch(topicEpoch: long): CommandProducer</TD></TR>
<TR><TD ALIGN="LEFT" >+ setTxnEnabled(txnEnabled: boolean): CommandProducer</TD></TR>
<TR><TD ALIGN="LEFT" >+ setUserProvidedProducerName(userProvidedProducerName: boolean): CommandProducer</TD></TR>
<TR><TD ALIGN="LEFT" >+ toByteArray(): byte[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeTo(_b: ByteBuf): int</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

CommandProducerSuccess297559756[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)CommandProducerSuccess</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   _bitField0: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _cachedSize: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _parsedBuffer: ByteBuf [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _producerNameBufferIdx: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _producerNameBufferLen: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _schemaVersionIdx: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _schemaVersionLen: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   lastSequenceId: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   producerName: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   producerReady: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   requestId: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   schemaVersion: ByteBuf [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   topicEpoch: long [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- checkRequiredFields()</TD></TR>
<TR><TD ALIGN="LEFT" >+ clear(): CommandProducerSuccess</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearLastSequenceId(): CommandProducerSuccess</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearProducerName(): CommandProducerSuccess</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearProducerReady(): CommandProducerSuccess</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearRequestId(): CommandProducerSuccess</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearSchemaVersion(): CommandProducerSuccess</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearTopicEpoch(): CommandProducerSuccess</TD></TR>
<TR><TD ALIGN="LEFT" >+ copyFrom(_other: CommandProducerSuccess): CommandProducerSuccess</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(_buffer: ByteBuf, _size: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(a: byte[])</TD></TR>
<TR><TD ALIGN="LEFT" >+ setLastSequenceId(lastSequenceId: long): CommandProducerSuccess</TD></TR>
<TR><TD ALIGN="LEFT" >+ setProducerName(producerName: String): CommandProducerSuccess</TD></TR>
<TR><TD ALIGN="LEFT" >+ setProducerReady(producerReady: boolean): CommandProducerSuccess</TD></TR>
<TR><TD ALIGN="LEFT" >+ setRequestId(requestId: long): CommandProducerSuccess</TD></TR>
<TR><TD ALIGN="LEFT" >+ setSchemaVersion(schemaVersion: byte[]): CommandProducerSuccess</TD></TR>
<TR><TD ALIGN="LEFT" >+ setSchemaVersion(schemaVersion: ByteBuf): CommandProducerSuccess</TD></TR>
<TR><TD ALIGN="LEFT" >+ setTopicEpoch(topicEpoch: long): CommandProducerSuccess</TD></TR>
<TR><TD ALIGN="LEFT" >+ toByteArray(): byte[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeTo(_b: ByteBuf): int</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

CommandReachedEndOfTopic297559756[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)CommandReachedEndOfTopic</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   _bitField0: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _cachedSize: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _parsedBuffer: ByteBuf [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   consumerId: long [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- checkRequiredFields()</TD></TR>
<TR><TD ALIGN="LEFT" >+ clear(): CommandReachedEndOfTopic</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearConsumerId(): CommandReachedEndOfTopic</TD></TR>
<TR><TD ALIGN="LEFT" >+ copyFrom(_other: CommandReachedEndOfTopic): CommandReachedEndOfTopic</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(_buffer: ByteBuf, _size: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(a: byte[])</TD></TR>
<TR><TD ALIGN="LEFT" >+ setConsumerId(consumerId: long): CommandReachedEndOfTopic</TD></TR>
<TR><TD ALIGN="LEFT" >+ toByteArray(): byte[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeTo(_b: ByteBuf): int</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

CommandRedeliverUnacknowledgedMessages297559756[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)CommandRedeliverUnacknowledgedMessages</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   _bitField0: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _cachedSize: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _messageIdsCount: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _parsedBuffer: ByteBuf [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   consumerEpoch: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   consumerId: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   messageIds: List&lt;MessageIdData&gt; [0..*]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ addAllMessageIds(messageIds: Iterable&lt;MessageIdData&gt;): CommandRedeliverUnacknowledgedMessages</TD></TR>
<TR><TD ALIGN="LEFT" >+ addMessageId(): MessageIdData</TD></TR>
<TR><TD ALIGN="LEFT" >- checkRequiredFields()</TD></TR>
<TR><TD ALIGN="LEFT" >+ clear(): CommandRedeliverUnacknowledgedMessages</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearConsumerEpoch(): CommandRedeliverUnacknowledgedMessages</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearConsumerId(): CommandRedeliverUnacknowledgedMessages</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearMessageIds(): CommandRedeliverUnacknowledgedMessages</TD></TR>
<TR><TD ALIGN="LEFT" >+ copyFrom(_other: CommandRedeliverUnacknowledgedMessages): CommandRedeliverUnacknowledgedMessages</TD></TR>
<TR><TD ALIGN="LEFT" >+ getMessageIdAt(idx: int): MessageIdData</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(_buffer: ByteBuf, _size: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(a: byte[])</TD></TR>
<TR><TD ALIGN="LEFT" >+ setConsumerEpoch(consumerEpoch: long): CommandRedeliverUnacknowledgedMessages</TD></TR>
<TR><TD ALIGN="LEFT" >+ setConsumerId(consumerId: long): CommandRedeliverUnacknowledgedMessages</TD></TR>
<TR><TD ALIGN="LEFT" >+ toByteArray(): byte[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeTo(_b: ByteBuf): int</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

CommandSeek297559756[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)CommandSeek</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   _bitField0: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _cachedSize: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _parsedBuffer: ByteBuf [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   consumerId: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   messageId: MessageIdData [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   messagePublishTime: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   requestId: long [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- checkRequiredFields()</TD></TR>
<TR><TD ALIGN="LEFT" >+ clear(): CommandSeek</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearConsumerId(): CommandSeek</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearMessageId(): CommandSeek</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearMessagePublishTime(): CommandSeek</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearRequestId(): CommandSeek</TD></TR>
<TR><TD ALIGN="LEFT" >+ copyFrom(_other: CommandSeek): CommandSeek</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(_buffer: ByteBuf, _size: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(a: byte[])</TD></TR>
<TR><TD ALIGN="LEFT" >+ setConsumerId(consumerId: long): CommandSeek</TD></TR>
<TR><TD ALIGN="LEFT" >+ setMessageId(): MessageIdData</TD></TR>
<TR><TD ALIGN="LEFT" >+ setMessagePublishTime(messagePublishTime: long): CommandSeek</TD></TR>
<TR><TD ALIGN="LEFT" >+ setRequestId(requestId: long): CommandSeek</TD></TR>
<TR><TD ALIGN="LEFT" >+ toByteArray(): byte[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeTo(_b: ByteBuf): int</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

CommandSend297559756[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)CommandSend</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   _bitField0: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _cachedSize: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _parsedBuffer: ByteBuf [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   highestSequenceId: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   isChunk: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   marker: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   numMessages: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   producerId: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   sequenceId: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   txnidLeastBits: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   txnidMostBits: long [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- checkRequiredFields()</TD></TR>
<TR><TD ALIGN="LEFT" >+ clear(): CommandSend</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearHighestSequenceId(): CommandSend</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearIsChunk(): CommandSend</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearMarker(): CommandSend</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearNumMessages(): CommandSend</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearProducerId(): CommandSend</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearSequenceId(): CommandSend</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearTxnidLeastBits(): CommandSend</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearTxnidMostBits(): CommandSend</TD></TR>
<TR><TD ALIGN="LEFT" >+ copyFrom(_other: CommandSend): CommandSend</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(_buffer: ByteBuf, _size: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(a: byte[])</TD></TR>
<TR><TD ALIGN="LEFT" >+ setHighestSequenceId(highestSequenceId: long): CommandSend</TD></TR>
<TR><TD ALIGN="LEFT" >+ setIsChunk(isChunk: boolean): CommandSend</TD></TR>
<TR><TD ALIGN="LEFT" >+ setMarker(marker: boolean): CommandSend</TD></TR>
<TR><TD ALIGN="LEFT" >+ setNumMessages(numMessages: int): CommandSend</TD></TR>
<TR><TD ALIGN="LEFT" >+ setProducerId(producerId: long): CommandSend</TD></TR>
<TR><TD ALIGN="LEFT" >+ setSequenceId(sequenceId: long): CommandSend</TD></TR>
<TR><TD ALIGN="LEFT" >+ setTxnidLeastBits(txnidLeastBits: long): CommandSend</TD></TR>
<TR><TD ALIGN="LEFT" >+ setTxnidMostBits(txnidMostBits: long): CommandSend</TD></TR>
<TR><TD ALIGN="LEFT" >+ toByteArray(): byte[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeTo(_b: ByteBuf): int</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

CommandSendError297559756[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)CommandSendError</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   _bitField0: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _cachedSize: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _messageBufferIdx: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _messageBufferLen: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _parsedBuffer: ByteBuf [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   error: ServerError [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   message: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   producerId: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   sequenceId: long [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- checkRequiredFields()</TD></TR>
<TR><TD ALIGN="LEFT" >+ clear(): CommandSendError</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearError(): CommandSendError</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearMessage(): CommandSendError</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearProducerId(): CommandSendError</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearSequenceId(): CommandSendError</TD></TR>
<TR><TD ALIGN="LEFT" >+ copyFrom(_other: CommandSendError): CommandSendError</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(_buffer: ByteBuf, _size: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(a: byte[])</TD></TR>
<TR><TD ALIGN="LEFT" >+ setError(error: ServerError): CommandSendError</TD></TR>
<TR><TD ALIGN="LEFT" >+ setMessage(message: String): CommandSendError</TD></TR>
<TR><TD ALIGN="LEFT" >+ setProducerId(producerId: long): CommandSendError</TD></TR>
<TR><TD ALIGN="LEFT" >+ setSequenceId(sequenceId: long): CommandSendError</TD></TR>
<TR><TD ALIGN="LEFT" >+ toByteArray(): byte[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeTo(_b: ByteBuf): int</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

CommandSendReceipt297559756[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)CommandSendReceipt</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   _bitField0: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _cachedSize: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _parsedBuffer: ByteBuf [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   highestSequenceId: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   messageId: MessageIdData [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   producerId: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   sequenceId: long [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- checkRequiredFields()</TD></TR>
<TR><TD ALIGN="LEFT" >+ clear(): CommandSendReceipt</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearHighestSequenceId(): CommandSendReceipt</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearMessageId(): CommandSendReceipt</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearProducerId(): CommandSendReceipt</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearSequenceId(): CommandSendReceipt</TD></TR>
<TR><TD ALIGN="LEFT" >+ copyFrom(_other: CommandSendReceipt): CommandSendReceipt</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(_buffer: ByteBuf, _size: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(a: byte[])</TD></TR>
<TR><TD ALIGN="LEFT" >+ setHighestSequenceId(highestSequenceId: long): CommandSendReceipt</TD></TR>
<TR><TD ALIGN="LEFT" >+ setMessageId(): MessageIdData</TD></TR>
<TR><TD ALIGN="LEFT" >+ setProducerId(producerId: long): CommandSendReceipt</TD></TR>
<TR><TD ALIGN="LEFT" >+ setSequenceId(sequenceId: long): CommandSendReceipt</TD></TR>
<TR><TD ALIGN="LEFT" >+ toByteArray(): byte[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeTo(_b: ByteBuf): int</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

CommandSubscribe297559756[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)CommandSubscribe</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   _bitField0: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _cachedSize: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _consumerNameBufferIdx: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _consumerNameBufferLen: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _metadatasCount: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _parsedBuffer: ByteBuf [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _subscriptionBufferIdx: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _subscriptionBufferLen: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _subscriptionPropertiesCount: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _topicBufferIdx: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _topicBufferLen: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   consumerEpoch: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   consumerId: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   consumerName: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   durable: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   forceTopicCreation: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   initialPosition: InitialPosition [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   keySharedMeta: KeySharedMeta [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   metadatas: List&lt;KeyValue&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   priorityLevel: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   readCompacted: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   replicateSubscriptionState: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   requestId: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   schema: Schema [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   startMessageId: MessageIdData [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   startMessageRollbackDurationSec: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   subType: SubType [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   subscription: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   subscriptionProperties: List&lt;KeyValue&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   topic: String [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ addAllMetadatas(metadatas: Iterable&lt;KeyValue&gt;): CommandSubscribe</TD></TR>
<TR><TD ALIGN="LEFT" >+ addAllSubscriptionProperties(subscriptionProperties: Iterable&lt;KeyValue&gt;): CommandSubscribe</TD></TR>
<TR><TD ALIGN="LEFT" >+ addMetadata(): KeyValue</TD></TR>
<TR><TD ALIGN="LEFT" >+ addSubscriptionProperty(): KeyValue</TD></TR>
<TR><TD ALIGN="LEFT" >- checkRequiredFields()</TD></TR>
<TR><TD ALIGN="LEFT" >+ clear(): CommandSubscribe</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearConsumerEpoch(): CommandSubscribe</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearConsumerId(): CommandSubscribe</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearConsumerName(): CommandSubscribe</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearDurable(): CommandSubscribe</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearForceTopicCreation(): CommandSubscribe</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearInitialPosition(): CommandSubscribe</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearKeySharedMeta(): CommandSubscribe</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearMetadata(): CommandSubscribe</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearPriorityLevel(): CommandSubscribe</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearReadCompacted(): CommandSubscribe</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearReplicateSubscriptionState(): CommandSubscribe</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearRequestId(): CommandSubscribe</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearSchema(): CommandSubscribe</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearStartMessageId(): CommandSubscribe</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearStartMessageRollbackDurationSec(): CommandSubscribe</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearSubType(): CommandSubscribe</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearSubscription(): CommandSubscribe</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearSubscriptionProperties(): CommandSubscribe</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearTopic(): CommandSubscribe</TD></TR>
<TR><TD ALIGN="LEFT" >+ copyFrom(_other: CommandSubscribe): CommandSubscribe</TD></TR>
<TR><TD ALIGN="LEFT" >+ getMetadataAt(idx: int): KeyValue</TD></TR>
<TR><TD ALIGN="LEFT" >+ getSubscriptionPropertyAt(idx: int): KeyValue</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(_buffer: ByteBuf, _size: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(a: byte[])</TD></TR>
<TR><TD ALIGN="LEFT" >+ setConsumerEpoch(consumerEpoch: long): CommandSubscribe</TD></TR>
<TR><TD ALIGN="LEFT" >+ setConsumerId(consumerId: long): CommandSubscribe</TD></TR>
<TR><TD ALIGN="LEFT" >+ setConsumerName(consumerName: String): CommandSubscribe</TD></TR>
<TR><TD ALIGN="LEFT" >+ setDurable(durable: boolean): CommandSubscribe</TD></TR>
<TR><TD ALIGN="LEFT" >+ setForceTopicCreation(forceTopicCreation: boolean): CommandSubscribe</TD></TR>
<TR><TD ALIGN="LEFT" >+ setInitialPosition(initialPosition: InitialPosition): CommandSubscribe</TD></TR>
<TR><TD ALIGN="LEFT" >+ setKeySharedMeta(): KeySharedMeta</TD></TR>
<TR><TD ALIGN="LEFT" >+ setPriorityLevel(priorityLevel: int): CommandSubscribe</TD></TR>
<TR><TD ALIGN="LEFT" >+ setReadCompacted(readCompacted: boolean): CommandSubscribe</TD></TR>
<TR><TD ALIGN="LEFT" >+ setReplicateSubscriptionState(replicateSubscriptionState: boolean): CommandSubscribe</TD></TR>
<TR><TD ALIGN="LEFT" >+ setRequestId(requestId: long): CommandSubscribe</TD></TR>
<TR><TD ALIGN="LEFT" >+ setSchema(): Schema</TD></TR>
<TR><TD ALIGN="LEFT" >+ setStartMessageId(): MessageIdData</TD></TR>
<TR><TD ALIGN="LEFT" >+ setStartMessageRollbackDurationSec(startMessageRollbackDurationSec: long): CommandSubscribe</TD></TR>
<TR><TD ALIGN="LEFT" >+ setSubType(subType: SubType): CommandSubscribe</TD></TR>
<TR><TD ALIGN="LEFT" >+ setSubscription(subscription: String): CommandSubscribe</TD></TR>
<TR><TD ALIGN="LEFT" >+ setTopic(topic: String): CommandSubscribe</TD></TR>
<TR><TD ALIGN="LEFT" >+ toByteArray(): byte[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeTo(_b: ByteBuf): int</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

CommandSuccess297559756[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)CommandSuccess</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   _bitField0: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _cachedSize: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _parsedBuffer: ByteBuf [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   requestId: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   schema: Schema [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- checkRequiredFields()</TD></TR>
<TR><TD ALIGN="LEFT" >+ clear(): CommandSuccess</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearRequestId(): CommandSuccess</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearSchema(): CommandSuccess</TD></TR>
<TR><TD ALIGN="LEFT" >+ copyFrom(_other: CommandSuccess): CommandSuccess</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(_buffer: ByteBuf, _size: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(a: byte[])</TD></TR>
<TR><TD ALIGN="LEFT" >+ setRequestId(requestId: long): CommandSuccess</TD></TR>
<TR><TD ALIGN="LEFT" >+ setSchema(): Schema</TD></TR>
<TR><TD ALIGN="LEFT" >+ toByteArray(): byte[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeTo(_b: ByteBuf): int</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

CommandTcClientConnectRequest297559756[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)CommandTcClientConnectRequest</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   _bitField0: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _cachedSize: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _parsedBuffer: ByteBuf [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   requestId: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   tcId: long [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- checkRequiredFields()</TD></TR>
<TR><TD ALIGN="LEFT" >+ clear(): CommandTcClientConnectRequest</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearRequestId(): CommandTcClientConnectRequest</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearTcId(): CommandTcClientConnectRequest</TD></TR>
<TR><TD ALIGN="LEFT" >+ copyFrom(_other: CommandTcClientConnectRequest): CommandTcClientConnectRequest</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(_buffer: ByteBuf, _size: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(a: byte[])</TD></TR>
<TR><TD ALIGN="LEFT" >+ setRequestId(requestId: long): CommandTcClientConnectRequest</TD></TR>
<TR><TD ALIGN="LEFT" >+ setTcId(tcId: long): CommandTcClientConnectRequest</TD></TR>
<TR><TD ALIGN="LEFT" >+ toByteArray(): byte[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeTo(_b: ByteBuf): int</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

CommandTcClientConnectResponse297559756[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)CommandTcClientConnectResponse</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   _bitField0: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _cachedSize: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _messageBufferIdx: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _messageBufferLen: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _parsedBuffer: ByteBuf [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   error: ServerError [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   message: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   requestId: long [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- checkRequiredFields()</TD></TR>
<TR><TD ALIGN="LEFT" >+ clear(): CommandTcClientConnectResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearError(): CommandTcClientConnectResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearMessage(): CommandTcClientConnectResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearRequestId(): CommandTcClientConnectResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ copyFrom(_other: CommandTcClientConnectResponse): CommandTcClientConnectResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(_buffer: ByteBuf, _size: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(a: byte[])</TD></TR>
<TR><TD ALIGN="LEFT" >+ setError(error: ServerError): CommandTcClientConnectResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ setMessage(message: String): CommandTcClientConnectResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ setRequestId(requestId: long): CommandTcClientConnectResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ toByteArray(): byte[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeTo(_b: ByteBuf): int</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

CommandUnsubscribe297559756[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)CommandUnsubscribe</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   _bitField0: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _cachedSize: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _parsedBuffer: ByteBuf [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   consumerId: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   requestId: long [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- checkRequiredFields()</TD></TR>
<TR><TD ALIGN="LEFT" >+ clear(): CommandUnsubscribe</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearConsumerId(): CommandUnsubscribe</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearRequestId(): CommandUnsubscribe</TD></TR>
<TR><TD ALIGN="LEFT" >+ copyFrom(_other: CommandUnsubscribe): CommandUnsubscribe</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(_buffer: ByteBuf, _size: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(a: byte[])</TD></TR>
<TR><TD ALIGN="LEFT" >+ setConsumerId(consumerId: long): CommandUnsubscribe</TD></TR>
<TR><TD ALIGN="LEFT" >+ setRequestId(requestId: long): CommandUnsubscribe</TD></TR>
<TR><TD ALIGN="LEFT" >+ toByteArray(): byte[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeTo(_b: ByteBuf): int</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

CommandUtils1070348832[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)CommandUtils</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ metadataFromCommand(commandProducer: CommandProducer): Map&lt;String, String&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ metadataFromCommand(commandSubscribe: CommandSubscribe): Map&lt;String, String&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- toMap(keyValues: List&lt;KeyValue&gt;): Map&lt;String, String&gt;</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

Commands1070348832[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)Commands</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ addBrokerEntryMetadata(headerAndPayload: ByteBuf, interceptors: Set&lt;BrokerEntryMetadataInterceptor&gt;): ByteBuf</TD></TR>
<TR><TD ALIGN="LEFT" >+ addBrokerEntryMetadata(headerAndPayload: ByteBuf, brokerInterceptors: Set&lt;BrokerEntryMetadataInterceptor&gt;, numberOfMessages: int): ByteBuf</TD></TR>
<TR><TD ALIGN="LEFT" >- convertKeySharedMode(mode: KeySharedMode): KeySharedMode</TD></TR>
<TR><TD ALIGN="LEFT" >+ convertProducerAccessMode(accessMode: ProducerAccessMode): ProducerAccessMode</TD></TR>
<TR><TD ALIGN="LEFT" >- convertSchema(schemaInfo: SchemaInfo, schema: Schema)</TD></TR>
<TR><TD ALIGN="LEFT" >+ deSerializeSingleMessageInBatch(uncompressedPayload: ByteBuf, singleMessageMetadata: SingleMessageMetadata, index: int, batchSize: int): ByteBuf</TD></TR>
<TR><TD ALIGN="LEFT" >+ getEntryTimestamp(headersAndPayloadWithBrokerEntryMetadata: ByteBuf): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ getNumberOfMessagesInBatch(metadataAndPayload: ByteBuf, subscription: String, consumerId: long): int</TD></TR>
<TR><TD ALIGN="LEFT" >- getSchemaType(type: SchemaType): Type</TD></TR>
<TR><TD ALIGN="LEFT" >+ getSchemaType(type: Type): SchemaType</TD></TR>
<TR><TD ALIGN="LEFT" >+ hasChecksum(buffer: ByteBuf): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ initBatchMessageMetadata(messageMetadata: MessageMetadata, builder: MessageMetadata): long</TD></TR>
<TR><TD ALIGN="LEFT" >- localCmd(type: Type): BaseCommand</TD></TR>
<TR><TD ALIGN="LEFT" >+ newAck(consumerId: long, ledgerId: long, entryId: long, ackSet: BitSetRecyclable, ackType: AckType, validationError: ValidationError, properties: Map&lt;String, Long&gt;, requestId: long): ByteBuf</TD></TR>
<TR><TD ALIGN="LEFT" >+ newAck(consumerId: long, ledgerId: long, entryId: long, ackSet: BitSetRecyclable, ackType: AckType, validationError: ValidationError, properties: Map&lt;String, Long&gt;, txnIdLeastBits: long, txnIdMostBits: long, requestId: long, batchSize: int): ByteBuf</TD></TR>
<TR><TD ALIGN="LEFT" >+ newAck(consumerId: long, ledgerId: long, entryId: long, ackSet: BitSetRecyclable, ackType: AckType, validationError: ValidationError, properties: Map&lt;String, Long&gt;, txnIdLeastBits: long, txnIdMostBits: long, requestId: long): ByteBuf</TD></TR>
<TR><TD ALIGN="LEFT" >+ newAckResponse(requestId: long, error: ServerError, errorMsg: String, consumerId: long): ByteBuf</TD></TR>
<TR><TD ALIGN="LEFT" >+ newActiveConsumerChange(consumerId: long, isActive: boolean): ByteBuf</TD></TR>
<TR><TD ALIGN="LEFT" >+ newAddPartitionToTxn(requestId: long, txnIdLeastBits: long, txnIdMostBits: long, partitions: List&lt;String&gt;): ByteBuf</TD></TR>
<TR><TD ALIGN="LEFT" >+ newAddPartitionToTxnResponse(requestId: long, txnIdLeastBits: long, txnIdMostBits: long): ByteBuf</TD></TR>
<TR><TD ALIGN="LEFT" >+ newAddPartitionToTxnResponse(requestId: long, txnIdMostBits: long, error: ServerError, errorMsg: String): ByteBuf</TD></TR>
<TR><TD ALIGN="LEFT" >+ newAddSubscriptionToTxn(requestId: long, txnIdLeastBits: long, txnIdMostBits: long, subscriptions: List&lt;Subscription&gt;): ByteBuf</TD></TR>
<TR><TD ALIGN="LEFT" >+ newAddSubscriptionToTxnResponse(requestId: long, txnIdLeastBits: long, txnIdMostBits: long): ByteBuf</TD></TR>
<TR><TD ALIGN="LEFT" >+ newAddSubscriptionToTxnResponse(requestId: long, txnIdMostBits: long, error: ServerError, errorMsg: String): ByteBuf</TD></TR>
<TR><TD ALIGN="LEFT" >+ newAuthChallenge(authMethod: String, brokerData: AuthData, clientProtocolVersion: int): ByteBuf</TD></TR>
<TR><TD ALIGN="LEFT" >+ newAuthResponse(authMethod: String, clientData: AuthData, clientProtocolVersion: int, clientVersion: String): ByteBuf</TD></TR>
<TR><TD ALIGN="LEFT" >+ newCloseConsumer(consumerId: long, requestId: long): ByteBuf</TD></TR>
<TR><TD ALIGN="LEFT" >+ newCloseProducer(producerId: long, requestId: long): ByteBuf</TD></TR>
<TR><TD ALIGN="LEFT" >+ newConnect(authMethodName: String, authData: String, libVersion: String): ByteBuf</TD></TR>
<TR><TD ALIGN="LEFT" >+ newConnect(authMethodName: String, authData: String, libVersion: String, targetBroker: String): ByteBuf</TD></TR>
<TR><TD ALIGN="LEFT" >+ newConnect(authMethodName: String, authData: String, libVersion: String, targetBroker: String, originalPrincipal: String, clientAuthData: String, clientAuthMethod: String): ByteBuf</TD></TR>
<TR><TD ALIGN="LEFT" >+ newConnect(authMethodName: String, authData: String, protocolVersion: int, libVersion: String, targetBroker: String, originalPrincipal: String, originalAuthData: String, originalAuthMethod: String): ByteBuf</TD></TR>
<TR><TD ALIGN="LEFT" >+ newConnect(authMethodName: String, authData: AuthData, protocolVersion: int, libVersion: String, targetBroker: String, originalPrincipal: String, originalAuthData: AuthData, originalAuthMethod: String): ByteBuf</TD></TR>
<TR><TD ALIGN="LEFT" >+ newConnected(clientProtocoVersion: int): ByteBuf</TD></TR>
<TR><TD ALIGN="LEFT" >+ newConnected(clientProtocolVersion: int, maxMessageSize: int): ByteBuf</TD></TR>
<TR><TD ALIGN="LEFT" >+ newConnectedCommand(clientProtocolVersion: int, maxMessageSize: int): BaseCommand</TD></TR>
<TR><TD ALIGN="LEFT" >+ newConsumerStatsResponse(serverError: ServerError, errMsg: String, requestId: long): ByteBuf</TD></TR>
<TR><TD ALIGN="LEFT" >+ newConsumerStatsResponseCommand(serverError: ServerError, errMsg: String, requestId: long): BaseCommand</TD></TR>
<TR><TD ALIGN="LEFT" >+ newEndTxn(requestId: long, txnIdLeastBits: long, txnIdMostBits: long, txnAction: TxnAction): BaseCommand</TD></TR>
<TR><TD ALIGN="LEFT" >+ newEndTxnOnPartition(requestId: long, txnIdLeastBits: long, txnIdMostBits: long, topic: String, txnAction: TxnAction, lowWaterMark: long): ByteBuf</TD></TR>
<TR><TD ALIGN="LEFT" >+ newEndTxnOnPartitionResponse(requestId: long, txnIdLeastBits: long, txnIdMostBits: long): ByteBuf</TD></TR>
<TR><TD ALIGN="LEFT" >+ newEndTxnOnPartitionResponse(requestId: long, error: ServerError, errorMsg: String, txnIdLeastBits: long, txnIdMostBits: long): ByteBuf</TD></TR>
<TR><TD ALIGN="LEFT" >+ newEndTxnOnSubscription(requestId: long, txnIdLeastBits: long, txnIdMostBits: long, topic: String, subscription: String, txnAction: TxnAction, lowWaterMark: long): ByteBuf</TD></TR>
<TR><TD ALIGN="LEFT" >+ newEndTxnOnSubscriptionResponse(requestId: long, txnIdLeastBits: long, txnIdMostBits: long): ByteBuf</TD></TR>
<TR><TD ALIGN="LEFT" >+ newEndTxnOnSubscriptionResponse(requestId: long, txnIdLeastBits: long, txnIdMostBits: long, error: ServerError, errorMsg: String): ByteBuf</TD></TR>
<TR><TD ALIGN="LEFT" >+ newEndTxnResponse(requestId: long, txnIdLeastBits: long, txnIdMostBits: long): ByteBuf</TD></TR>
<TR><TD ALIGN="LEFT" >+ newEndTxnResponse(requestId: long, txnIdMostBits: long, error: ServerError, errorMsg: String): ByteBuf</TD></TR>
<TR><TD ALIGN="LEFT" >+ newError(requestId: long, serverError: ServerError, message: String): ByteBuf</TD></TR>
<TR><TD ALIGN="LEFT" >+ newErrorCommand(requestId: long, serverError: ServerError, message: String): BaseCommand</TD></TR>
<TR><TD ALIGN="LEFT" >+ newFlow(consumerId: long, messagePermits: int): ByteBuf</TD></TR>
<TR><TD ALIGN="LEFT" >+ newGetLastMessageId(consumerId: long, requestId: long): ByteBuf</TD></TR>
<TR><TD ALIGN="LEFT" >+ newGetLastMessageIdResponse(requestId: long, lastMessageLedgerId: long, lastMessageEntryId: long, lastMessagePartitionIdx: int, lastMessageBatchIndex: int, markDeletePositionLedgerId: long, markDeletePositionEntryId: long): ByteBuf</TD></TR>
<TR><TD ALIGN="LEFT" >+ newGetOrCreateSchema(requestId: long, topic: String, schemaInfo: SchemaInfo): ByteBuf</TD></TR>
<TR><TD ALIGN="LEFT" >+ newGetOrCreateSchemaResponse(requestId: long, schemaVersion: SchemaVersion): ByteBuf</TD></TR>
<TR><TD ALIGN="LEFT" >+ newGetOrCreateSchemaResponseCommand(requestId: long, schemaVersion: SchemaVersion): BaseCommand</TD></TR>
<TR><TD ALIGN="LEFT" >+ newGetOrCreateSchemaResponseError(requestId: long, error: ServerError, errorMessage: String): ByteBuf</TD></TR>
<TR><TD ALIGN="LEFT" >+ newGetOrCreateSchemaResponseErrorCommand(requestId: long, error: ServerError, errorMessage: String): BaseCommand</TD></TR>
<TR><TD ALIGN="LEFT" >+ newGetSchema(requestId: long, topic: String, version: Optional&lt;SchemaVersion&gt;): ByteBuf</TD></TR>
<TR><TD ALIGN="LEFT" >+ newGetSchemaResponse(requestId: long, response: CommandGetSchemaResponse): ByteBuf</TD></TR>
<TR><TD ALIGN="LEFT" >+ newGetSchemaResponse(requestId: long, schemaInfo: SchemaInfo, version: SchemaVersion): ByteBuf</TD></TR>
<TR><TD ALIGN="LEFT" >+ newGetSchemaResponseCommand(requestId: long, schemaInfo: SchemaInfo, version: SchemaVersion): BaseCommand</TD></TR>
<TR><TD ALIGN="LEFT" >+ newGetSchemaResponseError(requestId: long, error: ServerError, errorMessage: String): ByteBuf</TD></TR>
<TR><TD ALIGN="LEFT" >+ newGetSchemaResponseErrorCommand(requestId: long, error: ServerError, errorMessage: String): BaseCommand</TD></TR>
<TR><TD ALIGN="LEFT" >+ newGetTopicsOfNamespaceRequest(namespace: String, requestId: long, mode: Mode): ByteBuf</TD></TR>
<TR><TD ALIGN="LEFT" >+ newGetTopicsOfNamespaceResponse(topics: List&lt;String&gt;, requestId: long): ByteBuf</TD></TR>
<TR><TD ALIGN="LEFT" >+ newGetTopicsOfNamespaceResponseCommand(topics: List&lt;String&gt;, requestId: long): BaseCommand</TD></TR>
<TR><TD ALIGN="LEFT" >+ newLookup(topic: String, authoritative: boolean, requestId: long): ByteBuf</TD></TR>
<TR><TD ALIGN="LEFT" >+ newLookup(topic: String, listenerName: String, authoritative: boolean, requestId: long): ByteBuf</TD></TR>
<TR><TD ALIGN="LEFT" >+ newLookupErrorResponse(error: ServerError, errorMsg: String, requestId: long): ByteBuf</TD></TR>
<TR><TD ALIGN="LEFT" >+ newLookupErrorResponseCommand(error: ServerError, errorMsg: String, requestId: long): BaseCommand</TD></TR>
<TR><TD ALIGN="LEFT" >+ newLookupResponse(brokerServiceUrl: String, brokerServiceUrlTls: String, authoritative: boolean, lookupType: LookupType, requestId: long, proxyThroughServiceUrl: boolean): ByteBuf</TD></TR>
<TR><TD ALIGN="LEFT" >+ newLookupResponseCommand(brokerServiceUrl: String, brokerServiceUrlTls: String, authoritative: boolean, lookupType: LookupType, requestId: long, proxyThroughServiceUrl: boolean): BaseCommand</TD></TR>
<TR><TD ALIGN="LEFT" >+ newMessage(consumerId: long, ledgerId: long, entryId: long, partition: int, redeliveryCount: int, metadataAndPayload: ByteBuf, ackSet: long[]): ByteBufPair</TD></TR>
<TR><TD ALIGN="LEFT" >+ newMessageCommand(consumerId: long, ledgerId: long, entryId: long, partition: int, redeliveryCount: int, ackSet: long[], consumerEpoch: long): BaseCommand</TD></TR>
<TR><TD ALIGN="LEFT" >+ newMultiMessageAck(consumerId: long, entries: List&lt;Triple&lt;Long, Long, ConcurrentBitSetRecyclable&gt;&gt;, requestId: long): ByteBuf</TD></TR>
<TR><TD ALIGN="LEFT" >- newMultiMessageAckCommon(entries: List&lt;Triple&lt;Long, Long, ConcurrentBitSetRecyclable&gt;&gt;): BaseCommand</TD></TR>
<TR><TD ALIGN="LEFT" >+ newMultiTransactionMessageAck(consumerId: long, txnID: TxnID, entries: List&lt;Triple&lt;Long, Long, ConcurrentBitSetRecyclable&gt;&gt;): ByteBuf</TD></TR>
<TR><TD ALIGN="LEFT" >+ newPartitionMetadataRequest(topic: String, requestId: long): ByteBuf</TD></TR>
<TR><TD ALIGN="LEFT" >+ newPartitionMetadataResponse(error: ServerError, errorMsg: String, requestId: long): ByteBuf</TD></TR>
<TR><TD ALIGN="LEFT" >+ newPartitionMetadataResponse(partitions: int, requestId: long): ByteBuf</TD></TR>
<TR><TD ALIGN="LEFT" >+ newPartitionMetadataResponseCommand(error: ServerError, errorMsg: String, requestId: long): BaseCommand</TD></TR>
<TR><TD ALIGN="LEFT" >+ newPartitionMetadataResponseCommand(partitions: int, requestId: long): BaseCommand</TD></TR>
<TR><TD ALIGN="LEFT" ># newPing(): ByteBuf</TD></TR>
<TR><TD ALIGN="LEFT" >+ newPong(): ByteBuf</TD></TR>
<TR><TD ALIGN="LEFT" >+ newProducer(topic: String, producerId: long, requestId: long, producerName: String, metadata: Map&lt;String, String&gt;, isTxnEnabled: boolean): ByteBuf</TD></TR>
<TR><TD ALIGN="LEFT" >+ newProducer(topic: String, producerId: long, requestId: long, producerName: String, encrypted: boolean, metadata: Map&lt;String, String&gt;, isTxnEnabled: boolean): ByteBuf</TD></TR>
<TR><TD ALIGN="LEFT" >+ newProducer(topic: String, producerId: long, requestId: long, producerName: String, encrypted: boolean, metadata: Map&lt;String, String&gt;, schemaInfo: SchemaInfo, epoch: long, userProvidedProducerName: boolean, accessMode: ProducerAccessMode, topicEpoch: Optional&lt;Long&gt;, isTxnEnabled: boolean): ByteBuf</TD></TR>
<TR><TD ALIGN="LEFT" >+ newProducer(topic: String, producerId: long, requestId: long, producerName: String, encrypted: boolean, metadata: Map&lt;String, String&gt;, schemaInfo: SchemaInfo, epoch: long, userProvidedProducerName: boolean, accessMode: ProducerAccessMode, topicEpoch: Optional&lt;Long&gt;, isTxnEnabled: boolean, initialSubscriptionName: String): ByteBuf</TD></TR>
<TR><TD ALIGN="LEFT" >+ newProducerSuccess(requestId: long, producerName: String, schemaVersion: SchemaVersion): ByteBuf</TD></TR>
<TR><TD ALIGN="LEFT" >+ newProducerSuccess(requestId: long, producerName: String, lastSequenceId: long, schemaVersion: SchemaVersion, topicEpoch: Optional&lt;Long&gt;, isProducerReady: boolean): ByteBuf</TD></TR>
<TR><TD ALIGN="LEFT" >+ newProducerSuccessCommand(requestId: long, producerName: String, schemaVersion: SchemaVersion): BaseCommand</TD></TR>
<TR><TD ALIGN="LEFT" >+ newProducerSuccessCommand(requestId: long, producerName: String, lastSequenceId: long, schemaVersion: SchemaVersion, topicEpoch: Optional&lt;Long&gt;, isProducerReady: boolean): BaseCommand</TD></TR>
<TR><TD ALIGN="LEFT" >+ newReachedEndOfTopic(consumerId: long): ByteBuf</TD></TR>
<TR><TD ALIGN="LEFT" >+ newRedeliverUnacknowledgedMessages(consumerId: long, consumerEpoch: long): ByteBuf</TD></TR>
<TR><TD ALIGN="LEFT" >+ newRedeliverUnacknowledgedMessages(consumerId: long, messageIds: List&lt;MessageIdData&gt;): ByteBuf</TD></TR>
<TR><TD ALIGN="LEFT" >+ newSeek(consumerId: long, requestId: long, ledgerId: long, entryId: long, ackSet: long[]): ByteBuf</TD></TR>
<TR><TD ALIGN="LEFT" >+ newSeek(consumerId: long, requestId: long, timestamp: long): ByteBuf</TD></TR>
<TR><TD ALIGN="LEFT" >+ newSend(producerId: long, sequenceId: long, numMessaegs: int, checksumType: ChecksumType, messageMetadata: MessageMetadata, payload: ByteBuf): ByteBufPair</TD></TR>
<TR><TD ALIGN="LEFT" >+ newSend(producerId: long, lowestSequenceId: long, highestSequenceId: long, numMessaegs: int, checksumType: ChecksumType, messageMetadata: MessageMetadata, payload: ByteBuf): ByteBufPair</TD></TR>
<TR><TD ALIGN="LEFT" >+ newSend(producerId: long, sequenceId: long, highestSequenceId: long, numMessages: int, txnIdLeastBits: long, txnIdMostBits: long, checksumType: ChecksumType, messageData: MessageMetadata, payload: ByteBuf): ByteBufPair</TD></TR>
<TR><TD ALIGN="LEFT" >+ newSendError(producerId: long, sequenceId: long, error: ServerError, errorMsg: String): ByteBuf</TD></TR>
<TR><TD ALIGN="LEFT" >+ newSendErrorCommand(producerId: long, sequenceId: long, error: ServerError, errorMsg: String): BaseCommand</TD></TR>
<TR><TD ALIGN="LEFT" >+ newSendReceipt(producerId: long, sequenceId: long, highestId: long, ledgerId: long, entryId: long): ByteBuf</TD></TR>
<TR><TD ALIGN="LEFT" >+ newSendReceiptCommand(producerId: long, sequenceId: long, highestId: long, ledgerId: long, entryId: long): BaseCommand</TD></TR>
<TR><TD ALIGN="LEFT" >+ newSubscribe(topic: String, subscription: String, consumerId: long, requestId: long, subType: SubType, priorityLevel: int, consumerName: String, resetStartMessageBackInSeconds: long): ByteBuf</TD></TR>
<TR><TD ALIGN="LEFT" >+ newSubscribe(topic: String, subscription: String, consumerId: long, requestId: long, subType: SubType, priorityLevel: int, consumerName: String, isDurable: boolean, startMessageId: MessageIdData, metadata: Map&lt;String, String&gt;, readCompacted: boolean, isReplicated: boolean, subscriptionInitialPosition: InitialPosition, startMessageRollbackDurationInSec: long, schemaInfo: SchemaInfo, createTopicIfDoesNotExist: boolean): ByteBuf</TD></TR>
<TR><TD ALIGN="LEFT" >+ newSubscribe(topic: String, subscription: String, consumerId: long, requestId: long, subType: SubType, priorityLevel: int, consumerName: String, isDurable: boolean, startMessageId: MessageIdData, metadata: Map&lt;String, String&gt;, readCompacted: boolean, isReplicated: boolean, subscriptionInitialPosition: InitialPosition, startMessageRollbackDurationInSec: long, schemaInfo: SchemaInfo, createTopicIfDoesNotExist: boolean, keySharedPolicy: KeySharedPolicy, subscriptionProperties: Map&lt;String, String&gt;, consumerEpoch: long): ByteBuf</TD></TR>
<TR><TD ALIGN="LEFT" >+ newSuccess(requestId: long): ByteBuf</TD></TR>
<TR><TD ALIGN="LEFT" >+ newSuccessCommand(requestId: long): BaseCommand</TD></TR>
<TR><TD ALIGN="LEFT" >+ newTcClientConnectRequest(tcId: long, requestId: long): ByteBuf</TD></TR>
<TR><TD ALIGN="LEFT" >+ newTcClientConnectResponse(requestId: long, error: ServerError, message: String): BaseCommand</TD></TR>
<TR><TD ALIGN="LEFT" >+ newTxn(tcId: long, requestId: long, ttlSeconds: long): ByteBuf</TD></TR>
<TR><TD ALIGN="LEFT" >+ newTxnResponse(requestId: long, txnIdLeastBits: long, txnIdMostBits: long): ByteBuf</TD></TR>
<TR><TD ALIGN="LEFT" >+ newTxnResponse(requestId: long, txnIdMostBits: long, error: ServerError, errorMsg: String): ByteBuf</TD></TR>
<TR><TD ALIGN="LEFT" >+ newUnsubscribe(consumerId: long, requestId: long): ByteBuf</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseBrokerEntryMetadataIfExist(headerAndPayloadWithBrokerEntryMetadata: ByteBuf): BrokerEntryMetadata</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseMessageMetadata(buffer: ByteBuf): MessageMetadata</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseMessageMetadata(buffer: ByteBuf, msgMetadata: MessageMetadata)</TD></TR>
<TR><TD ALIGN="LEFT" >+ peekBrokerEntryMetadataIfExist(headerAndPayloadWithBrokerEntryMetadata: ByteBuf): BrokerEntryMetadata</TD></TR>
<TR><TD ALIGN="LEFT" >+ peekMessageMetadata(metadataAndPayload: ByteBuf, subscription: String, consumerId: long): MessageMetadata</TD></TR>
<TR><TD ALIGN="LEFT" >+ peekStickyKey(metadataAndPayload: ByteBuf, topic: String, subscription: String): byte[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ peerSupportJsonSchemaAvroFormat(peerVersion: int): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ peerSupportsAckReceipt(peerVersion: int): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ peerSupportsActiveConsumerListener(peerVersion: int): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ peerSupportsBrokerMetadata(peerVersion: int): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ peerSupportsGetLastMessageId(peerVersion: int): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ peerSupportsGetOrCreateSchema(peerVersion: int): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ peerSupportsMultiMessageAcknowledgment(peerVersion: int): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ readChecksum(buffer: ByteBuf): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ serializeCommandMessageWithSize(cmd: BaseCommand, metadataAndPayload: ByteBuf): ByteBufPair</TD></TR>
<TR><TD ALIGN="LEFT" >- serializeCommandSendWithSize(cmd: BaseCommand, checksumType: ChecksumType, msgMetadata: MessageMetadata, payload: ByteBuf): ByteBufPair</TD></TR>
<TR><TD ALIGN="LEFT" >+ serializeMetadataAndPayload(checksumType: ChecksumType, msgMetadata: MessageMetadata, payload: ByteBuf): ByteBuf</TD></TR>
<TR><TD ALIGN="LEFT" >+ serializeSingleMessageInBatchWithPayload(singleMessageMetadata: SingleMessageMetadata, payload: ByteBuf, batchBuffer: ByteBuf): ByteBuf</TD></TR>
<TR><TD ALIGN="LEFT" >+ serializeSingleMessageInBatchWithPayload(msg: MessageMetadata, payload: ByteBuf, batchBuffer: ByteBuf): ByteBuf</TD></TR>
<TR><TD ALIGN="LEFT" >+ serializeWithSize(cmd: BaseCommand): ByteBuf</TD></TR>
<TR><TD ALIGN="LEFT" >+ skipBrokerEntryMetadataIfExist(headerAndPayloadWithBrokerEntryMetadata: ByteBuf): ByteBuf</TD></TR>
<TR><TD ALIGN="LEFT" >+ skipChecksumIfPresent(buffer: ByteBuf)</TD></TR>
<TR><TD ALIGN="LEFT" >+ skipMessageMetadata(buffer: ByteBuf)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

CompactedTopicImpl435643328[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)CompactedTopicImpl</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   bk: BookKeeper [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   compactedTopicContext: CompletableFuture&lt;CompactedTopicContext&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   compactionHorizon: PositionImpl [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ asyncReadEntriesOrWait(cursor: ManagedCursor, numberOfEntriesToRead: int, isFirstRead: boolean, callback: ReadEntriesCallback, consumer: Consumer)</TD></TR>
<TR><TD ALIGN="LEFT" >- comparePositionAndMessageId(p: PositionImpl, m: MessageIdData): int</TD></TR>
<TR><TD ALIGN="LEFT" ># createCache(lh: LedgerHandle, maxSize: long): AsyncLoadingCache&lt;Long, MessageIdData&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ deleteCompactedLedger(compactedLedgerId: long): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># findStartPoint(p: PositionImpl, lastEntryId: long, cache: AsyncLoadingCache&lt;Long, MessageIdData&gt;): CompletableFuture&lt;Long&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- findStartPointLoop(p: PositionImpl, start: long, end: long, promise: CompletableFuture&lt;Long&gt;, cache: AsyncLoadingCache&lt;Long, MessageIdData&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ newCompactedLedger(p: Position, compactedLedgerId: long): CompletableFuture&lt;CompactedTopicContext&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- openCompactedLedger(bk: BookKeeper, id: long): CompletableFuture&lt;CompactedTopicContext&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- readEntries(lh: LedgerHandle, from: long, to: long): CompletableFuture&lt;List&lt;Entry&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ readLastEntryOfCompactedLedger(): CompletableFuture&lt;Entry&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- readOneMessageId(lh: LedgerHandle, entryId: long): CompletableFuture&lt;MessageIdData&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- tryDeleteCompactedLedger(bk: BookKeeper, id: long): CompletableFuture&lt;Void&gt;</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

CompactionRecord435643328[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)CompactionRecord</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   compactionDurationTimeInMills: LongAdder [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   compactionFailedCount: LongAdder [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   compactionRemovedEventCount: LongAdder [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   compactionSucceedCount: LongAdder [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   lastCompactionDurationTimeInMills: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   lastCompactionFailedTimestamp: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   lastCompactionRemovedEventCount: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   lastCompactionRemovedEventCountOp: LongAdder [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   lastCompactionStartTimeOp: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   lastCompactionSucceedTimestamp: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   readRate: Rate [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   writeLatencyStats: StatsBuckets [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   writeRate: Rate [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ addCompactionEndOp(succeed: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ addCompactionLatencyOp(latency: long, unit: TimeUnit)</TD></TR>
<TR><TD ALIGN="LEFT" >+ addCompactionReadOp(readableBytes: long)</TD></TR>
<TR><TD ALIGN="LEFT" >+ addCompactionRemovedEvent()</TD></TR>
<TR><TD ALIGN="LEFT" >+ addCompactionStartOp()</TD></TR>
<TR><TD ALIGN="LEFT" >+ addCompactionWriteOp(writeableBytes: long)</TD></TR>
<TR><TD ALIGN="LEFT" >+ reset()</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

CompactorMXBeanImpl435643328[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)CompactorMXBeanImpl</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   compactionRecordOps: ConcurrentHashMap&lt;String, CompactionRecord&gt; [0..*]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ addCompactionEndOp(topic: String, succeed: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ addCompactionLatencyOp(topic: String, latency: long, unit: TimeUnit)</TD></TR>
<TR><TD ALIGN="LEFT" >+ addCompactionReadOp(topic: String, readableBytes: long)</TD></TR>
<TR><TD ALIGN="LEFT" >+ addCompactionRemovedEvent(topic: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ addCompactionStartOp(topic: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ addCompactionWriteOp(topic: String, writeableBytes: long)</TD></TR>
<TR><TD ALIGN="LEFT" >+ getCompactionRecordForTopic(topic: String): Optional&lt;CompactionRecord&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ removeTopic(topic: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ reset()</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

CompactorSubscription1101090806[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)CompactorSubscription</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   compactedTopic: CompactedTopic [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ acknowledgeMessage(positions: List&lt;Position&gt;, ackType: AckType, properties: Map&lt;String, Long&gt;)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

CompletableFutureCancellationHandler1762718902[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)CompletableFutureCancellationHandler</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   attached: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   cancelAction: Runnable [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   cancelHandled: AtomicBoolean [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   completionStatus: CompletionStatus [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ attachToFuture(future: CompletableFuture&lt;?&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ createFuture(): CompletableFuture&lt;T&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- runCancelActionOnceIfCancelled()</TD></TR>
<TR><TD ALIGN="LEFT" >- whenCompleteFunction(): BiConsumer&lt;Object, ? super Throwable&gt;</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

CompressionCodecLZ4917667102[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)CompressionCodecLZ4</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ decode(encoded: ByteBuf, uncompressedLength: int): ByteBuf</TD></TR>
<TR><TD ALIGN="LEFT" >+ encode(source: ByteBuf): ByteBuf</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

CompressionCodecNone917667102[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)CompressionCodecNone</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ decode(encoded: ByteBuf, uncompressedSize: int): ByteBuf</TD></TR>
<TR><TD ALIGN="LEFT" >+ encode(raw: ByteBuf): ByteBuf</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

CompressionCodecProvider917667102[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)CompressionCodecProvider</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ convertFromWireProtocol(compressionType: CompressionType): CompressionType</TD></TR>
<TR><TD ALIGN="LEFT" >+ convertToWireProtocol(compressionType: CompressionType): CompressionType</TD></TR>
<TR><TD ALIGN="LEFT" >+ getCompressionCodec(type: CompressionType): CompressionCodec</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

CompressionCodecSnappy917667102[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)CompressionCodecSnappy</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ decode(encoded: ByteBuf, uncompressedLength: int): ByteBuf</TD></TR>
<TR><TD ALIGN="LEFT" >+ encode(source: ByteBuf): ByteBuf</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

CompressionCodecZLib917667102[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)CompressionCodecZLib</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   deflater: FastThreadLocal&lt;Deflater&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   inflater: FastThreadLocal&lt;Inflater&gt; [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ decode(encoded: ByteBuf, uncompressedLength: int): ByteBuf</TD></TR>
<TR><TD ALIGN="LEFT" >- deflate(deflater: Deflater, out: ByteBuf)</TD></TR>
<TR><TD ALIGN="LEFT" >+ encode(source: ByteBuf): ByteBuf</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

CompressionCodecZstd917667102[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)CompressionCodecZstd</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ decode(encoded: ByteBuf, uncompressedLength: int): ByteBuf</TD></TR>
<TR><TD ALIGN="LEFT" >+ encode(source: ByteBuf): ByteBuf</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

ConcurrentBitSet201476337[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)ConcurrentBitSet</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   rwLock: StampedLock [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># canEqual(other: Object): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ get(bitIndex: int): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ nextClearBit(fromIndex: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ nextSetBit(fromIndex: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ previousClearBit(fromIndex: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ previousSetBit(fromIndex: int): int</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

ConcurrentBitSetRecyclable201476337[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)ConcurrentBitSetRecyclable</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   recyclerHandle: Handle&lt;ConcurrentBitSetRecyclable&gt; [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># canEqual(other: Object): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ create(): ConcurrentBitSetRecyclable</TD></TR>
<TR><TD ALIGN="LEFT" >+ create(bitSet: BitSet): ConcurrentBitSetRecyclable</TD></TR>
<TR><TD ALIGN="LEFT" >+ recycle()</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

ConcurrentLongHashMap201476337[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)ConcurrentLongHashMap&lt;V&gt;</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   sections: Section&lt;V&gt;[] [0..*]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- alignToPowerOfTwo(n: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ capacity(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ clear()</TD></TR>
<TR><TD ALIGN="LEFT" >+ computeIfAbsent(key: long, provider: LongFunction&lt;V&gt;): V</TD></TR>
<TR><TD ALIGN="LEFT" >+ containsKey(key: long): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ forEach(processor: EntryProcessor&lt;V&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ get(key: long): V</TD></TR>
<TR><TD ALIGN="LEFT" >- getSection(hash: long): Section&lt;V&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># hash(key: long): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ keys(): List&lt;Long&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ put(key: long, value: V): V</TD></TR>
<TR><TD ALIGN="LEFT" >+ putIfAbsent(key: long, value: V): V</TD></TR>
<TR><TD ALIGN="LEFT" >+ remove(key: long): V</TD></TR>
<TR><TD ALIGN="LEFT" >+ remove(key: long, value: Object): boolean</TD></TR>
<TR><TD ALIGN="LEFT" ># signSafeMod(n: long, max: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ size(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ values(): List&lt;V&gt;</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

ConcurrentOpenHashMap201476337[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)ConcurrentOpenHashMap&lt;K, V&gt;</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   sections: Section&lt;K, V&gt;[] [0..*]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- alignToPowerOfTwo(n: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ capacity(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ clear()</TD></TR>
<TR><TD ALIGN="LEFT" >+ computeIfAbsent(key: K, provider: Function&lt;K, V&gt;): V</TD></TR>
<TR><TD ALIGN="LEFT" >+ containsKey(key: K): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ forEach(processor: BiConsumer&lt;? super K, ? super V&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ get(key: K): V</TD></TR>
<TR><TD ALIGN="LEFT" >- getSection(hash: long): Section&lt;K, V&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># hash(key: K): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ keys(): List&lt;K&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ put(key: K, value: V): V</TD></TR>
<TR><TD ALIGN="LEFT" >+ putIfAbsent(key: K, value: V): V</TD></TR>
<TR><TD ALIGN="LEFT" >+ remove(key: K): V</TD></TR>
<TR><TD ALIGN="LEFT" >+ remove(key: K, value: Object): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ removeNullValue(key: K)</TD></TR>
<TR><TD ALIGN="LEFT" ># signSafeMod(n: long, max: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ size(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ values(): List&lt;V&gt;</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

ConcurrentOpenHashSet201476337[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)ConcurrentOpenHashSet&lt;V&gt;</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   sections: Section&lt;V&gt;[] [0..*]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ add(value: V): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >- alignToPowerOfTwo(n: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ capacity(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ clear()</TD></TR>
<TR><TD ALIGN="LEFT" >+ contains(value: V): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ forEach(processor: Consumer&lt;? super V&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >- getSection(hash: long): Section&lt;V&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># hash(key: K): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ remove(value: V): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ removeIf(filter: Predicate&lt;V&gt;): int</TD></TR>
<TR><TD ALIGN="LEFT" ># signSafeMod(n: long, max: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ size(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ values(): List&lt;V&gt;</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

ConcurrentOpenLongPairRangeSet201476337[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)ConcurrentOpenLongPairRangeSet&lt;T extends Comparable&lt;T&gt;&gt;</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   bitSetSize: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   cachedSize: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   cachedToString: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   consumer: LongPairConsumer&lt;T&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   rangeBitSetMap: NavigableMap&lt;Long, BitSet&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   threadSafe: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   updatedAfterCachedForSize: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   updatedAfterCachedForToString: boolean [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ add(range: Range&lt;LongPair&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ addOpenClosed(lowerKey: long, lowerValueOpen: long, upperKey: long, upperValue: long)</TD></TR>
<TR><TD ALIGN="LEFT" >+ asRanges(): List&lt;Range&lt;T&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ clear()</TD></TR>
<TR><TD ALIGN="LEFT" >+ contains(key: long, value: long): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ contains(position: LongPair): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >- createNewBitSet(): BitSet</TD></TR>
<TR><TD ALIGN="LEFT" >+ firstRange(): Range&lt;T&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ forEach(action: RangeProcessor&lt;T&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ forEach(action: RangeProcessor&lt;T&gt;, consumer: LongPairConsumer&lt;? extends T&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >- getSafeEntry(position: LongPair): int</TD></TR>
<TR><TD ALIGN="LEFT" >- getSafeEntry(value: long): int</TD></TR>
<TR><TD ALIGN="LEFT" >- isValid(key: long, value: long): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ lastRange(): Range&lt;T&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ rangeContaining(key: long, value: long): Range&lt;T&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ remove(range: Range&lt;LongPair&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ removeAtMost(key: long, value: long)</TD></TR>
<TR><TD ALIGN="LEFT" >+ size(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ span(): Range&lt;T&gt;</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

ConfigurationDataUtils1053524534[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)ConfigurationDataUtils</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ create(): ObjectMapper</TD></TR>
<TR><TD ALIGN="LEFT" >+ loadData(config: Map&lt;String, Object&gt;, existingData: T, dataCls: Class&lt;T&gt;): T</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

ConnectionHandler12001400[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)ConnectionHandler</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   backoff: Backoff [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   clientCnx: ClientCnx [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   connection: Connection [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   epoch: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   lastConnectionClosedTimestamp: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   state: HandlerState [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ cnx(): ClientCnx</TD></TR>
<TR><TD ALIGN="LEFT" >+ connectionClosed(cnx: ClientCnx)</TD></TR>
<TR><TD ALIGN="LEFT" ># grabCnx()</TD></TR>
<TR><TD ALIGN="LEFT" >- handleConnectionError(exception: Throwable): Void</TD></TR>
<TR><TD ALIGN="LEFT" ># reconnectLater(exception: Throwable)</TD></TR>
<TR><TD ALIGN="LEFT" ># resetBackoff()</TD></TR>
<TR><TD ALIGN="LEFT" ># switchClientCnx(clientCnx: ClientCnx): long</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

ConnectionPool12001400[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)ConnectionPool</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   bootstrap: Bootstrap [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   channelInitializerHandler: PulsarChannelInitializer [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   clientConfig: ClientConfigurationData [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   dnsResolver: DnsNameResolver [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   eventLoopGroup: EventLoopGroup [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   isSniProxy: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   maxConnectionsPerHosts: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   pool: ConcurrentHashMap&lt;InetSocketAddress, ConcurrentMap&lt;Integer, CompletableFuture&lt;ClientCnx&gt;&gt;&gt; [0..*]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- cleanupConnection(address: InetSocketAddress, connectionKey: int, connectionFuture: CompletableFuture&lt;ClientCnx&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" ># closeAllConnections()</TD></TR>
<TR><TD ALIGN="LEFT" >- connectToAddress(ipAddress: InetAddress, port: int, sniHost: InetSocketAddress): CompletableFuture&lt;Channel&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- connectToResolvedAddresses(unresolvedAddresses: Iterator&lt;InetAddress&gt;, port: int, sniHost: InetSocketAddress): CompletableFuture&lt;Channel&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- createConnection(logicalAddress: InetSocketAddress, physicalAddress: InetSocketAddress, connectionKey: int): CompletableFuture&lt;ClientCnx&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- createConnection(unresolvedAddress: InetSocketAddress): CompletableFuture&lt;Channel&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getConnection(address: InetSocketAddress): CompletableFuture&lt;ClientCnx&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getConnection(logicalAddress: InetSocketAddress, physicalAddress: InetSocketAddress): CompletableFuture&lt;ClientCnx&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ releaseConnection(cnx: ClientCnx)</TD></TR>
<TR><TD ALIGN="LEFT" ># resolveName(hostname: String): CompletableFuture&lt;List&lt;InetAddress&gt;&gt;</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

Consumer1718290011[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)Consumer</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   appId: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   avgMessagesPerEntry: AtomicDouble [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   blockedConsumerOnUnackedMsgs: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   bytesOutCounter: LongAdder [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   chunkedMessageRate: Rate [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   clientAddress: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   cnx: TransportCnx [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   consumerEpoch: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   consumerId: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   consumerName: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   isAcknowledgmentAtBatchIndexLevelEnabled: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   isDurable: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   keySharedMeta: KeySharedMeta [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   lastAckedTimestamp: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   lastConsumedTimestamp: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   messagePermits: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   metadata: Map&lt;String, String&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   msgOut: Rate [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   msgOutCounter: LongAdder [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   msgRedeliver: Rate [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   negtiveUnackedMsgsTimestamp: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   partitionIdx: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   pendingAcks: ConcurrentLongLongPairHashMap [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   permitsReceivedWhileConsumerBlocked: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   preciseDispatcherFlowControl: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   priorityLevel: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   readCompacted: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   readPositionWhenJoining: PositionImpl [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   startMessageId: MessageId [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   stats: ConsumerStatsImpl [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   subType: SubType [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   subscription: Subscription [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   subscriptionInitialPosition: InitialPosition [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   topicName: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   unackedMessages: int [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- addAndGetUnAckedMsgs(consumer: Consumer, ackedMessages: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >- checkAckValidationError(ack: CommandAck, position: PositionImpl)</TD></TR>
<TR><TD ALIGN="LEFT" >- checkCanRemovePendingAcksAndHandle(position: PositionImpl, msgId: MessageIdData)</TD></TR>
<TR><TD ALIGN="LEFT" >+ checkPermissionsAsync(): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- clearUnAckedMsgs()</TD></TR>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ close(isResetCursor: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ cnx(): TransportCnx</TD></TR>
<TR><TD ALIGN="LEFT" >+ consumerId(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ consumerName(): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ disconnect()</TD></TR>
<TR><TD ALIGN="LEFT" >+ disconnect(isResetCursor: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ doUnsubscribe(requestId: long)</TD></TR>
<TR><TD ALIGN="LEFT" ># flowConsumerBlockedPermits(consumer: Consumer)</TD></TR>
<TR><TD ALIGN="LEFT" >+ flowPermits(additionalNumberOfMessages: int)</TD></TR>
<TR><TD ALIGN="LEFT" >- getAckOwnerConsumer(ledgerId: long, entryId: long): Consumer</TD></TR>
<TR><TD ALIGN="LEFT" >- getAckedCountForBatchIndexLevelEnabled(position: PositionImpl, batchSize: long, ackSets: long[]): long</TD></TR>
<TR><TD ALIGN="LEFT" >- getAckedCountForMsgIdNoAckSets(batchSize: long, position: PositionImpl): long</TD></TR>
<TR><TD ALIGN="LEFT" >- getAckedCountForTransactionAck(batchSize: long, ackSets: long[]): long</TD></TR>
<TR><TD ALIGN="LEFT" >- getBatchSize(msgId: MessageIdData): long</TD></TR>
<TR><TD ALIGN="LEFT" >- getCursorAckSet(position: PositionImpl): long[]</TD></TR>
<TR><TD ALIGN="LEFT" >- getStickyKeyHash(entry: Entry): int</TD></TR>
<TR><TD ALIGN="LEFT" >- getUnAckedCountForBatchIndexLevelEnabled(position: PositionImpl, batchSize: long): long</TD></TR>
<TR><TD ALIGN="LEFT" >- incrementUnackedMessages(ackedMessages: int)</TD></TR>
<TR><TD ALIGN="LEFT" >- individualAckNormal(ack: CommandAck, properties: Map&lt;String, Long&gt;): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- individualAckWithTransaction(ack: CommandAck): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ messageAcked(ack: CommandAck): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># notifyActiveConsumerChange(activeConsumer: Consumer)</TD></TR>
<TR><TD ALIGN="LEFT" >+ reachedEndOfTopic()</TD></TR>
<TR><TD ALIGN="LEFT" >+ readCompacted(): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ redeliverUnacknowledgedMessages(consumerEpoch: long)</TD></TR>
<TR><TD ALIGN="LEFT" >+ redeliverUnacknowledgedMessages(messageIds: List&lt;MessageIdData&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >- removePendingAcks(position: PositionImpl)</TD></TR>
<TR><TD ALIGN="LEFT" >+ sendMessages(entries: List&lt;Entry&gt;, batchSizes: EntryBatchSizes, batchIndexesAcks: EntryBatchIndexesAcks, totalMessages: int, totalBytes: long, totalChunkedMessages: long, redeliveryTracker: RedeliveryTracker): Future&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ sendMessages(entries: List&lt;Entry&gt;, batchSizes: EntryBatchSizes, batchIndexesAcks: EntryBatchIndexesAcks, totalMessages: int, totalBytes: long, totalChunkedMessages: long, redeliveryTracker: RedeliveryTracker, epoch: long): Future&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- shouldBlockConsumerOnUnackMsgs(): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ subType(): SubType</TD></TR>
<TR><TD ALIGN="LEFT" >- transactionCumulativeAcknowledge(txnidMostBits: long, txnidLeastBits: long, positionList: List&lt;PositionImpl&gt;): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- transactionIndividualAcknowledge(txnidMostBits: long, txnidLeastBits: long, positionList: List&lt;MutablePair&lt;PositionImpl, Integer&gt;&gt;): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ updateRates()</TD></TR>
<TR><TD ALIGN="LEFT" >+ updateStats(consumerStats: ConsumerStatsImpl)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

ConsumerAssignException1254029274[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)ConsumerAssignException</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

ConsumerBase12001400[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)ConsumerBase&lt;T&gt;</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   batchReceivePolicy: BatchReceivePolicy [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   batchReceiveTimeout: Timeout [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   conf: ConsumerConfigurationData&lt;T&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   consumerEpoch: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   consumerEventListener: ConsumerEventListener [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   consumerName: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   executorProvider: ExecutorProvider [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   externalPinnedExecutor: ScheduledExecutorService [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   incomingMessages: BlockingQueue&lt;Message&lt;T&gt;&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >#   incomingMessagesSize: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   interceptors: ConsumerInterceptors&lt;T&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   internalPinnedExecutor: ScheduledExecutorService [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   isListenerHandlingMessage: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   listener: MessageListener&lt;T&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   maxReceiverQueueSize: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   pendingBatchReceives: ConcurrentLinkedQueue&lt;OpBatchReceive&lt;T&gt;&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >#   pendingReceives: ConcurrentLinkedQueue&lt;CompletableFuture&lt;Message&lt;T&gt;&gt;&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >#   reentrantLock: Lock [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   schema: Schema&lt;T&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   subscribeFuture: CompletableFuture&lt;Consumer&lt;T&gt;&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   subscription: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   unAckedChunkedMessageIdSequenceMap: ConcurrentOpenHashMap&lt;MessageIdImpl, MessageIdImpl[]&gt; [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ acknowledge(message: Message&lt;?&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ acknowledge(messageId: MessageId)</TD></TR>
<TR><TD ALIGN="LEFT" >+ acknowledge(messageIdList: List&lt;MessageId&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ acknowledge(messages: Messages&lt;?&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ acknowledgeAsync(message: Message&lt;?&gt;): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ acknowledgeAsync(messages: Messages&lt;?&gt;): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ acknowledgeAsync(messageIdList: List&lt;MessageId&gt;): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ acknowledgeAsync(messageId: MessageId): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ acknowledgeAsync(messageId: MessageId, txn: Transaction): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ acknowledgeCumulative(message: Message&lt;?&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ acknowledgeCumulative(messageId: MessageId)</TD></TR>
<TR><TD ALIGN="LEFT" >+ acknowledgeCumulativeAsync(message: Message&lt;?&gt;): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ acknowledgeCumulativeAsync(messageId: MessageId): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ acknowledgeCumulativeAsync(messageId: MessageId, txn: Transaction): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ batchReceive(): Messages&lt;T&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ batchReceiveAsync(): CompletableFuture&lt;Messages&lt;T&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># beforeConsume(message: Message&lt;T&gt;): Message&lt;T&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># callMessageListener(msg: Message&lt;T&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" ># canEnqueueMessage(message: Message&lt;T&gt;): boolean</TD></TR>
<TR><TD ALIGN="LEFT" ># clearIncomingMessages()</TD></TR>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ closeAsync(): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># completeOpBatchReceive(op: OpBatchReceive&lt;T&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" ># completePendingBatchReceive(future: CompletableFuture&lt;Messages&lt;T&gt;&gt;, messages: Messages&lt;T&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" ># completePendingReceive(receivedFuture: CompletableFuture&lt;Message&lt;T&gt;&gt;, message: Message&lt;T&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" ># decreaseIncomingMessageSize(message: Message&lt;?&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" ># doAcknowledge(messageId: MessageId, ackType: AckType, properties: Map&lt;String, Long&gt;, txn: TransactionImpl): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># doAcknowledge(messageIdList: List&lt;MessageId&gt;, ackType: AckType, properties: Map&lt;String, Long&gt;, txn: TransactionImpl): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># doAcknowledgeWithTxn(messageIdList: List&lt;MessageId&gt;, ackType: AckType, properties: Map&lt;String, Long&gt;, txn: TransactionImpl): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># doAcknowledgeWithTxn(messageId: MessageId, ackType: AckType, properties: Map&lt;String, Long&gt;, txn: TransactionImpl): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- doPendingBatchReceiveTask(timeout: Timeout)</TD></TR>
<TR><TD ALIGN="LEFT" ># doReconsumeLater(message: Message&lt;?&gt;, ackType: AckType, customProperties: Map&lt;String, String&gt;, delayTime: long, unit: TimeUnit): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># enqueueMessageAndCheckBatchReceive(message: Message&lt;T&gt;): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >- failPendingBatchReceives()</TD></TR>
<TR><TD ALIGN="LEFT" ># failPendingReceive(): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- failPendingReceives()</TD></TR>
<TR><TD ALIGN="LEFT" >- getExternalExecutor(msg: Message&lt;T&gt;): ExecutorService</TD></TR>
<TR><TD ALIGN="LEFT" >- getInternalExecutor(msg: Message&lt;T&gt;): ExecutorService</TD></TR>
<TR><TD ALIGN="LEFT" ># internalBatchReceive(): Messages&lt;T&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># internalBatchReceiveAsync(): CompletableFuture&lt;Messages&lt;T&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># internalReceive(): Message&lt;T&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># internalReceive(timeout: int, unit: TimeUnit): Message&lt;T&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># internalReceiveAsync(): CompletableFuture&lt;Message&lt;T&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- isCumulativeAcknowledgementAllowed(type: SubscriptionType): boolean</TD></TR>
<TR><TD ALIGN="LEFT" ># isValidConsumerEpoch(message: MessageImpl&lt;T&gt;): boolean</TD></TR>
<TR><TD ALIGN="LEFT" ># messageProcessed(msg: Message&lt;?&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ negativeAcknowledge(message: Message&lt;?&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ negativeAcknowledge(messages: Messages&lt;?&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >- nextBatchReceive(): OpBatchReceive&lt;T&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># nextPendingReceive(): CompletableFuture&lt;Message&lt;T&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># notifyPendingBatchReceivedCallBack()</TD></TR>
<TR><TD ALIGN="LEFT" ># notifyPendingBatchReceivedCallBack(opBatchReceive: OpBatchReceive&lt;T&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ numMessagesInQueue(): int</TD></TR>
<TR><TD ALIGN="LEFT" ># onAckTimeoutSend(messageIds: Set&lt;MessageId&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" ># onAcknowledge(messageId: MessageId, exception: Throwable)</TD></TR>
<TR><TD ALIGN="LEFT" ># onAcknowledgeCumulative(messageId: MessageId, exception: Throwable)</TD></TR>
<TR><TD ALIGN="LEFT" ># onNegativeAcksSend(messageIds: Set&lt;MessageId&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" ># onPartitionsChange(topicName: String, partitions: int)</TD></TR>
<TR><TD ALIGN="LEFT" ># peekMessageKey(msg: Message&lt;T&gt;): byte[]</TD></TR>
<TR><TD ALIGN="LEFT" >- pendingBatchReceiveTask(timeout: Timeout)</TD></TR>
<TR><TD ALIGN="LEFT" >+ receive(): Message&lt;T&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ receive(timeout: int, unit: TimeUnit): Message&lt;T&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ receiveAsync(): CompletableFuture&lt;Message&lt;T&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ reconsumeLater(message: Message&lt;?&gt;, delayTime: long, unit: TimeUnit)</TD></TR>
<TR><TD ALIGN="LEFT" >+ reconsumeLater(message: Message&lt;?&gt;, customProperties: Map&lt;String, String&gt;, delayTime: long, unit: TimeUnit)</TD></TR>
<TR><TD ALIGN="LEFT" >+ reconsumeLater(messages: Messages&lt;?&gt;, delayTime: long, unit: TimeUnit)</TD></TR>
<TR><TD ALIGN="LEFT" >+ reconsumeLaterAsync(message: Message&lt;?&gt;, delayTime: long, unit: TimeUnit): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ reconsumeLaterAsync(message: Message&lt;?&gt;, customProperties: Map&lt;String, String&gt;, delayTime: long, unit: TimeUnit): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ reconsumeLaterAsync(messages: Messages&lt;?&gt;, delayTime: long, unit: TimeUnit): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ reconsumeLaterCumulative(message: Message&lt;?&gt;, delayTime: long, unit: TimeUnit)</TD></TR>
<TR><TD ALIGN="LEFT" >+ reconsumeLaterCumulativeAsync(message: Message&lt;?&gt;, delayTime: long, unit: TimeUnit): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ reconsumeLaterCumulativeAsync(message: Message&lt;?&gt;, customProperties: Map&lt;String, String&gt;, delayTime: long, unit: TimeUnit): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># redeliverUnacknowledgedMessages(messageIds: Set&lt;MessageId&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" ># resetIncomingMessageSize()</TD></TR>
<TR><TD ALIGN="LEFT" >+ subscribeFuture(): CompletableFuture&lt;Consumer&lt;T&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># triggerListener()</TD></TR>
<TR><TD ALIGN="LEFT" >+ unsubscribe()</TD></TR>
<TR><TD ALIGN="LEFT" >+ unsubscribeAsync(): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- validateMessageId(message: Message&lt;?&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >- validateMessageId(messageId: MessageId)</TD></TR>
<TR><TD ALIGN="LEFT" >- verifyBatchReceive()</TD></TR>
<TR><TD ALIGN="LEFT" >- verifyConsumerState()</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

ConsumerBusyException1254029274[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)ConsumerBusyException</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

ConsumerConfigurationData1053524534[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)ConsumerConfigurationData&lt;T&gt;</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   ackReceiptEnabled: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   ackTimeoutMillis: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   ackTimeoutRedeliveryBackoff: RedeliveryBackoff [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   acknowledgementsGroupTimeMicros: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   autoAckOldestChunkedMessageOnQueueFull: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   autoUpdatePartitions: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   autoUpdatePartitionsIntervalSeconds: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   batchIndexAckEnabled: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   batchReceivePolicy: BatchReceivePolicy [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   consumerEventListener: ConsumerEventListener [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   consumerName: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   cryptoFailureAction: ConsumerCryptoFailureAction [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   cryptoKeyReader: CryptoKeyReader [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   deadLetterPolicy: DeadLetterPolicy [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   expireTimeOfIncompleteChunkedMessageMillis: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   keySharedPolicy: KeySharedPolicy [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   maxPendingChunkedMessage: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   maxTotalReceiverQueueSizeAcrossPartitions: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   messageCrypto: MessageCrypto [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   messageListener: MessageListener&lt;T&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   negativeAckRedeliveryBackoff: RedeliveryBackoff [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   negativeAckRedeliveryDelayMicros: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   patternAutoDiscoveryPeriod: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   payloadProcessor: MessagePayloadProcessor [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   poolMessages: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   priorityLevel: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   properties: SortedMap&lt;String, String&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   readCompacted: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   receiverQueueSize: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   regexSubscriptionMode: RegexSubscriptionMode [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   replicateSubscriptionState: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   resetIncludeHead: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   retryEnable: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   startPaused: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   subscriptionInitialPosition: SubscriptionInitialPosition [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   subscriptionMode: SubscriptionMode [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   subscriptionName: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   subscriptionProperties: Map&lt;String, String&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   subscriptionType: SubscriptionType [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   tickDurationMillis: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   topicNames: Set&lt;String&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   topicsPattern: Pattern [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># canEqual(other: Object): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ clone(): ConsumerConfigurationData&lt;T&gt;</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

ConsumerHandler1308078636[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)ConsumerHandler</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   consumer: Consumer&lt;byte[]&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   maxPendingMessages: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   messageIdCache: Cache&lt;String, MessageId&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   msgDeliveredCounter: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   numBytesDelivered: LongAdder [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   numMsgsAcked: LongAdder [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   numMsgsDelivered: LongAdder [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   pendingMessages: AtomicInteger [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   pullMode: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   subscription: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   subscriptionMode: SubscriptionMode [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   subscriptionType: SubscriptionType [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- checkResumeReceive()</TD></TR>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ extractSubscription(request: HttpServletRequest): String</TD></TR>
<TR><TD ALIGN="LEFT" ># getConsumerConfiguration(client: PulsarClient): ConsumerBuilder&lt;byte[]&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- handleAck(command: ConsumerCommand)</TD></TR>
<TR><TD ALIGN="LEFT" >- handleEndOfTopic()</TD></TR>
<TR><TD ALIGN="LEFT" >- handleNack(command: ConsumerCommand)</TD></TR>
<TR><TD ALIGN="LEFT" >- handlePermit(command: ConsumerCommand)</TD></TR>
<TR><TD ALIGN="LEFT" >- handleUnsubscribe(command: ConsumerCommand)</TD></TR>
<TR><TD ALIGN="LEFT" ># isAuthorized(authRole: String, authenticationData: AuthenticationDataSource): Boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ onWebSocketConnect(session: Session)</TD></TR>
<TR><TD ALIGN="LEFT" >+ onWebSocketText(message: String)</TD></TR>
<TR><TD ALIGN="LEFT" >- receiveMessage()</TD></TR>
<TR><TD ALIGN="LEFT" ># updateDeliverMsgStat(msgSize: long)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

ConsumerImpl12001400[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)ConsumerImpl&lt;T&gt;</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   acknowledgmentsGroupingTracker: AcknowledgmentsGroupingTracker [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   autoAckOldestChunkedMessageOnQueueFull: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   availablePermits: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   chunkedMessagesMap: ConcurrentOpenHashMap&lt;String, ChunkedMessageCtx&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   clientCnxUsedForConsumerRegistration: AtomicReference&lt;ClientCnx&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   connectionHandler: ConnectionHandler [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   consumerId: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   createProducerLock: ReadWriteLock [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   createTopicIfDoesNotExist: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   deadLetterPolicy: DeadLetterPolicy [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   deadLetterProducer: CompletableFuture&lt;Producer&lt;byte[]&gt;&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   duringSeek: AtomicBoolean [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   expireChunkMessageTaskScheduled: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   expireTimeOfIncompleteChunkedMessageMillis: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   hasParentConsumer: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   hasReachedEndOfTopic: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   initialStartMessageId: BatchMessageIdImpl [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   lastDequeuedMessageId: MessageId [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   lastMessageIdInBroker: MessageId [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   lookupDeadline: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   maxPendingChunkedMessage: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   metadata: Map&lt;String, String&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   msgCrypto: MessageCrypto [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   negativeAcksTracker: NegativeAcksTracker [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   partitionIndex: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   paused: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   pendingChunkedMessageCount: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   pendingChunkedMessageUuidQueue: BlockingQueue&lt;String&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   poolMessages: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   possibleSendToDeadLetterTopicMessages: Map&lt;MessageIdImpl, List&lt;MessageImpl&lt;T&gt;&gt;&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   previousExceptions: List&lt;Throwable&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   priorityLevel: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   readCompacted: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   receiverQueueRefillThreshold: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   resetIncludeHead: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   retryLetterProducer: Producer&lt;T&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   seekMessageId: BatchMessageIdImpl [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   startMessageId: BatchMessageIdImpl [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   startMessageRollbackDurationInSec: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   stats: ConsumerStatsRecorder [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   subscribeDeadline: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   subscriptionInitialPosition: SubscriptionInitialPosition [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   subscriptionMode: SubscriptionMode [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   topicName: TopicName [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   topicNameWithoutPartition: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   unAckedMessageTracker: UnAckedMessageTracker [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># activeConsumerChanged(isActive: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >- cleanupAtClose(closeFuture: CompletableFuture&lt;Void&gt;, exception: Throwable)</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearIncomingMessagesAndGetMessageNumber(): int</TD></TR>
<TR><TD ALIGN="LEFT" >- clearReceiverQueue(): BatchMessageIdImpl</TD></TR>
<TR><TD ALIGN="LEFT" >+ closeAsync(): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- closeConsumerTasks()</TD></TR>
<TR><TD ALIGN="LEFT" ># cnx(): ClientCnx</TD></TR>
<TR><TD ALIGN="LEFT" ># completeOpBatchReceive(op: OpBatchReceive&lt;T&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >- completehasMessageAvailableWithValue(future: CompletableFuture&lt;Boolean&gt;, value: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" ># connectionClosed(cnx: ClientCnx)</TD></TR>
<TR><TD ALIGN="LEFT" >+ connectionFailed(exception: PulsarClientException)</TD></TR>
<TR><TD ALIGN="LEFT" >+ connectionOpened(cnx: ClientCnx)</TD></TR>
<TR><TD ALIGN="LEFT" ># consumerIsReconnectedToBroker(cnx: ClientCnx, currentQueueSize: int)</TD></TR>
<TR><TD ALIGN="LEFT" >- createEncryptionContext(msgMetadata: MessageMetadata): Optional&lt;EncryptionContext&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- decryptPayloadIfNeeded(messageId: MessageIdData, redeliveryCount: int, msgMetadata: MessageMetadata, payload: ByteBuf, currentCnx: ClientCnx): ByteBuf</TD></TR>
<TR><TD ALIGN="LEFT" ># deregisterFromClientCnx()</TD></TR>
<TR><TD ALIGN="LEFT" >- discardCorruptedMessage(messageId: MessageIdImpl, currentCnx: ClientCnx, validationError: ValidationError)</TD></TR>
<TR><TD ALIGN="LEFT" >- discardCorruptedMessage(messageId: MessageIdData, currentCnx: ClientCnx, validationError: ValidationError)</TD></TR>
<TR><TD ALIGN="LEFT" >- discardMessage(messageId: MessageIdData, currentCnx: ClientCnx, validationError: ValidationError)</TD></TR>
<TR><TD ALIGN="LEFT" ># doAcknowledge(messageId: MessageId, ackType: AckType, properties: Map&lt;String, Long&gt;, txn: TransactionImpl): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># doAcknowledge(messageIdList: List&lt;MessageId&gt;, ackType: AckType, properties: Map&lt;String, Long&gt;, txn: TransactionImpl): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># doReconsumeLater(message: Message&lt;?&gt;, ackType: AckType, customProperties: Map&lt;String, String&gt;, delayTime: long, unit: TimeUnit): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- doTransactionAcknowledgeForResponse(messageId: MessageId, ackType: AckType, validationError: ValidationError, properties: Map&lt;String, Long&gt;, txnID: TxnID): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- executeNotifyCallback(message: MessageImpl&lt;T&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >- getMessageIdImpl(msg: Message&lt;?&gt;): MessageIdImpl</TD></TR>
<TR><TD ALIGN="LEFT" >- getMessageImpl(message: Message&lt;?&gt;): MessageImpl&lt;?&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- getOriginMessageIdStr(message: Message&lt;?&gt;): String</TD></TR>
<TR><TD ALIGN="LEFT" >- getOriginTopicNameStr(message: Message&lt;?&gt;): String</TD></TR>
<TR><TD ALIGN="LEFT" >- getPropertiesMap(message: Message&lt;?&gt;, originMessageIdStr: String, originTopicNameStr: String): SortedMap&lt;String, String&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- getRedeliveryMessageIdData(messageIds: List&lt;MessageIdImpl&gt;): CompletableFuture&lt;List&lt;MessageIdData&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># grabCnx()</TD></TR>
<TR><TD ALIGN="LEFT" >- hasMoreMessages(lastMessageIdInBroker: MessageId, messageId: MessageId, inclusive: boolean): boolean</TD></TR>
<TR><TD ALIGN="LEFT" ># increaseAvailablePermits(currentCnx: ClientCnx)</TD></TR>
<TR><TD ALIGN="LEFT" ># increaseAvailablePermits(currentCnx: ClientCnx, delta: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ increaseAvailablePermits(delta: int)</TD></TR>
<TR><TD ALIGN="LEFT" >- initDeadLetterProducerIfNeeded()</TD></TR>
<TR><TD ALIGN="LEFT" >- interceptAndComplete(message: Message&lt;T&gt;, receivedFuture: CompletableFuture&lt;Message&lt;T&gt;&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" ># internalBatchReceive(): Messages&lt;T&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># internalBatchReceiveAsync(): CompletableFuture&lt;Messages&lt;T&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ internalGetLastMessageIdAsync(): CompletableFuture&lt;GetLastMessageIdResponse&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- internalGetLastMessageIdAsync(backoff: Backoff, remainingTime: AtomicLong, future: CompletableFuture&lt;GetLastMessageIdResponse&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" ># internalReceive(): Message&lt;T&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># internalReceive(timeout: int, unit: TimeUnit): Message&lt;T&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># internalReceiveAsync(): CompletableFuture&lt;Message&lt;T&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># isBatch(messageMetadata: MessageMetadata): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ isConnected(cnx: ClientCnx): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >- isMessageUndecryptable(msgMetadata: MessageMetadata): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >- isPriorBatchIndex(idx: long): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >- isPriorEntryIndex(idx: long): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >- isSameEntry(messageId: MessageIdImpl): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >- isValidConsumerEpoch(message: Message&lt;T&gt;): boolean</TD></TR>
<TR><TD ALIGN="LEFT" ># messageProcessed(msg: Message&lt;?&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" ># messageReceived(cmdMessage: CommandMessage, headersAndPayload: ByteBuf, cnx: ClientCnx)</TD></TR>
<TR><TD ALIGN="LEFT" >+ negativeAcknowledge(messageId: MessageId)</TD></TR>
<TR><TD ALIGN="LEFT" >+ negativeAcknowledge(message: Message&lt;?&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" ># newConsumerImpl(client: PulsarClientImpl, topic: String, conf: ConsumerConfigurationData&lt;T&gt;, executorProvider: ExecutorProvider, partitionIndex: int, hasParentConsumer: boolean, subscribeFuture: CompletableFuture&lt;Consumer&lt;T&gt;&gt;, startMessageId: MessageId, schema: Schema&lt;T&gt;, interceptors: ConsumerInterceptors&lt;T&gt;, createTopicIfDoesNotExist: boolean): ConsumerImpl&lt;T&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># newConsumerImpl(client: PulsarClientImpl, topic: String, conf: ConsumerConfigurationData&lt;T&gt;, executorProvider: ExecutorProvider, partitionIndex: int, hasParentConsumer: boolean, subscribeFuture: CompletableFuture&lt;Consumer&lt;T&gt;&gt;, startMessageId: MessageId, schema: Schema&lt;T&gt;, interceptors: ConsumerInterceptors&lt;T&gt;, createTopicIfDoesNotExist: boolean, startMessageRollbackDurationInSec: long): ConsumerImpl&lt;T&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># newMessage(messageId: MessageIdImpl, brokerEntryMetadata: BrokerEntryMetadata, messageMetadata: MessageMetadata, payload: ByteBuf, schema: Schema&lt;V&gt;, redeliveryCount: int, consumerEpoch: long): MessageImpl&lt;V&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># newSingleMessage(index: int, numMessages: int, brokerEntryMetadata: BrokerEntryMetadata, msgMetadata: MessageMetadata, singleMessageMetadata: SingleMessageMetadata, payload: ByteBuf, messageId: MessageIdImpl, schema: Schema&lt;V&gt;, containMetadata: boolean, ackBitSet: BitSetRecyclable, acker: BatchMessageAcker, redeliveryCount: int, consumerEpoch: long): MessageImpl&lt;V&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># notifyPendingReceivedCallback(message: Message&lt;T&gt;, exception: Exception)</TD></TR>
<TR><TD ALIGN="LEFT" >+ numMessagesInQueue(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ pause()</TD></TR>
<TR><TD ALIGN="LEFT" >- processMessageChunk(compressedPayload: ByteBuf, msgMetadata: MessageMetadata, msgId: MessageIdImpl, messageId: MessageIdData, cnx: ClientCnx): ByteBuf</TD></TR>
<TR><TD ALIGN="LEFT" >- processPayloadByProcessor(brokerEntryMetadata: BrokerEntryMetadata, messageMetadata: MessageMetadata, byteBuf: ByteBuf, messageId: MessageIdImpl, schema: Schema&lt;T&gt;, redeliveryCount: int, ackSet: List&lt;Long&gt;, consumerEpoch: long)</TD></TR>
<TR><TD ALIGN="LEFT" >- processPossibleToDLQ(messageId: MessageIdImpl): CompletableFuture&lt;Boolean&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># receiveIndividualMessagesFromBatch(brokerEntryMetadata: BrokerEntryMetadata, msgMetadata: MessageMetadata, redeliveryCount: int, ackSet: List&lt;Long&gt;, uncompressedPayload: ByteBuf, messageId: MessageIdData, cnx: ClientCnx, consumerEpoch: long)</TD></TR>
<TR><TD ALIGN="LEFT" ># reconnectLater(exception: Throwable)</TD></TR>
<TR><TD ALIGN="LEFT" >+ redeliverUnacknowledgedMessages()</TD></TR>
<TR><TD ALIGN="LEFT" >+ redeliverUnacknowledgedMessages(messageIds: Set&lt;MessageId&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >- removeChunkMessage(msgUUID: String, chunkedMsgCtx: ChunkedMessageCtx, autoAck: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" ># removeExpireIncompleteChunkedMessages()</TD></TR>
<TR><TD ALIGN="LEFT" >- removeExpiredMessagesFromQueue(messageIds: Set&lt;MessageId&gt;): int</TD></TR>
<TR><TD ALIGN="LEFT" >- removeOldestPendingChunkedMessage()</TD></TR>
<TR><TD ALIGN="LEFT" ># resetBackoff()</TD></TR>
<TR><TD ALIGN="LEFT" >+ resume()</TD></TR>
<TR><TD ALIGN="LEFT" >+ seek(messageId: MessageId)</TD></TR>
<TR><TD ALIGN="LEFT" >+ seek(timestamp: long)</TD></TR>
<TR><TD ALIGN="LEFT" >+ seek(function: Function&lt;String, Object&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ seekAsync(function: Function&lt;String, Object&gt;): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ seekAsync(timestamp: long): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ seekAsync(messageId: MessageId): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- seekAsyncCheckState(seekBy: String): Optional&lt;CompletableFuture&lt;Void&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- seekAsyncInternal(requestId: long, seek: ByteBuf, seekId: MessageId, seekBy: String): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- sendFlowPermitsToBroker(cnx: ClientCnx, numMessages: int)</TD></TR>
<TR><TD ALIGN="LEFT" ># trackMessage(msg: Message&lt;?&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" ># trackMessage(messageId: MessageId)</TD></TR>
<TR><TD ALIGN="LEFT" ># trackMessage(messageId: MessageId, redeliveryCount: int)</TD></TR>
<TR><TD ALIGN="LEFT" >- tryTriggerListener()</TD></TR>
<TR><TD ALIGN="LEFT" >- uncompressPayloadIfNeeded(messageId: MessageIdData, msgMetadata: MessageMetadata, payload: ByteBuf, currentCnx: ClientCnx, checkMaxMessageSize: boolean): ByteBuf</TD></TR>
<TR><TD ALIGN="LEFT" >+ unsubscribeAsync(): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- verifyChecksum(headersAndPayload: ByteBuf, messageId: MessageIdData): boolean</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

ConsumerStatsRecorderImpl12001400[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)ConsumerStatsRecorderImpl</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   consumer: Consumer&lt;?&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   numAcksFailed: LongAdder [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   numAcksSent: LongAdder [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   numBatchReceiveFailed: LongAdder [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   numBytesReceived: LongAdder [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   numMsgsReceived: LongAdder [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   numReceiveFailed: LongAdder [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   oldTime: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   pulsarClient: PulsarClientImpl [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   receivedBytesRate: double [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   receivedMsgsRate: double [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   stat: TimerTask [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   statTimeout: Timeout [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   statsIntervalSeconds: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   totalAcksFailed: LongAdder [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   totalAcksSent: LongAdder [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   totalBatchReceiveFailed: LongAdder [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   totalBytesReceived: LongAdder [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   totalMsgsReceived: LongAdder [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   totalReceiveFailed: LongAdder [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ incrementNumAcksFailed()</TD></TR>
<TR><TD ALIGN="LEFT" >+ incrementNumAcksSent(numAcks: long)</TD></TR>
<TR><TD ALIGN="LEFT" >+ incrementNumBatchReceiveFailed()</TD></TR>
<TR><TD ALIGN="LEFT" >+ incrementNumReceiveFailed()</TD></TR>
<TR><TD ALIGN="LEFT" >- init(conf: ConsumerConfigurationData&lt;?&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ reset()</TD></TR>
<TR><TD ALIGN="LEFT" >+ updateCumulativeStats(stats: ConsumerStats)</TD></TR>
<TR><TD ALIGN="LEFT" >+ updateNumMsgsReceived(message: Message&lt;?&gt;)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

ConsumerV1Impl1051373919[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)ConsumerV1Impl</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   consumer: Consumer&lt;byte[]&gt; [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ acknowledge(arg0: Message&lt;?&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ acknowledge(arg0: MessageId)</TD></TR>
<TR><TD ALIGN="LEFT" >+ acknowledgeAsync(arg0: Message&lt;?&gt;): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ acknowledgeAsync(arg0: MessageId): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ acknowledgeCumulative(arg0: Message&lt;?&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ acknowledgeCumulative(arg0: MessageId)</TD></TR>
<TR><TD ALIGN="LEFT" >+ acknowledgeCumulativeAsync(arg0: Message&lt;?&gt;): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ acknowledgeCumulativeAsync(arg0: MessageId): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ closeAsync(): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ pause()</TD></TR>
<TR><TD ALIGN="LEFT" >+ receive(): Message&lt;byte[]&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ receive(arg0: int, arg1: TimeUnit): Message&lt;byte[]&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ receiveAsync(): CompletableFuture&lt;Message&lt;byte[]&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ redeliverUnacknowledgedMessages()</TD></TR>
<TR><TD ALIGN="LEFT" >+ resume()</TD></TR>
<TR><TD ALIGN="LEFT" >+ seek(arg0: MessageId)</TD></TR>
<TR><TD ALIGN="LEFT" >+ seek(arg0: long)</TD></TR>
<TR><TD ALIGN="LEFT" >+ seek(function: Function&lt;String, Object&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ seekAsync(arg0: long): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ seekAsync(arg0: MessageId): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ seekAsync(function: Function&lt;String, Object&gt;): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ unsubscribe()</TD></TR>
<TR><TD ALIGN="LEFT" >+ unsubscribeAsync(): CompletableFuture&lt;Void&gt;</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

ContextImpl1550931773[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)ContextImpl</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   client: PulsarClient [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   clientBuilder: ClientBuilder [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   componentType: ComponentType [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   config: InstanceConfig [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   defaultStateStore: DefaultStateStore [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   exposePulsarAdminClientEnabled: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   inputConsumers: List&lt;Consumer&lt;?&gt;&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   logger: Logger [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   metricsLabels: String[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   producerBuilder: ProducerBuilderImpl&lt;?&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   publishProducers: Map&lt;String, Producer&lt;?&gt;&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   pulsarAdmin: PulsarAdmin [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   record: Record&lt;?&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   secretsMap: Map&lt;String, Object&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   secretsProvider: SecretsProvider [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   stateManager: StateManager [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   statsManager: ComponentStatsManager [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   subscriptionType: SubscriptionType [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   tlPublishProducers: ThreadLocal&lt;Map&lt;String, Producer&lt;?&gt;&gt;&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   topicConsumers: Map&lt;TopicName, Consumer&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   topicSchema: TopicSchema [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   userConfigs: Map&lt;String, Object&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >#   userMetricsLabels: Map&lt;String, String[]&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   userMetricsSummary: Summary [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ deleteState(key: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ deleteStateAsync(key: String): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- ensureStateEnabled()</TD></TR>
<TR><TD ALIGN="LEFT" ># getConsumer(topic: String, partition: int): Consumer&lt;?&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getCounter(key: String): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ getCounterAsync(key: String): CompletableFuture&lt;Long&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- getProducer(topicName: String, schema: Schema&lt;O&gt;): Producer&lt;O&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getSecret(secretName: String): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ getState(key: String): ByteBuffer</TD></TR>
<TR><TD ALIGN="LEFT" >+ getStateAsync(key: String): CompletableFuture&lt;ByteBuffer&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getStateStore(name: String): S</TD></TR>
<TR><TD ALIGN="LEFT" >+ getStateStore(tenant: String, ns: String, name: String): S</TD></TR>
<TR><TD ALIGN="LEFT" >+ getUserConfigValue(key: String): Optional&lt;Object&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getUserConfigValueOrDefault(key: String, defaultValue: Object): Object</TD></TR>
<TR><TD ALIGN="LEFT" >+ incrCounter(key: String, amount: long)</TD></TR>
<TR><TD ALIGN="LEFT" >+ incrCounterAsync(key: String, amount: long): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ newConsumerBuilder(schema: Schema&lt;O&gt;): ConsumerBuilder&lt;O&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ newOutputMessage(topicName: String, schema: Schema&lt;O&gt;): TypedMessageBuilder&lt;O&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ pause(topic: String, partition: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ publish(topicName: String, object: O): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ publish(topicName: String, object: O, schemaOrSerdeClassName: String): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ publish(topicName: String, object: O, schema: Schema&lt;O&gt;): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ putState(key: String, value: ByteBuffer)</TD></TR>
<TR><TD ALIGN="LEFT" >+ putStateAsync(key: String, value: ByteBuffer): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ recordMetric(metricName: String, value: double)</TD></TR>
<TR><TD ALIGN="LEFT" >- reloadConsumersFromMultiTopicsConsumers()</TD></TR>
<TR><TD ALIGN="LEFT" >+ resetMetrics()</TD></TR>
<TR><TD ALIGN="LEFT" >+ resume(topic: String, partition: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ seek(topic: String, partition: int, messageId: MessageId)</TD></TR>
<TR><TD ALIGN="LEFT" >- tryGetConsumer(topic: String, partition: int): Consumer&lt;?&gt;</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

ControlledClusterFailover12001400[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)ControlledClusterFailover</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   currentControlledConfiguration: ControlledConfiguration [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   currentPulsarServiceUrl: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   executor: ScheduledExecutorService [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   httpClient: AsyncHttpClient [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   interval: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   objectMapper: ObjectMapper [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   pulsarClient: PulsarClientImpl [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   requestBuilder: BoundRequestBuilder [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- buildHttpClient(): AsyncHttpClient</TD></TR>
<TR><TD ALIGN="LEFT" >+ builder(): ControlledClusterFailoverBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" ># fetchControlledConfiguration(): ControlledConfiguration</TD></TR>
<TR><TD ALIGN="LEFT" >+ initialize(client: PulsarClient)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

CoordinationServiceImpl1394915087[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)CoordinationServiceImpl</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   executor: ScheduledExecutorService [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   leaderElections: Map&lt;String, LeaderElection&lt;?&gt;&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   lockManagers: Map&lt;Object, LockManager&lt;?&gt;&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   store: MetadataStoreExtended [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ getLeaderElection(clazz: Class&lt;T&gt;, path: String, stateChangesListener: Consumer&lt;LeaderElectionState&gt;): LeaderElection&lt;T&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getLockManager(clazz: Class&lt;T&gt;): LockManager&lt;T&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getLockManager(serde: MetadataSerde&lt;T&gt;): LockManager&lt;T&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getNextCounterValue(path: String): CompletableFuture&lt;Long&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- incrementCounter(path: String): CompletableFuture&lt;Long&gt;</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

CursorDetails961700686[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)CursorDetails</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+   cursorBacklog: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   cursorLedgerId: long [1]</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

CustomBaseSerde82010421[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)CustomBaseSerde</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ deserialize(bytes: byte[]): CustomBaseObject</TD></TR>
<TR><TD ALIGN="LEFT" >+ serialize(object: CustomBaseObject): byte[]</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

CustomDerivedSerde82010421[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)CustomDerivedSerde</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ deserialize(bytes: byte[]): CustomDerivedObject</TD></TR>
<TR><TD ALIGN="LEFT" >+ serialize(object: CustomDerivedObject): byte[]</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

CustomObjectSerde1774045186[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)CustomObjectSerde</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ deserialize(bytes: byte[]): CustomObject</TD></TR>
<TR><TD ALIGN="LEFT" >+ serialize(object: CustomObject): byte[]</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

DataSketchesSummaryLogger1852472696[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)DataSketchesSummaryLogger</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   countAdder: LongAdder [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   current: ThreadLocalAccessor [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   replacement: ThreadLocalAccessor [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   sumAdder: LongAdder [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   values: DoublesSketch [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ getQuantileValue(quantile: double): double</TD></TR>
<TR><TD ALIGN="LEFT" >+ registerEvent(eventLatency: long, unit: TimeUnit)</TD></TR>
<TR><TD ALIGN="LEFT" >+ rotateLatencyCollection()</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

DateFormatter1762718902[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)DateFormatter</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ format(timestamp: long): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ format(instant: Instant): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ now(): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ parse(datetime: String): long</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

DateSchema1622012615[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)DateSchema</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ decode(bytes: byte[]): Date</TD></TR>
<TR><TD ALIGN="LEFT" >+ decode(byteBuf: ByteBuf): Date</TD></TR>
<TR><TD ALIGN="LEFT" >+ encode(message: Date): byte[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ of(): DateSchema</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

DefaultConnectionController1434559213[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)DefaultConnectionController</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   maxConnectionPerIp: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   maxConnections: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   maxConnectionsLimitEnabled: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   maxConnectionsLimitPerIpEnabled: boolean [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ decreaseConnection(remoteAddress: SocketAddress)</TD></TR>
<TR><TD ALIGN="LEFT" >+ increaseConnection(remoteAddress: SocketAddress): Sate</TD></TR>
<TR><TD ALIGN="LEFT" >- isLegalIpAddress(address: String): boolean</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

DefaultImplementation212457750[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)DefaultImplementation</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ newAdminClientBuilder(): PulsarAdminBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ newOffloadProcessStatus(status: Status, lastError: String, messageId: MessageId): OffloadProcessStatus</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

DefaultRangeSet623349000[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)DefaultRangeSet&lt;T extends Comparable&lt;T&gt;&gt;</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   consumer: LongPairConsumer&lt;T&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   set: RangeSet&lt;T&gt; [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ addOpenClosed(key1: long, value1: long, key2: long, value2: long)</TD></TR>
<TR><TD ALIGN="LEFT" >+ asRanges(): Set&lt;Range&lt;T&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ clear()</TD></TR>
<TR><TD ALIGN="LEFT" >+ contains(position: T): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ contains(key: long, value: long): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ firstRange(): Range&lt;T&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ forEach(action: RangeProcessor&lt;T&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ forEach(action: RangeProcessor&lt;T&gt;, consumer: LongPairConsumer&lt;? extends T&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ lastRange(): Range&lt;T&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ rangeContaining(position: T): Range&lt;T&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ rangeContaining(key: long, value: long): Range&lt;T&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ remove(range: Range&lt;T&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ removeAtMost(key: long, value: long)</TD></TR>
<TR><TD ALIGN="LEFT" >+ size(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ span(): Range&lt;T&gt;</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

DefaultSchemaRegistryService445450388[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)DefaultSchemaRegistryService</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ checkCompatible(schemaId: String, schema: SchemaData, strategy: SchemaCompatibilityStrategy): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ checkConsumerCompatibility(schemaId: String, schemaData: SchemaData, strategy: SchemaCompatibilityStrategy): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ deleteSchema(schemaId: String, user: String): CompletableFuture&lt;SchemaVersion&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ deleteSchemaStorage(schemaId: String): CompletableFuture&lt;SchemaVersion&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ deleteSchemaStorage(schemaId: String, forcefully: boolean): CompletableFuture&lt;SchemaVersion&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ findSchemaVersion(schemaId: String, schemaData: SchemaData): CompletableFuture&lt;Long&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getAllSchemas(schemaId: String): CompletableFuture&lt;List&lt;CompletableFuture&lt;SchemaAndMetadata&gt;&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getSchema(schemaId: String): CompletableFuture&lt;SchemaAndMetadata&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getSchema(schemaId: String, version: SchemaVersion): CompletableFuture&lt;SchemaAndMetadata&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getSchemaVersionBySchemaData(schemaAndMetadataList: List&lt;SchemaAndMetadata&gt;, schemaData: SchemaData): CompletableFuture&lt;SchemaVersion&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ isCompatible(schemaId: String, schema: SchemaData, strategy: SchemaCompatibilityStrategy): CompletableFuture&lt;Boolean&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ putSchemaIfAbsent(schemaId: String, schema: SchemaData, strategy: SchemaCompatibilityStrategy): CompletableFuture&lt;SchemaVersion&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ trimDeletedSchemaAndGetList(schemaId: String): CompletableFuture&lt;List&lt;SchemaAndMetadata&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ versionFromBytes(version: byte[]): SchemaVersion</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

DeferredSchemaPlaceholder843672203[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)DeferredSchemaPlaceholder</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

DelayedDeliveryPoliciesImpl1043561458[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)DelayedDeliveryPoliciesImpl</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   active: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   tickTime: long [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ builder(): DelayedDeliveryPoliciesImplBuilder</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

DelayedDeliveryPoliciesImplBuilder699932710[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)DelayedDeliveryPoliciesImplBuilder</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   active: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   tickTime: long [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ active(active: boolean): DelayedDeliveryPoliciesImplBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ build(): DelayedDeliveryPoliciesImpl</TD></TR>
<TR><TD ALIGN="LEFT" >+ tickTime(tickTime: long): DelayedDeliveryPoliciesImplBuilder</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

DirectProxyHandler79518146[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)DirectProxyHandler</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   authentication: Authentication [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   authenticationDataProvider: AuthenticationDataProvider [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   clientAuthData: AuthData [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   clientAuthMethod: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   inboundChannel: Channel [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   inboundChannelRequestsRate: Rate [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   onHandshakeCompleteAction: Runnable [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   originalPrincipal: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   outboundChannel: Channel [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   proxyConnection: ProxyConnection [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   service: ProxyService [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- encodeProxyProtocolMessage(msg: HAProxyMessage): ByteBuf</TD></TR>
<TR><TD ALIGN="LEFT" >- parseHost(brokerPortAndHost: String): String</TD></TR>
<TR><TD ALIGN="LEFT" >- writeHAProxyMessage()</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

DispatchRateImpl1043561458[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)DispatchRateImpl</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   dispatchThrottlingRateInByte: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   dispatchThrottlingRateInMsg: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   ratePeriodInSecond: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   relativeToPublishRate: boolean [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ builder(): DispatchRateImplBuilder</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

DispatchRateImplBuilder811351110[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)DispatchRateImplBuilder</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   dispatchThrottlingRateInByte: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   dispatchThrottlingRateInMsg: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   ratePeriodInSecond: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   relativeToPublishRate: boolean [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ build(): DispatchRateImpl</TD></TR>
<TR><TD ALIGN="LEFT" >+ dispatchThrottlingRateInByte(dispatchThrottlingRateInByte: long): DispatchRateImplBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ dispatchThrottlingRateInMsg(dispatchThrottlingRateInMsg: int): DispatchRateImplBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ ratePeriodInSecond(ratePeriodInSecond: int): DispatchRateImplBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ relativeToPublishRate(relativeToPublishRate: boolean): DispatchRateImplBuilder</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

DispatchRateLimiter1101090806[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)DispatchRateLimiter</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   brokerService: BrokerService [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   dispatchRateLimiterOnByte: RateLimiter [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   dispatchRateLimiterOnMessage: RateLimiter [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   topic: PersistentTopic [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   topicName: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   type: Type [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >- createDispatchRate(): DispatchRate</TD></TR>
<TR><TD ALIGN="LEFT" >+ getPolicies(brokerService: BrokerService, topicName: String): Optional&lt;Policies&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getPoliciesAsync(brokerService: BrokerService, topicName: String): CompletableFuture&lt;Optional&lt;Policies&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getPoliciesDispatchRate(cluster: String, policies: Optional&lt;Policies&gt;, type: Type): DispatchRateImpl</TD></TR>
<TR><TD ALIGN="LEFT" >+ getPoliciesDispatchRateAsync(brokerService: BrokerService): CompletableFuture&lt;Optional&lt;DispatchRate&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- getRelativeDispatchRateInByte(dispatchRate: DispatchRate): long</TD></TR>
<TR><TD ALIGN="LEFT" >- getRelativeDispatchRateInMsg(dispatchRate: DispatchRate): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ getTopicPolicyDispatchRate(brokerService: BrokerService, topicName: String, type: Type): Optional&lt;DispatchRate&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ isDispatchRateEnabled(dispatchRate: DispatchRate): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ isDispatchRateNeeded(brokerService: BrokerService, policies: Optional&lt;Policies&gt;, topicName: String, type: Type): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ isDispatchRateNeeded(serviceConfig: ServiceConfiguration, policies: Optional&lt;Policies&gt;, topicName: String, type: Type): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ onPoliciesUpdate(data: Policies)</TD></TR>
<TR><TD ALIGN="LEFT" >+ tryDispatchPermit(msgPermits: long, bytePermits: long): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ updateDispatchRate()</TD></TR>
<TR><TD ALIGN="LEFT" >+ updateDispatchRate(dispatchRate: DispatchRate)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

DistributedIdGenerator1718290011[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)DistributedIdGenerator</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   counter: AtomicLong [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   generatorInstanceId: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   prefix: String [0..1]</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

DoubleSchema1622012615[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)DoubleSchema</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ decode(bytes: byte[]): Double</TD></TR>
<TR><TD ALIGN="LEFT" >+ decode(byteBuf: ByteBuf): Double</TD></TR>
<TR><TD ALIGN="LEFT" >+ encode(message: Double): byte[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ of(): DoubleSchema</TD></TR>
<TR><TD ALIGN="LEFT" >+ validate(message: byte[])</TD></TR>
<TR><TD ALIGN="LEFT" >+ validate(message: ByteBuf)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

DynamicConfigurationResources220376139[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)DynamicConfigurationResources</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ isDynamicConfigurationPath(path: String): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ setDynamicConfigurationAsync(updateFunction: Function&lt;Map&lt;String, String&gt;, Map&lt;String, String&gt;&gt;): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ setDynamicConfigurationWithCreateAsync(createFunction: Function&lt;Optional&lt;Map&lt;String, String&gt;&gt;, Map&lt;String, String&gt;&gt;): CompletableFuture&lt;Void&gt;</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

EmptyVersion1472480913[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)EmptyVersion</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ bytes(): byte[]</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

EncryptionKeys297559756[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)EncryptionKeys</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   _bitField0: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _cachedSize: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _keyBufferIdx: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _keyBufferLen: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _metadatasCount: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _parsedBuffer: ByteBuf [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _valueIdx: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _valueLen: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   key: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   metadatas: List&lt;KeyValue&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   value: ByteBuf [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ addAllMetadatas(metadatas: Iterable&lt;KeyValue&gt;): EncryptionKeys</TD></TR>
<TR><TD ALIGN="LEFT" >+ addMetadata(): KeyValue</TD></TR>
<TR><TD ALIGN="LEFT" >- checkRequiredFields()</TD></TR>
<TR><TD ALIGN="LEFT" >+ clear(): EncryptionKeys</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearKey(): EncryptionKeys</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearMetadata(): EncryptionKeys</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearValue(): EncryptionKeys</TD></TR>
<TR><TD ALIGN="LEFT" >+ copyFrom(_other: EncryptionKeys): EncryptionKeys</TD></TR>
<TR><TD ALIGN="LEFT" >+ getMetadataAt(idx: int): KeyValue</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(_buffer: ByteBuf, _size: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(a: byte[])</TD></TR>
<TR><TD ALIGN="LEFT" >+ setKey(key: String): EncryptionKeys</TD></TR>
<TR><TD ALIGN="LEFT" >+ setValue(value: byte[]): EncryptionKeys</TD></TR>
<TR><TD ALIGN="LEFT" >+ setValue(value: ByteBuf): EncryptionKeys</TD></TR>
<TR><TD ALIGN="LEFT" >+ toByteArray(): byte[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeTo(_b: ByteBuf): int</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

EntryBatchIndexesAcks1718290011[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)EntryBatchIndexesAcks</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   handle: Handle&lt;EntryBatchIndexesAcks&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   indexesAcks: Pair&lt;Integer, long[]&gt;[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   size: int [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- ensureCapacityAndSetSize(entriesListSize: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ get(entriesListSize: int): EntryBatchIndexesAcks</TD></TR>
<TR><TD ALIGN="LEFT" >+ getAckSet(entryIdx: int): long[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ recycle()</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

EntryBatchSizes1718290011[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)EntryBatchSizes</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   handle: Handle&lt;EntryBatchSizes&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   sizes: int[] [0..*]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ get(entriesListSize: int): EntryBatchSizes</TD></TR>
<TR><TD ALIGN="LEFT" >+ getBatchSize(entryIdx: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ recyle()</TD></TR>
<TR><TD ALIGN="LEFT" >+ setBatchSize(entryIdx: int, batchSize: int): int</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

EntryFilterWithClassLoader368263718[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)EntryFilterWithClassLoader</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   classLoader: NarClassLoader [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   entryFilter: EntryFilter [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ filterEntry(entry: Entry, context: FilterContext): FilterResult</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

EventLoopUtil343630530[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)EventLoopUtil</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ enableTriggeredMode(bootstrap: ServerBootstrap)</TD></TR>
<TR><TD ALIGN="LEFT" >+ getClientSocketChannelClass(eventLoopGroup: EventLoopGroup): Class&lt;? extends SocketChannel&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getDatagramChannelClass(eventLoopGroup: EventLoopGroup): Class&lt;? extends DatagramChannel&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getServerSocketChannelClass(eventLoopGroup: EventLoopGroup): Class&lt;? extends ServerSocketChannel&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ newEventLoopGroup(nThreads: int, enableBusyWait: boolean, threadFactory: ThreadFactory): EventLoopGroup</TD></TR>
<TR><TD ALIGN="LEFT" >+ shutdownGracefully(eventLoopGroup: EventLoopGroup): CompletableFuture&lt;Void&gt;</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

EventsTopicNames2082884193[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)EventsTopicNames</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ checkTopicIsEventsNames(topicName: TopicName): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ checkTopicIsTransactionCoordinatorAssign(topicName: TopicName): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ isTopicPoliciesSystemTopic(topic: String): boolean</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

Exceptions2034047811[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)Exceptions</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ areExceptionsPresentInChain(error: Throwable, types: Class...): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ rethrowIOException(cause: Throwable)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

FailureDomainResources166830254[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)FailureDomainResources</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ deleteFailureDomain(clusterName: String, domainName: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ deleteFailureDomains(clusterName: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ getFailureDomain(clusterName: String, domainName: String): Optional&lt;FailureDomainImpl&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ listFailureDomains(clusterName: String): List&lt;String&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ registerListener(listener: Consumer&lt;Notification&gt;)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

FaultInjectionMetadataStore437280412[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)FaultInjectionMetadataStore</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   alwaysFail: AtomicReference&lt;MetadataStoreException&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   failures: CopyOnWriteArrayList&lt;Failure&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   sessionListeners: List&lt;Consumer&lt;SessionEvent&gt;&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   store: MetadataStoreExtended [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ delete(path: String, expectedVersion: Optional&lt;Long&gt;): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ deleteRecursive(path: String): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ exists(path: String): CompletableFuture&lt;Boolean&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ failConditional(ex: MetadataStoreException, predicate: BiPredicate&lt;OperationType, String&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ get(path: String): CompletableFuture&lt;Optional&lt;GetResult&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getChildren(path: String): CompletableFuture&lt;List&lt;String&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getMetadataCache(clazz: Class&lt;T&gt;): MetadataCache&lt;T&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getMetadataCache(typeRef: TypeReference&lt;T&gt;): MetadataCache&lt;T&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getMetadataCache(serde: MetadataSerde&lt;T&gt;): MetadataCache&lt;T&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- programmedFailure(op: OperationType, path: String): Optional&lt;MetadataStoreException&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ put(path: String, value: byte[], expectedVersion: Optional&lt;Long&gt;): CompletableFuture&lt;Stat&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ put(path: String, value: byte[], expectedVersion: Optional&lt;Long&gt;, options: EnumSet&lt;CreateOption&gt;): CompletableFuture&lt;Stat&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ registerListener(listener: Consumer&lt;Notification&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ registerSessionListener(listener: Consumer&lt;SessionEvent&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ triggerSessionEvent(event: SessionEvent)</TD></TR>
<TR><TD ALIGN="LEFT" >+ unsetAlwaysFail()</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

FeatureFlags297559756[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)FeatureFlags</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   _bitField0: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _cachedSize: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _parsedBuffer: ByteBuf [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   supportsAuthRefresh: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   supportsBrokerEntryMetadata: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   supportsPartialProducer: boolean [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ clear(): FeatureFlags</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearSupportsAuthRefresh(): FeatureFlags</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearSupportsBrokerEntryMetadata(): FeatureFlags</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearSupportsPartialProducer(): FeatureFlags</TD></TR>
<TR><TD ALIGN="LEFT" >+ copyFrom(_other: FeatureFlags): FeatureFlags</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(_buffer: ByteBuf, _size: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(a: byte[])</TD></TR>
<TR><TD ALIGN="LEFT" >+ setSupportsAuthRefresh(supportsAuthRefresh: boolean): FeatureFlags</TD></TR>
<TR><TD ALIGN="LEFT" >+ setSupportsBrokerEntryMetadata(supportsBrokerEntryMetadata: boolean): FeatureFlags</TD></TR>
<TR><TD ALIGN="LEFT" >+ setSupportsPartialProducer(supportsPartialProducer: boolean): FeatureFlags</TD></TR>
<TR><TD ALIGN="LEFT" >+ toByteArray(): byte[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeTo(_b: ByteBuf): int</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

FieldParser1762718902[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)FieldParser</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ booleanToString(value: Boolean): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ convert(from: Object, to: Class&lt;T&gt;): T</TD></TR>
<TR><TD ALIGN="LEFT" >- initConverters()</TD></TR>
<TR><TD ALIGN="LEFT" >- initWrappers()</TD></TR>
<TR><TD ALIGN="LEFT" >+ integerToString(value: Integer): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ stringToBoolean(value: String): Boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ stringToDouble(val: String): Double</TD></TR>
<TR><TD ALIGN="LEFT" >+ stringToFloat(val: String): Float</TD></TR>
<TR><TD ALIGN="LEFT" >+ stringToInteger(val: String): Integer</TD></TR>
<TR><TD ALIGN="LEFT" >+ stringToList(val: String, type: Class&lt;T&gt;): List&lt;T&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ stringToLong(val: String): Long</TD></TR>
<TR><TD ALIGN="LEFT" >- stringToMap(strValue: String, keyType: Class&lt;K&gt;, valueType: Class&lt;V&gt;): Map&lt;K, V&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ stringToSet(val: String, type: Class&lt;T&gt;): Set&lt;T&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- trim(val: String): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ update(properties: Map&lt;String, String&gt;, obj: T)</TD></TR>
<TR><TD ALIGN="LEFT" >+ value(strValue: String, field: Field): Object</TD></TR>
<TR><TD ALIGN="LEFT" >- wrap(type: Class&lt;?&gt;): Class&lt;?&gt;</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

FillEntryQueueCallback389689066[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)FillEntryQueueCallback</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   isReadable: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   outstandingReadsRequests: AtomicLong [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># fillQueue(): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ readEntriesComplete(entries: List&lt;Entry&gt;, ctx: Object)</TD></TR>
<TR><TD ALIGN="LEFT" >+ readEntriesFailed(exception: ManagedLedgerException, ctx: Object)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

FillEntryQueueCallback534259052[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)FillEntryQueueCallback</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   isReadable: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   outstandingReadsRequests: AtomicLong [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># fillQueue(): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ readEntriesComplete(entries: List&lt;Entry&gt;, ctx: Object)</TD></TR>
<TR><TD ALIGN="LEFT" >+ readEntriesFailed(exception: ManagedLedgerException, ctx: Object)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

FilterContext368263718[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)FilterContext</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   msgMetadata: MessageMetadata [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   subscription: Subscription [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># canEqual(other: Object): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ reset()</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

FloatSchema1622012615[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)FloatSchema</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ decode(bytes: byte[]): Float</TD></TR>
<TR><TD ALIGN="LEFT" >+ decode(byteBuf: ByteBuf): Float</TD></TR>
<TR><TD ALIGN="LEFT" >+ encode(message: Float): byte[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ of(): FloatSchema</TD></TR>
<TR><TD ALIGN="LEFT" >+ validate(message: byte[])</TD></TR>
<TR><TD ALIGN="LEFT" >+ validate(message: ByteBuf)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

FunctionAssignmentTailer1316119764[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)FunctionAssignmentTailer</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   errorNotifier: ErrorNotifier [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   exitFuture: CompletableFuture&lt;Void&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   exitOnEndOfTopic: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   functionRuntimeManager: FunctionRuntimeManager [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   isRunning: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   lastMessageId: MessageId [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   reader: Reader&lt;byte[]&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   readerBuilder: ReaderBuilder [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   tailerThread: Thread [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   workerConfig: WorkerConfig [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >- createReader(startMessageId: MessageId): Reader&lt;byte[]&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ start()</TD></TR>
<TR><TD ALIGN="LEFT" >+ startFromMessage(startMessageId: MessageId)</TD></TR>
<TR><TD ALIGN="LEFT" >+ triggerReadToTheEndAndExit(): CompletableFuture&lt;Void&gt;</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

FunctionMetaDataTopicTailer1316119764[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)FunctionMetaDataTopicTailer</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   errorNotifier: ErrorNotifier [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   exitFuture: CompletableFuture&lt;Void&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   exitOnEndOfTopic: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   functionMetaDataManager: FunctionMetaDataManager [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   isRunning: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   reader: Reader&lt;byte[]&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   tailerThread: Thread [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ createReader(workerConfig: WorkerConfig, readerBuilder: ReaderBuilder, startMessageId: MessageId): Reader</TD></TR>
<TR><TD ALIGN="LEFT" >+ run()</TD></TR>
<TR><TD ALIGN="LEFT" >+ start()</TD></TR>
<TR><TD ALIGN="LEFT" >+ stopWhenNoMoreMessages(): CompletableFuture&lt;Void&gt;</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

Functions620988779[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)Functions</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ deregisterFunction(tenant: String, namespace: String, functionName: String): Response</TD></TR>
<TR><TD ALIGN="LEFT" >+ downloadFunction(path: String): Response</TD></TR>
<TR><TD ALIGN="LEFT" ># functions(): FunctionsV2&lt;? extends WorkerService&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getFunctionInfo(tenant: String, namespace: String, functionName: String): Response</TD></TR>
<TR><TD ALIGN="LEFT" >+ getFunctionInstanceStatus(tenant: String, namespace: String, functionName: String, instanceId: String): Response</TD></TR>
<TR><TD ALIGN="LEFT" >+ getFunctionState(tenant: String, namespace: String, functionName: String, key: String): Response</TD></TR>
<TR><TD ALIGN="LEFT" >+ getFunctionStatus(tenant: String, namespace: String, functionName: String): Response</TD></TR>
<TR><TD ALIGN="LEFT" >+ listFunctions(tenant: String, namespace: String): Response</TD></TR>
<TR><TD ALIGN="LEFT" >+ registerFunction(tenant: String, namespace: String, functionName: String, uploadedInputStream: InputStream, fileDetail: FormDataContentDisposition, functionPkgUrl: String, functionDetailsJson: String): Response</TD></TR>
<TR><TD ALIGN="LEFT" >+ restartFunction(tenant: String, namespace: String, functionName: String, instanceId: String): Response</TD></TR>
<TR><TD ALIGN="LEFT" >+ restartFunction(tenant: String, namespace: String, functionName: String): Response</TD></TR>
<TR><TD ALIGN="LEFT" >+ stopFunction(tenant: String, namespace: String, functionName: String, instanceId: String): Response</TD></TR>
<TR><TD ALIGN="LEFT" >+ stopFunction(tenant: String, namespace: String, functionName: String): Response</TD></TR>
<TR><TD ALIGN="LEFT" >+ triggerFunction(tenant: String, namespace: String, functionName: String, triggerValue: String, triggerStream: InputStream, topic: String): Response</TD></TR>
<TR><TD ALIGN="LEFT" >+ updateFunction(tenant: String, namespace: String, functionName: String, uploadedInputStream: InputStream, fileDetail: FormDataContentDisposition, functionPkgUrl: String, functionDetailsJson: String): Response</TD></TR>
<TR><TD ALIGN="LEFT" >+ uploadFunction(uploadedInputStream: InputStream, path: String): Response</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

FunctionsBase229910521[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)FunctionsBase</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ deregisterFunction(tenant: String, namespace: String, functionName: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ downloadFunction(path: String): StreamingOutput</TD></TR>
<TR><TD ALIGN="LEFT" >+ downloadFunction(tenant: String, namespace: String, functionName: String): StreamingOutput</TD></TR>
<TR><TD ALIGN="LEFT" ># functions(): Functions&lt;? extends WorkerService&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getFunctionInfo(tenant: String, namespace: String, functionName: String): FunctionConfig</TD></TR>
<TR><TD ALIGN="LEFT" >+ getFunctionInstanceStats(tenant: String, namespace: String, functionName: String, instanceId: String): FunctionInstanceStatsDataImpl</TD></TR>
<TR><TD ALIGN="LEFT" >+ getFunctionInstanceStatus(tenant: String, namespace: String, functionName: String, instanceId: String): FunctionInstanceStatusData</TD></TR>
<TR><TD ALIGN="LEFT" >+ getFunctionState(tenant: String, namespace: String, functionName: String, key: String): FunctionState</TD></TR>
<TR><TD ALIGN="LEFT" >+ getFunctionStats(tenant: String, namespace: String, functionName: String): FunctionStatsImpl</TD></TR>
<TR><TD ALIGN="LEFT" >+ getFunctionStatus(tenant: String, namespace: String, functionName: String): FunctionStatus</TD></TR>
<TR><TD ALIGN="LEFT" >+ listFunctions(tenant: String, namespace: String): List&lt;String&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ putFunctionState(tenant: String, namespace: String, functionName: String, key: String, stateJson: FunctionState)</TD></TR>
<TR><TD ALIGN="LEFT" >+ registerFunction(tenant: String, namespace: String, functionName: String, uploadedInputStream: InputStream, fileDetail: FormDataContentDisposition, functionPkgUrl: String, functionConfig: FunctionConfig)</TD></TR>
<TR><TD ALIGN="LEFT" >+ restartFunction(tenant: String, namespace: String, functionName: String, instanceId: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ restartFunction(tenant: String, namespace: String, functionName: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ startFunction(tenant: String, namespace: String, functionName: String, instanceId: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ startFunction(tenant: String, namespace: String, functionName: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ stopFunction(tenant: String, namespace: String, functionName: String, instanceId: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ stopFunction(tenant: String, namespace: String, functionName: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ triggerFunction(tenant: String, namespace: String, functionName: String, triggerValue: String, triggerStream: InputStream, topic: String): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ updateFunction(tenant: String, namespace: String, functionName: String, uploadedInputStream: InputStream, fileDetail: FormDataContentDisposition, functionPkgUrl: String, functionConfig: FunctionConfig, updateOptions: UpdateOptionsImpl)</TD></TR>
<TR><TD ALIGN="LEFT" >+ updateFunctionOnWorkerLeader(tenant: String, namespace: String, functionName: String, uploadedInputStream: InputStream, delete: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ uploadFunction(uploadedInputStream: InputStream, path: String)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

FutureUtil1762718902[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)FutureUtil</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ addTimeoutHandling(future: CompletableFuture&lt;T&gt;, timeout: Duration, executor: ScheduledExecutorService, exceptionSupplier: Supplier&lt;Throwable&gt;): CompletableFuture&lt;T&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ createFutureWithTimeout(timeout: Duration, executor: ScheduledExecutorService, exceptionSupplier: Supplier&lt;Throwable&gt;): CompletableFuture&lt;T&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ createTimeoutException(message: String, sourceClass: Class&lt;?&gt;, sourceMethod: String): TimeoutException</TD></TR>
<TR><TD ALIGN="LEFT" >+ failedFuture(t: Throwable): CompletableFuture&lt;T&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getException(future: CompletableFuture&lt;T&gt;): Optional&lt;Throwable&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ unwrapCompletionException(ex: Throwable): Throwable</TD></TR>
<TR><TD ALIGN="LEFT" >+ waitForAll(futures: List&lt;? extends CompletableFuture&lt;?&gt;&gt;): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ waitForAllAndSupportCancel(futures: List&lt;? extends CompletableFuture&lt;?&gt;&gt;): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ waitForAny(futures: List&lt;? extends CompletableFuture&lt;?&gt;&gt;): CompletableFuture&lt;Object&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ whenCancelledOrTimedOut(future: CompletableFuture&lt;?&gt;, cancelAction: Runnable)</TD></TR>
<TR><TD ALIGN="LEFT" >+ wrapToCompletionException(throwable: Throwable): CompletionException</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

GenericAvroReader75672144[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)GenericAvroReader</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   byteArrayOutputStream: ByteArrayOutputStream [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   encoder: BinaryEncoder [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   fields: List&lt;Field&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   offset: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   reader: GenericDatumReader&lt;GenericAvroRecord&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   schema: Schema [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   schemaVersion: byte[] [0..*]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ read(bytes: byte[], offset: int, length: int): GenericAvroRecord</TD></TR>
<TR><TD ALIGN="LEFT" >+ read(inputStream: InputStream): GenericRecord</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

GenericAvroSchema75672144[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)GenericAvroSchema</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ clone(): Schema&lt;GenericRecord&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ newRecordBuilder(): GenericRecordBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ supportSchemaVersioning(): boolean</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

GenericAvroWriter75672144[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)GenericAvroWriter</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   byteArrayOutputStream: ByteArrayOutputStream [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   encoder: BinaryEncoder [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   writer: GenericDatumWriter&lt;GenericRecord&gt; [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ write(message: GenericRecord): byte[]</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

GenericBrokerHostUsageImpl109292786[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)GenericBrokerHostUsageImpl</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   cpuUsageCount: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   cpuUsageSum: double [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   systemBean: OperatingSystemMXBean [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   totalCpuLimit: double [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   usage: SystemResourceUsage [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ calculateBrokerHostUsage()</TD></TR>
<TR><TD ALIGN="LEFT" >- checkCpuLoad()</TD></TR>
<TR><TD ALIGN="LEFT" ># doCalculateBrokerHostUsage()</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

GenericJsonReader75672144[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)GenericJsonReader</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   fields: List&lt;Field&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   objectMapper: ObjectMapper [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   schemaInfo: SchemaInfo [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   schemaVersion: byte[] [0..*]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ read(bytes: byte[], offset: int, length: int): GenericJsonRecord</TD></TR>
<TR><TD ALIGN="LEFT" >+ read(inputStream: InputStream): GenericRecord</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

GenericJsonSchema75672144[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)GenericJsonSchema</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ clone(): Schema&lt;GenericRecord&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ newRecordBuilder(): GenericRecordBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ supportSchemaVersioning(): boolean</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

GenericJsonWriter75672144[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)GenericJsonWriter</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   objectMapper: ObjectMapper [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ write(message: GenericRecord): byte[]</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

GenericProtobufNativeReader75672144[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)GenericProtobufNativeReader</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   descriptor: Descriptor [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   fields: List&lt;Field&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   schemaVersion: byte[] [0..*]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ read(bytes: byte[], offset: int, length: int): GenericProtobufNativeRecord</TD></TR>
<TR><TD ALIGN="LEFT" >+ read(inputStream: InputStream): GenericProtobufNativeRecord</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

GenericProtobufNativeSchema75672144[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)GenericProtobufNativeSchema</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   descriptor: Descriptor [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ newRecordBuilder(): GenericRecordBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ of(schemaInfo: SchemaInfo): GenericSchema</TD></TR>
<TR><TD ALIGN="LEFT" >+ of(schemaInfo: SchemaInfo, useProvidedSchemaAsReaderSchema: boolean): GenericSchema</TD></TR>
<TR><TD ALIGN="LEFT" >+ supportSchemaVersioning(): boolean</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

GenericProtobufNativeWriter75672144[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)GenericProtobufNativeWriter</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ write(message: GenericRecord): byte[]</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

GenericSchemaImpl75672144[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)GenericSchemaImpl</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   fields: List&lt;Field&gt; [0..*]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ of(schemaInfo: SchemaInfo): GenericSchemaImpl</TD></TR>
<TR><TD ALIGN="LEFT" >+ of(schemaInfo: SchemaInfo, useProvidedSchemaAsReaderSchema: boolean): GenericSchemaImpl</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

GracefulExecutorServicesShutdown1718290011[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)GracefulExecutorServicesShutdown</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   executorServices: List&lt;ExecutorService&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   terminationTimeout: Duration [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   timeout: Duration [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ handle(): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ initiate(): GracefulExecutorServicesShutdown</TD></TR>
<TR><TD ALIGN="LEFT" >+ shutdown(executorServices: ExecutorService...): GracefulExecutorServicesShutdown</TD></TR>
<TR><TD ALIGN="LEFT" >+ terminationTimeout(terminationTimeout: Duration): GracefulExecutorServicesShutdown</TD></TR>
<TR><TD ALIGN="LEFT" >+ timeout(timeout: Duration): GracefulExecutorServicesShutdown</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

HandlerState12001400[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)HandlerState</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   client: PulsarClientImpl [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   state: State [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   topic: String [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># changeToConnecting(): boolean</TD></TR>
<TR><TD ALIGN="LEFT" ># changeToReadyState(): boolean</TD></TR>
<TR><TD ALIGN="LEFT" ># changeToRegisteringSchemaState(): boolean</TD></TR>
<TR><TD ALIGN="LEFT" ># getAndUpdateState(updater: UnaryOperator&lt;State&gt;): State</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

InMemTransactionBuffer1621168036[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)InMemTransactionBuffer</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   buffers: ConcurrentMap&lt;TxnID, TxnBuffer&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >#   txnIndex: Map&lt;Long, Set&lt;TxnID&gt;&gt; [0..*]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ abortTxn(txnID: TxnID, lowWaterMark: long): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- addTxnToTxnIdex(txnId: TxnID, committedAtLedgerId: long)</TD></TR>
<TR><TD ALIGN="LEFT" >+ appendBufferToTxn(txnId: TxnID, sequenceId: long, buffer: ByteBuf): CompletableFuture&lt;Position&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ checkIfTBRecoverCompletely(isTxn: boolean): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearSnapshot(): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ closeAsync(): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ commitTxn(txnID: TxnID, lowWaterMark: long): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getTransactionInBufferStats(txnID: TxnID): TransactionInBufferStats</TD></TR>
<TR><TD ALIGN="LEFT" >+ getTransactionMeta(txnID: TxnID): CompletableFuture&lt;TransactionMeta&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- getTxnBufferOrCreateIfNotExist(txnID: TxnID): TxnBuffer</TD></TR>
<TR><TD ALIGN="LEFT" >- getTxnBufferOrThrowNotFoundException(txnID: TxnID): TxnBuffer</TD></TR>
<TR><TD ALIGN="LEFT" >+ isTxnAborted(txnID: TxnID): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ openTransactionBufferReader(txnID: TxnID, startSequenceId: long): CompletableFuture&lt;TransactionBufferReader&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ purgeTxns(dataLedgers: List&lt;Long&gt;): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ syncMaxReadPositionForNormalPublish(position: PositionImpl)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

InMemTransactionMetadataStore1462729559[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)InMemTransactionMetadataStore</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   abortTransactionCount: LongAdder [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   commitTransactionCount: LongAdder [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   createTransactionCount: LongAdder [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   localID: AtomicLong [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   tcID: TransactionCoordinatorID [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   transactionMetadataStoreStats: TransactionMetadataStoreStats [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   transactionTimeoutCount: LongAdder [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   transactions: ConcurrentMap&lt;TxnID, TxnMetaImpl&gt; [0..*]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ addAckedPartitionToTxn(txnid: TxnID, partitions: List&lt;TransactionSubscription&gt;): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ addProducedPartitionToTxn(txnid: TxnID, partitions: List&lt;String&gt;): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ closeAsync(): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getSlowTransactions(timeout: long): List&lt;TxnMeta&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getTxnMeta(txnid: TxnID): CompletableFuture&lt;TxnMeta&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ newTransaction(timeoutInMills: long): CompletableFuture&lt;TxnID&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ updateTxnStatus(txnid: TxnID, newStatus: TxnStatus, expectedStatus: TxnStatus, isTimeout: boolean): CompletableFuture&lt;Void&gt;</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

InMemTransactionMetadataStoreProvider1462729559[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)InMemTransactionMetadataStoreProvider</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ openStore(transactionCoordinatorId: TransactionCoordinatorID, managedLedgerFactory: ManagedLedgerFactory, managedLedgerConfig: ManagedLedgerConfig, timeoutTracker: TransactionTimeoutTracker, recoverTracker: TransactionRecoverTracker): CompletableFuture&lt;TransactionMetadataStore&gt;</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

InMemoryDelayedDeliveryTracker1284485384[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)InMemoryDelayedDeliveryTracker</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   clock: Clock [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   currentTimeoutTarget: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   dispatcher: PersistentDispatcherMultipleConsumers [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   priorityQueue: TripleLongPriorityQueue [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   tickTimeMillis: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   timeout: Timeout [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   timer: Timer [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ addMessage(ledgerId: long, entryId: long, deliveryAt: long): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ clear()</TD></TR>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ getScheduledMessages(maxMessages: int): Set&lt;PositionImpl&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ resetTickTime(tickTime: long)</TD></TR>
<TR><TD ALIGN="LEFT" >+ run(timeout: Timeout)</TD></TR>
<TR><TD ALIGN="LEFT" >- updateTimer()</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

InMemoryDelayedDeliveryTrackerFactory1284485384[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)InMemoryDelayedDeliveryTrackerFactory</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   tickTimeMillis: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   timer: Timer [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ initialize(config: ServiceConfiguration)</TD></TR>
<TR><TD ALIGN="LEFT" >+ newTracker(dispatcher: PersistentDispatcherMultipleConsumers): DelayedDeliveryTracker</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

InMemoryRedeliveryTracker1718290011[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)InMemoryRedeliveryTracker</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   trackerCache: ConcurrentLongLongPairHashMap [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ addIfAbsent(position: Position)</TD></TR>
<TR><TD ALIGN="LEFT" >+ clear()</TD></TR>
<TR><TD ALIGN="LEFT" >+ contains(position: Position): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ getRedeliveryCount(position: Position): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ incrementAndGetRedeliveryCount(position: Position): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ remove(position: Position)</TD></TR>
<TR><TD ALIGN="LEFT" >+ removeBatch(positions: List&lt;Position&gt;)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

IncompatibleSchemaException770960286[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)IncompatibleSchemaException</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

IndexEntry840873545[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)IndexEntry</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   bitField0_: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   hash_: ByteString [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   memoizedIsInitialized: byte [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   position_: PositionInfo [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   version_: long [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># internalGetFieldAccessorTable(): FieldAccessorTable</TD></TR>
<TR><TD ALIGN="LEFT" >+ newBuilder(): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ newBuilder(prototype: IndexEntry): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ newBuilderForType(): Builder</TD></TR>
<TR><TD ALIGN="LEFT" ># newBuilderForType(parent: BuilderParent): Builder</TD></TR>
<TR><TD ALIGN="LEFT" ># newInstance(unused: UnusedPrivateParameter): Object</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseDelimitedFrom(input: InputStream): IndexEntry</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseDelimitedFrom(input: InputStream, extensionRegistry: ExtensionRegistryLite): IndexEntry</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(data: ByteBuffer): IndexEntry</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(data: ByteBuffer, extensionRegistry: ExtensionRegistryLite): IndexEntry</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(data: ByteString): IndexEntry</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(data: ByteString, extensionRegistry: ExtensionRegistryLite): IndexEntry</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(data: byte[]): IndexEntry</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(data: byte[], extensionRegistry: ExtensionRegistryLite): IndexEntry</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(input: InputStream): IndexEntry</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(input: InputStream, extensionRegistry: ExtensionRegistryLite): IndexEntry</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(input: CodedInputStream): IndexEntry</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(input: CodedInputStream, extensionRegistry: ExtensionRegistryLite): IndexEntry</TD></TR>
<TR><TD ALIGN="LEFT" >+ parser(): Parser&lt;IndexEntry&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ toBuilder(): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeTo(output: CodedOutputStream)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

InetAddressUtils1605704883[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)InetAddressUtils</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ isIPv4Address(input: String): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ isIPv4MappedIPv64Address(input: String): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ isIPv6Address(input: String): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ isIPv6HexCompressedAddress(input: String): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ isIPv6StdAddress(input: String): boolean</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

InstantSchema1622012615[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)InstantSchema</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ decode(bytes: byte[]): Instant</TD></TR>
<TR><TD ALIGN="LEFT" >+ decode(byteBuf: ByteBuf): Instant</TD></TR>
<TR><TD ALIGN="LEFT" >+ encode(message: Instant): byte[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ of(): InstantSchema</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

IntRange297559756[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)IntRange</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   _bitField0: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _cachedSize: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _parsedBuffer: ByteBuf [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   end: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   start: int [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- checkRequiredFields()</TD></TR>
<TR><TD ALIGN="LEFT" >+ clear(): IntRange</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearEnd(): IntRange</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearStart(): IntRange</TD></TR>
<TR><TD ALIGN="LEFT" >+ copyFrom(_other: IntRange): IntRange</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(_buffer: ByteBuf, _size: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(a: byte[])</TD></TR>
<TR><TD ALIGN="LEFT" >+ setEnd(end: int): IntRange</TD></TR>
<TR><TD ALIGN="LEFT" >+ setStart(start: int): IntRange</TD></TR>
<TR><TD ALIGN="LEFT" >+ toByteArray(): byte[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeTo(_b: ByteBuf): int</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

IntSchema1622012615[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)IntSchema</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ decode(bytes: byte[]): Integer</TD></TR>
<TR><TD ALIGN="LEFT" >+ decode(byteBuf: ByteBuf): Integer</TD></TR>
<TR><TD ALIGN="LEFT" >+ encode(message: Integer): byte[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ of(): IntSchema</TD></TR>
<TR><TD ALIGN="LEFT" >+ validate(message: byte[])</TD></TR>
<TR><TD ALIGN="LEFT" >+ validate(message: ByteBuf)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

InvalidSchemaDataException770960286[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)InvalidSchemaDataException</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

IsolationPolicyResources2098679213[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)IsolationPolicyResources</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ createIsolationData(cluster: String, id: Map&lt;String, NamespaceIsolationDataImpl&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ deleteIsolationData(cluster: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ getIsolationDataPolicies(cluster: String): Optional&lt;NamespaceIsolationPolicies&gt;</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

JSONSchema1622012615[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)JSONSchema&lt;T&gt;</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   pojo: Class&lt;T&gt; [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ of(schemaDefinition: SchemaDefinition&lt;T&gt;): JSONSchema&lt;T&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ of(pojo: Class&lt;T&gt;): JSONSchema&lt;T&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ of(pojo: Class&lt;T&gt;, properties: Map&lt;String, String&gt;): JSONSchema&lt;T&gt;</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

JacksonJsonReader657740342[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)JacksonJsonReader&lt;T&gt;</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   objectMapper: ObjectMapper [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   pojo: Class&lt;T&gt; [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ read(bytes: byte[], offset: int, length: int): T</TD></TR>
<TR><TD ALIGN="LEFT" >+ read(inputStream: InputStream): T</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

JacksonJsonWriter502335110[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)JacksonJsonWriter&lt;T&gt;</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   objectMapper: ObjectMapper [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ write(message: T): byte[]</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

JavaSerDe1955622255[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)JavaSerDe</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ deserialize(data: byte[]): Object</TD></TR>
<TR><TD ALIGN="LEFT" >+ of(): JavaSerDe</TD></TR>
<TR><TD ALIGN="LEFT" >+ serialize(resultValue: Object): byte[]</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

JsonReader657740342[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)JsonReader&lt;T&gt;</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   objectMapper: ObjectMapper [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   pojo: Class&lt;T&gt; [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ read(bytes: byte[], offset: int, length: int): T</TD></TR>
<TR><TD ALIGN="LEFT" >+ read(inputStream: InputStream): T</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

JsonSchemaCompatibilityCheck445450388[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)JsonSchemaCompatibilityCheck</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   objectMapper: ObjectMapper [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ checkCompatible(from: SchemaData, to: SchemaData, strategy: SchemaCompatibilityStrategy)</TD></TR>
<TR><TD ALIGN="LEFT" >- isAvroSchema(schemaData: SchemaData): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >- isCompatibleJsonSchema(from: SchemaData, to: SchemaData)</TD></TR>
<TR><TD ALIGN="LEFT" >- isJsonSchema(schemaData: SchemaData): boolean</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

JsonWriter502335110[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)JsonWriter&lt;T&gt;</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   objectMapper: ObjectMapper [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ write(message: T): byte[]</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

KafkaSchemaWrappedSchema1867121574[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)KafkaSchemaWrappedSchema</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   schemaInfo: SchemaInfo [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ clone(): Schema&lt;byte[]&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ encode(data: byte[]): byte[]</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

KeyLongValue297559756[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)KeyLongValue</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   _bitField0: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _cachedSize: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _keyBufferIdx: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _keyBufferLen: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _parsedBuffer: ByteBuf [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   key: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   value: long [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- checkRequiredFields()</TD></TR>
<TR><TD ALIGN="LEFT" >+ clear(): KeyLongValue</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearKey(): KeyLongValue</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearValue(): KeyLongValue</TD></TR>
<TR><TD ALIGN="LEFT" >+ copyFrom(_other: KeyLongValue): KeyLongValue</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(_buffer: ByteBuf, _size: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(a: byte[])</TD></TR>
<TR><TD ALIGN="LEFT" >+ setKey(key: String): KeyLongValue</TD></TR>
<TR><TD ALIGN="LEFT" >+ setValue(value: long): KeyLongValue</TD></TR>
<TR><TD ALIGN="LEFT" >+ toByteArray(): byte[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeTo(_b: ByteBuf): int</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

KeySharedMeta297559756[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)KeySharedMeta</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   _bitField0: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _cachedSize: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _hashRangesCount: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _parsedBuffer: ByteBuf [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   allowOutOfOrderDelivery: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   hashRanges: List&lt;IntRange&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   keySharedMode: KeySharedMode [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ addAllHashRanges(hashRanges: Iterable&lt;IntRange&gt;): KeySharedMeta</TD></TR>
<TR><TD ALIGN="LEFT" >+ addHashRange(): IntRange</TD></TR>
<TR><TD ALIGN="LEFT" >- checkRequiredFields()</TD></TR>
<TR><TD ALIGN="LEFT" >+ clear(): KeySharedMeta</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearAllowOutOfOrderDelivery(): KeySharedMeta</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearHashRanges(): KeySharedMeta</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearKeySharedMode(): KeySharedMeta</TD></TR>
<TR><TD ALIGN="LEFT" >+ copyFrom(_other: KeySharedMeta): KeySharedMeta</TD></TR>
<TR><TD ALIGN="LEFT" >+ getHashRangeAt(idx: int): IntRange</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(_buffer: ByteBuf, _size: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(a: byte[])</TD></TR>
<TR><TD ALIGN="LEFT" >+ setAllowOutOfOrderDelivery(allowOutOfOrderDelivery: boolean): KeySharedMeta</TD></TR>
<TR><TD ALIGN="LEFT" >+ setKeySharedMode(keySharedMode: KeySharedMode): KeySharedMeta</TD></TR>
<TR><TD ALIGN="LEFT" >+ toByteArray(): byte[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeTo(_b: ByteBuf): int</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

KeyValue1828741399[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)KeyValue&lt;K, V&gt;</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   key: K [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   value: V [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ decode(data: byte[], decoder: KeyValueDecoder&lt;K, V&gt;): KeyValue&lt;K, V&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ encode(key: K, keyWriter: Schema&lt;K&gt;, value: V, valueWriter: Schema&lt;V&gt;): byte[]</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

KeyValue297559756[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)KeyValue</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   _bitField0: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _cachedSize: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _keyBufferIdx: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _keyBufferLen: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _parsedBuffer: ByteBuf [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _valueBufferIdx: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _valueBufferLen: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   key: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   value: String [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- checkRequiredFields()</TD></TR>
<TR><TD ALIGN="LEFT" >+ clear(): KeyValue</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearKey(): KeyValue</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearValue(): KeyValue</TD></TR>
<TR><TD ALIGN="LEFT" >+ copyFrom(_other: KeyValue): KeyValue</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(_buffer: ByteBuf, _size: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(a: byte[])</TD></TR>
<TR><TD ALIGN="LEFT" >+ setKey(key: String): KeyValue</TD></TR>
<TR><TD ALIGN="LEFT" >+ setValue(value: String): KeyValue</TD></TR>
<TR><TD ALIGN="LEFT" >+ toByteArray(): byte[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeTo(_b: ByteBuf): int</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

KeyValuePair268846344[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)KeyValuePair</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   bitField0_: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   key_: Object [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   memoizedIsInitialized: byte [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   value_: Object [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># internalGetFieldAccessorTable(): FieldAccessorTable</TD></TR>
<TR><TD ALIGN="LEFT" >+ newBuilder(): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ newBuilder(prototype: KeyValuePair): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ newBuilderForType(): Builder</TD></TR>
<TR><TD ALIGN="LEFT" ># newBuilderForType(parent: BuilderParent): Builder</TD></TR>
<TR><TD ALIGN="LEFT" ># newInstance(unused: UnusedPrivateParameter): Object</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseDelimitedFrom(input: InputStream): KeyValuePair</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseDelimitedFrom(input: InputStream, extensionRegistry: ExtensionRegistryLite): KeyValuePair</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(data: ByteBuffer): KeyValuePair</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(data: ByteBuffer, extensionRegistry: ExtensionRegistryLite): KeyValuePair</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(data: ByteString): KeyValuePair</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(data: ByteString, extensionRegistry: ExtensionRegistryLite): KeyValuePair</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(data: byte[]): KeyValuePair</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(data: byte[], extensionRegistry: ExtensionRegistryLite): KeyValuePair</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(input: InputStream): KeyValuePair</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(input: InputStream, extensionRegistry: ExtensionRegistryLite): KeyValuePair</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(input: CodedInputStream): KeyValuePair</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(input: CodedInputStream, extensionRegistry: ExtensionRegistryLite): KeyValuePair</TD></TR>
<TR><TD ALIGN="LEFT" >+ parser(): Parser&lt;KeyValuePair&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ toBuilder(): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeTo(output: CodedOutputStream)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

KeyValueSchemaCompatibilityCheck445450388[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)KeyValueSchemaCompatibilityCheck</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   checkers: Map&lt;SchemaType, SchemaCompatibilityCheck&gt; [0..*]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ checkCompatible(from: SchemaData, to: SchemaData, strategy: SchemaCompatibilityStrategy)</TD></TR>
<TR><TD ALIGN="LEFT" >+ checkCompatible(from: Iterable&lt;SchemaData&gt;, to: SchemaData, strategy: SchemaCompatibilityStrategy)</TD></TR>
<TR><TD ALIGN="LEFT" >+ decodeKeyValueSchemaData(schemaData: SchemaData): KeyValue&lt;SchemaData, SchemaData&gt;</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

KeyValueSchemaImpl1622012615[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)KeyValueSchemaImpl&lt;K, V&gt;</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   keySchema: Schema&lt;K&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   keyValueEncodingType: KeyValueEncodingType [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   schemaInfo: SchemaInfo [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   schemaInfoProvider: SchemaInfoProvider [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   valueSchema: Schema&lt;V&gt; [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ atSchemaVersion(schemaVersion: byte[]): Schema&lt;?&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- buildKeyValueSchemaInfo()</TD></TR>
<TR><TD ALIGN="LEFT" >+ clone(): Schema&lt;KeyValue&lt;K, V&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- configureKeyValueSchemaInfo()</TD></TR>
<TR><TD ALIGN="LEFT" >+ configureSchemaInfo(topicName: String, componentName: String, schemaInfo: SchemaInfo)</TD></TR>
<TR><TD ALIGN="LEFT" >+ decode(bytes: byte[]): KeyValue&lt;K, V&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ decode(bytes: byte[], schemaVersion: byte[]): KeyValue&lt;K, V&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ decode(byteBuf: ByteBuf): KeyValue&lt;K, V&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ decode(byteBuf: ByteBuf, schemaVersion: byte[]): KeyValue&lt;K, V&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ decode(keyBytes: byte[], valueBytes: byte[], schemaVersion: byte[]): KeyValue&lt;K, V&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ encode(message: KeyValue&lt;K, V&gt;): byte[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ fetchSchemaIfNeeded(topicName: String, schemaVersion: SchemaVersion)</TD></TR>
<TR><TD ALIGN="LEFT" >+ kvBytes(): Schema&lt;KeyValue&lt;byte[], byte[]&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ of(key: Class&lt;K&gt;, value: Class&lt;V&gt;, type: SchemaType): Schema&lt;KeyValue&lt;K, V&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ of(keySchema: Schema&lt;K&gt;, valueSchema: Schema&lt;V&gt;): Schema&lt;KeyValue&lt;K, V&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ of(keySchema: Schema&lt;K&gt;, valueSchema: Schema&lt;V&gt;, keyValueEncodingType: KeyValueEncodingType): Schema&lt;KeyValue&lt;K, V&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ requireFetchingSchemaInfo(): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ supportSchemaVersioning(): boolean</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

KeyValueSchemaInfo1622012615[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)KeyValueSchemaInfo</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ decodeKeyValueEncodingType(schemaInfo: SchemaInfo): KeyValueEncodingType</TD></TR>
<TR><TD ALIGN="LEFT" >+ decodeKeyValueSchemaInfo(schemaInfo: SchemaInfo): KeyValue&lt;SchemaInfo, SchemaInfo&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- decodeSubSchemaInfo(parentSchemaInfo: SchemaInfo, schemaNameProperty: String, schemaTypeProperty: String, schemaPropsProperty: String, schemaData: byte[]): SchemaInfo</TD></TR>
<TR><TD ALIGN="LEFT" >+ encodeKeyValueSchemaInfo(keySchema: Schema&lt;K&gt;, valueSchema: Schema&lt;V&gt;, keyValueEncodingType: KeyValueEncodingType): SchemaInfo</TD></TR>
<TR><TD ALIGN="LEFT" >+ encodeKeyValueSchemaInfo(schemaName: String, keySchema: Schema&lt;K&gt;, valueSchema: Schema&lt;V&gt;, keyValueEncodingType: KeyValueEncodingType): SchemaInfo</TD></TR>
<TR><TD ALIGN="LEFT" >+ encodeKeyValueSchemaInfo(schemaName: String, keySchemaInfo: SchemaInfo, valueSchemaInfo: SchemaInfo, keyValueEncodingType: KeyValueEncodingType): SchemaInfo</TD></TR>
<TR><TD ALIGN="LEFT" >- encodeSubSchemaInfoToParentSchemaProperties(schemaInfo: SchemaInfo, schemaNameProperty: String, schemaTypeProperty: String, schemaPropsProperty: String, parentSchemaProperties: Map&lt;String, String&gt;)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

LatestVersion1472480913[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)LatestVersion</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ bytes(): byte[]</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

LeaderService1316119764[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)LeaderService</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   consumer: ConsumerImpl&lt;byte[]&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   consumerName: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   errorNotifier: ErrorNotifier [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   functionAssignmentTailer: FunctionAssignmentTailer [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   functionMetaDataManager: FunctionMetaDataManager [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   functionRuntimeManager: FunctionRuntimeManager [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   isLeader: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   membershipManager: MembershipManager [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   pulsarClient: PulsarClient [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   schedulerManager: SchedulerManager [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   workerConfig: WorkerConfig [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ becameActive(consumer: Consumer&lt;?&gt;, partitionId: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ becameInactive(consumer: Consumer&lt;?&gt;, partitionId: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ start()</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

LedgerDetails961700686[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)LedgerDetails</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+   entries: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   ledgerId: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   size: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   timestamp: long [1]</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

LightProtoCodec1906636927[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)LightProtoCodec</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- _writeVarInt(b: ByteBuf, n: int)</TD></TR>
<TR><TD ALIGN="LEFT" ># computeSignedVarInt64Size(value: long): int</TD></TR>
<TR><TD ALIGN="LEFT" ># computeSignedVarIntSize(value: int): int</TD></TR>
<TR><TD ALIGN="LEFT" ># computeStringUTF8Size(s: String): int</TD></TR>
<TR><TD ALIGN="LEFT" ># computeVarInt64Size(value: long): int</TD></TR>
<TR><TD ALIGN="LEFT" ># computeVarIntSize(value: int): int</TD></TR>
<TR><TD ALIGN="LEFT" ># computeVarUIntSize(value: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >- decodeZigZag32(n: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >- decodeZigZag64(n: long): long</TD></TR>
<TR><TD ALIGN="LEFT" >- encodeZigZag32(n: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >- encodeZigZag64(n: long): long</TD></TR>
<TR><TD ALIGN="LEFT" ># getFieldId(tag: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >- getTagType(tag: int): int</TD></TR>
<TR><TD ALIGN="LEFT" ># readDouble(b: ByteBuf): double</TD></TR>
<TR><TD ALIGN="LEFT" ># readFixedInt32(b: ByteBuf): int</TD></TR>
<TR><TD ALIGN="LEFT" ># readFixedInt64(b: ByteBuf): long</TD></TR>
<TR><TD ALIGN="LEFT" ># readFloat(b: ByteBuf): float</TD></TR>
<TR><TD ALIGN="LEFT" ># readSignedVarInt(b: ByteBuf): int</TD></TR>
<TR><TD ALIGN="LEFT" ># readSignedVarInt64(b: ByteBuf): long</TD></TR>
<TR><TD ALIGN="LEFT" ># readString(b: ByteBuf, index: int, len: int): String</TD></TR>
<TR><TD ALIGN="LEFT" ># readVarInt(buf: ByteBuf): int</TD></TR>
<TR><TD ALIGN="LEFT" ># readVarInt64(buf: ByteBuf): long</TD></TR>
<TR><TD ALIGN="LEFT" ># skipUnknownField(tag: int, buffer: ByteBuf)</TD></TR>
<TR><TD ALIGN="LEFT" ># writeDouble(b: ByteBuf, n: double)</TD></TR>
<TR><TD ALIGN="LEFT" ># writeFixedInt32(b: ByteBuf, n: int)</TD></TR>
<TR><TD ALIGN="LEFT" ># writeFixedInt64(b: ByteBuf, n: long)</TD></TR>
<TR><TD ALIGN="LEFT" ># writeFloat(b: ByteBuf, n: float)</TD></TR>
<TR><TD ALIGN="LEFT" ># writeSignedVarInt(b: ByteBuf, n: int)</TD></TR>
<TR><TD ALIGN="LEFT" ># writeSignedVarInt64(b: ByteBuf, n: long)</TD></TR>
<TR><TD ALIGN="LEFT" ># writeString(b: ByteBuf, s: String, bytesCount: int)</TD></TR>
<TR><TD ALIGN="LEFT" ># writeVarInt(b: ByteBuf, n: int)</TD></TR>
<TR><TD ALIGN="LEFT" ># writeVarInt64(b: ByteBuf, value: long)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

LightProtoCodec297559756[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)LightProtoCodec</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- _writeVarInt(b: ByteBuf, n: int)</TD></TR>
<TR><TD ALIGN="LEFT" ># computeSignedVarInt64Size(value: long): int</TD></TR>
<TR><TD ALIGN="LEFT" ># computeSignedVarIntSize(value: int): int</TD></TR>
<TR><TD ALIGN="LEFT" ># computeStringUTF8Size(s: String): int</TD></TR>
<TR><TD ALIGN="LEFT" ># computeVarInt64Size(value: long): int</TD></TR>
<TR><TD ALIGN="LEFT" ># computeVarIntSize(value: int): int</TD></TR>
<TR><TD ALIGN="LEFT" ># computeVarUIntSize(value: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >- decodeZigZag32(n: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >- decodeZigZag64(n: long): long</TD></TR>
<TR><TD ALIGN="LEFT" >- encodeZigZag32(n: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >- encodeZigZag64(n: long): long</TD></TR>
<TR><TD ALIGN="LEFT" ># getFieldId(tag: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >- getTagType(tag: int): int</TD></TR>
<TR><TD ALIGN="LEFT" ># readDouble(b: ByteBuf): double</TD></TR>
<TR><TD ALIGN="LEFT" ># readFixedInt32(b: ByteBuf): int</TD></TR>
<TR><TD ALIGN="LEFT" ># readFixedInt64(b: ByteBuf): long</TD></TR>
<TR><TD ALIGN="LEFT" ># readFloat(b: ByteBuf): float</TD></TR>
<TR><TD ALIGN="LEFT" ># readSignedVarInt(b: ByteBuf): int</TD></TR>
<TR><TD ALIGN="LEFT" ># readSignedVarInt64(b: ByteBuf): long</TD></TR>
<TR><TD ALIGN="LEFT" ># readString(b: ByteBuf, index: int, len: int): String</TD></TR>
<TR><TD ALIGN="LEFT" ># readVarInt(buf: ByteBuf): int</TD></TR>
<TR><TD ALIGN="LEFT" ># readVarInt64(buf: ByteBuf): long</TD></TR>
<TR><TD ALIGN="LEFT" ># skipUnknownField(tag: int, buffer: ByteBuf)</TD></TR>
<TR><TD ALIGN="LEFT" ># writeDouble(b: ByteBuf, n: double)</TD></TR>
<TR><TD ALIGN="LEFT" ># writeFixedInt32(b: ByteBuf, n: int)</TD></TR>
<TR><TD ALIGN="LEFT" ># writeFixedInt64(b: ByteBuf, n: long)</TD></TR>
<TR><TD ALIGN="LEFT" ># writeFloat(b: ByteBuf, n: float)</TD></TR>
<TR><TD ALIGN="LEFT" ># writeSignedVarInt(b: ByteBuf, n: int)</TD></TR>
<TR><TD ALIGN="LEFT" ># writeSignedVarInt64(b: ByteBuf, n: long)</TD></TR>
<TR><TD ALIGN="LEFT" ># writeString(b: ByteBuf, s: String, bytesCount: int)</TD></TR>
<TR><TD ALIGN="LEFT" ># writeVarInt(b: ByteBuf, n: int)</TD></TR>
<TR><TD ALIGN="LEFT" ># writeVarInt64(b: ByteBuf, value: long)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

LinuxBrokerHostUsageImpl109292786[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)LinuxBrokerHostUsageImpl</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   isCGroupsEnabled: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   lastCollection: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   lastCpuTotalTime: double [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   lastCpuUsage: double [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   lastTotalNicUsageRx: double [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   lastTotalNicUsageTx: double [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   overrideBrokerNicSpeedGbps: Optional&lt;Double&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   systemBean: OperatingSystemMXBean [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   usage: SystemResourceUsage [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ calculateBrokerHostUsage()</TD></TR>
<TR><TD ALIGN="LEFT" >- getNicRxPath(nic: String): Path</TD></TR>
<TR><TD ALIGN="LEFT" >- getNicSpeedPath(nic: String): Path</TD></TR>
<TR><TD ALIGN="LEFT" >- getNicTxPath(nic: String): Path</TD></TR>
<TR><TD ALIGN="LEFT" >- getTotalCpuUsage(elapsedTimeSeconds: double): double</TD></TR>
<TR><TD ALIGN="LEFT" >- getTotalCpuUsageForCGroup(elapsedTimeSeconds: double): double</TD></TR>
<TR><TD ALIGN="LEFT" >- getTotalNicLimitKbps(nics: List&lt;String&gt;): double</TD></TR>
<TR><TD ALIGN="LEFT" >- getTotalNicUsageRxKb(nics: List&lt;String&gt;): double</TD></TR>
<TR><TD ALIGN="LEFT" >- getTotalNicUsageTxKb(nics: List&lt;String&gt;): double</TD></TR>
<TR><TD ALIGN="LEFT" >- isPhysicalNic(path: Path): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >- readLongFromFile(path: String): long</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

LoadManagerShared109292786[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)LoadManagerShared</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ applyNamespacePolicies(serviceUnit: ServiceUnitId, policies: SimpleResourceAllocationPolicies, brokerCandidateCache: Set&lt;String&gt;, availableBrokers: Set&lt;String&gt;, brokerTopicLoadingPredicate: BrokerTopicLoadingPredicate)</TD></TR>
<TR><TD ALIGN="LEFT" >+ fillNamespaceToBundlesMap(bundles: Set&lt;String&gt;, target: ConcurrentOpenHashMap&lt;String, ConcurrentOpenHashSet&lt;String&gt;&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ filterAntiAffinityGroupOwnedBrokers(pulsar: PulsarService, assignedBundleName: String, candidates: Set&lt;String&gt;, brokerToNamespaceToBundleRange: ConcurrentOpenHashMap&lt;String, ConcurrentOpenHashMap&lt;String, ConcurrentOpenHashSet&lt;String&gt;&gt;&gt;, brokerToDomainMap: Map&lt;String, String&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ filterBrokersWithLargeTopicCount(brokerCandidateCache: Set&lt;String&gt;, loadData: LoadData, loadBalancerBrokerMaxTopics: int)</TD></TR>
<TR><TD ALIGN="LEFT" >- filterDomainsNotHavingLeastNumberAntiAffinityNamespaces(brokerToAntiAffinityNamespaceCount: Map&lt;String, Integer&gt;, candidates: Set&lt;String&gt;, brokerToDomainMap: Map&lt;String, String&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ getAntiAffinityNamespaceOwnedBrokers(pulsar: PulsarService, namespaceName: String, brokerToNamespaceToBundleRange: ConcurrentOpenHashMap&lt;String, ConcurrentOpenHashMap&lt;String, ConcurrentOpenHashSet&lt;String&gt;&gt;&gt;): CompletableFuture&lt;Map&lt;String, Integer&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getBundleRangeFromBundleName(bundleName: String): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ getNamespaceNameFromBundleName(bundleName: String): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ getSystemResourceUsage(brokerHostUsage: BrokerHostUsage): SystemResourceUsage</TD></TR>
<TR><TD ALIGN="LEFT" >+ isLoadSheddingEnabled(pulsar: PulsarService): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ removeMostServicingBrokersForNamespace(assignedBundleName: String, candidates: Set&lt;String&gt;, brokerToNamespaceToBundleRange: ConcurrentOpenHashMap&lt;String, ConcurrentOpenHashMap&lt;String, ConcurrentOpenHashSet&lt;String&gt;&gt;&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ shouldAntiAffinityNamespaceUnload(namespace: String, bundle: String, currentBroker: String, pulsar: PulsarService, brokerToNamespaceToBundleRange: ConcurrentOpenHashMap&lt;String, ConcurrentOpenHashMap&lt;String, ConcurrentOpenHashSet&lt;String&gt;&gt;&gt;, candidateBrokers: Set&lt;String&gt;): boolean</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

LoadReport842356003[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)LoadReport</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   allocatedBandwidthIn: double [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   allocatedBandwidthOut: double [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   allocatedCPU: double [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   allocatedMemory: double [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   allocatedMsgRateIn: double [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   allocatedMsgRateOut: double [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   brokerVersionString: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   bundleGains: Set&lt;String&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   bundleLosses: Set&lt;String&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   bundleStats: Map&lt;String, NamespaceBundleStats&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   isOverLoaded: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   isUnderLoaded: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   msgRateIn: double [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   msgRateOut: double [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   name: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   nonPersistentTopicsEnabled: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   numBundles: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   numConsumers: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   numProducers: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   numTopics: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   persistentTopicsEnabled: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   preAllocatedBandwidthIn: double [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   preAllocatedBandwidthOut: double [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   preAllocatedCPU: double [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   preAllocatedMemory: double [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   preAllocatedMsgRateIn: double [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   preAllocatedMsgRateOut: double [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   protocols: Map&lt;String, String&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   pulsarServiceUrl: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   pulsarServiceUrlTls: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   systemResourceUsage: SystemResourceUsage [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   timestamp: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   webServiceUrl: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   webServiceUrlTls: String [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ getProtocol(protocol: String): Optional&lt;String&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getSortedBundleStats(resType: ResourceType): TreeMap&lt;String, NamespaceBundleStats&gt;</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

LocalBrokerData842356003[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)LocalBrokerData</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   advertisedListeners: Map&lt;String, AdvertisedListener&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   bandwidthIn: ResourceUsage [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   bandwidthOut: ResourceUsage [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   brokerVersionString: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   bundles: Set&lt;String&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   cpu: ResourceUsage [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   directMemory: ResourceUsage [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   lastBundleGains: Set&lt;String&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   lastBundleLosses: Set&lt;String&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   lastStats: Map&lt;String, NamespaceBundleStats&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   lastUpdate: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   memory: ResourceUsage [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   msgRateIn: double [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   msgRateOut: double [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   msgThroughputIn: double [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   msgThroughputOut: double [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   nonPersistentTopicsEnabled: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   numBundles: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   numConsumers: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   numProducers: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   numTopics: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   persistentTopicsEnabled: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   protocols: Map&lt;String, String&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   pulsarServiceUrl: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   pulsarServiceUrlTls: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   webServiceUrl: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   webServiceUrlTls: String [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ cleanDeltas()</TD></TR>
<TR><TD ALIGN="LEFT" >+ getMaxResourceUsageWithWeight(cpuWeight: double, memoryWeight: double, directMemoryWeight: double, bandwidthInWeight: double, bandwidthOutWeight: double): double</TD></TR>
<TR><TD ALIGN="LEFT" >+ getProtocol(protocol: String): Optional&lt;String&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- max(args: double...): double</TD></TR>
<TR><TD ALIGN="LEFT" >- max(args: float...): float</TD></TR>
<TR><TD ALIGN="LEFT" >+ printResourceUsage(): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ update(systemResourceUsage: SystemResourceUsage, bundleStats: Map&lt;String, NamespaceBundleStats&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ update(other: LocalBrokerData)</TD></TR>
<TR><TD ALIGN="LEFT" >- updateBundleData(bundleStats: Map&lt;String, NamespaceBundleStats&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >- updateSystemResourceUsage(systemResourceUsage: SystemResourceUsage)</TD></TR>
<TR><TD ALIGN="LEFT" >- updateSystemResourceUsage(cpu: ResourceUsage, memory: ResourceUsage, directMemory: ResourceUsage, bandwidthIn: ResourceUsage, bandwidthOut: ResourceUsage)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

LocalDateSchema1622012615[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)LocalDateSchema</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ decode(bytes: byte[]): LocalDate</TD></TR>
<TR><TD ALIGN="LEFT" >+ decode(byteBuf: ByteBuf): LocalDate</TD></TR>
<TR><TD ALIGN="LEFT" >+ encode(message: LocalDate): byte[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ of(): LocalDateSchema</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

LocalDateTimeSchema1622012615[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)LocalDateTimeSchema</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ decode(bytes: byte[]): LocalDateTime</TD></TR>
<TR><TD ALIGN="LEFT" >+ decode(byteBuf: ByteBuf): LocalDateTime</TD></TR>
<TR><TD ALIGN="LEFT" >+ encode(message: LocalDateTime): byte[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ of(): LocalDateTimeSchema</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

LocalMemoryMetadataStore437280412[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)LocalMemoryMetadataStore</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   map: NavigableMap&lt;String, Value&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   sequentialIdGenerator: AtomicLong [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ existsFromStore(path: String): CompletableFuture&lt;Boolean&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getChildrenFromStore(path: String): CompletableFuture&lt;List&lt;String&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ storeDelete(path: String, optExpectedVersion: Optional&lt;Long&gt;): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ storeGet(path: String): CompletableFuture&lt;Optional&lt;GetResult&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ storePut(path: String, data: byte[], optExpectedVersion: Optional&lt;Long&gt;, options: EnumSet&lt;CreateOption&gt;): CompletableFuture&lt;Stat&gt;</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

LocalPoliciesResources220376139[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)LocalPoliciesResources</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ createLocalPoliciesAsync(ns: NamespaceName, policies: LocalPolicies): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ deleteLocalPolicies(ns: NamespaceName)</TD></TR>
<TR><TD ALIGN="LEFT" >+ deleteLocalPoliciesAsync(ns: NamespaceName): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ deleteLocalPoliciesTenantAsync(tenant: String): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getLocalPolicies(ns: NamespaceName): Optional&lt;LocalPolicies&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getLocalPoliciesAsync(ns: NamespaceName): CompletableFuture&lt;Optional&lt;LocalPolicies&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getLocalPoliciesWithVersion(ns: NamespaceName): CompletableFuture&lt;Optional&lt;CacheGetResult&lt;LocalPolicies&gt;&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ isLocalPoliciesPath(path: String): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ setLocalPoliciesWithVersion(ns: NamespaceName, policies: LocalPolicies, version: Optional&lt;Long&gt;): CompletableFuture&lt;Void&gt;</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

LocalTimeSchema1622012615[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)LocalTimeSchema</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ decode(bytes: byte[]): LocalTime</TD></TR>
<TR><TD ALIGN="LEFT" >+ decode(byteBuf: ByteBuf): LocalTime</TD></TR>
<TR><TD ALIGN="LEFT" >+ encode(message: LocalTime): byte[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ of(): LocalTimeSchema</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

LockManagerImpl1394915087[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)LockManagerImpl&lt;T&gt;</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   cache: MetadataCache&lt;T&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   executor: ExecutorService [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   locks: Map&lt;String, ResourceLockImpl&lt;T&gt;&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   serde: MetadataSerde&lt;T&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   state: State [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   store: MetadataStoreExtended [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ acquireLock(path: String, value: T): CompletableFuture&lt;ResourceLock&lt;T&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ asyncClose(): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >- handleDataNotification(n: Notification)</TD></TR>
<TR><TD ALIGN="LEFT" >- handleSessionEvent(se: SessionEvent)</TD></TR>
<TR><TD ALIGN="LEFT" >+ listLocks(path: String): CompletableFuture&lt;List&lt;String&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ readLock(path: String): CompletableFuture&lt;Optional&lt;T&gt;&gt;</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

LongSchema1622012615[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)LongSchema</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ decode(bytes: byte[]): Long</TD></TR>
<TR><TD ALIGN="LEFT" >+ decode(byteBuf: ByteBuf): Long</TD></TR>
<TR><TD ALIGN="LEFT" >+ encode(data: Long): byte[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ of(): LongSchema</TD></TR>
<TR><TD ALIGN="LEFT" >+ validate(message: byte[])</TD></TR>
<TR><TD ALIGN="LEFT" >+ validate(message: ByteBuf)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

LongSchemaVersion1828741399[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)LongSchemaVersion</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   version: long [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ bytes(): byte[]</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

LookupOptions839302271[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)LookupOptions</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   advertisedListenerName: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   authoritative: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   loadTopicsInBundle: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   readOnly: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   requestHttps: boolean [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ builder(): LookupOptionsBuilder</TD></TR>
<TR><TD ALIGN="LEFT" ># canEqual(other: Object): boolean</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

LookupProxyHandler79518146[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)LookupProxyHandler</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   brokerServiceURL: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   clientAddress: SocketAddress [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   connectWithTLS: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   discoveryProvider: BrokerDiscoveryProvider [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   lookupRequestSemaphore: Semaphore [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   proxyConnection: ProxyConnection [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   throttlingErrorMessage: String [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- getAddr(brokerServiceUrl: String, clientRequestId: long): InetSocketAddress</TD></TR>
<TR><TD ALIGN="LEFT" >- getBrokerServiceUrl(clientRequestId: long): String</TD></TR>
<TR><TD ALIGN="LEFT" >- getServerError(error: Throwable): ServerError</TD></TR>
<TR><TD ALIGN="LEFT" >+ handleGetSchema(commandGetSchema: CommandGetSchema)</TD></TR>
<TR><TD ALIGN="LEFT" >+ handleGetTopicsOfNamespace(commandGetTopicsOfNamespace: CommandGetTopicsOfNamespace)</TD></TR>
<TR><TD ALIGN="LEFT" >- handleGetTopicsOfNamespace(commandGetTopicsOfNamespace: CommandGetTopicsOfNamespace, clientRequestId: long)</TD></TR>
<TR><TD ALIGN="LEFT" >+ handleLookup(lookup: CommandLookupTopic)</TD></TR>
<TR><TD ALIGN="LEFT" >+ handlePartitionMetadataResponse(partitionMetadata: CommandPartitionedTopicMetadata)</TD></TR>
<TR><TD ALIGN="LEFT" >- handlePartitionMetadataResponse(partitionMetadata: CommandPartitionedTopicMetadata, clientRequestId: long)</TD></TR>
<TR><TD ALIGN="LEFT" >- performGetTopicsOfNamespace(clientRequestId: long, namespaceName: String, brokerServiceUrl: String, numberOfRetries: int, mode: Mode)</TD></TR>
<TR><TD ALIGN="LEFT" >- performLookup(clientRequestId: long, topic: String, brokerServiceUrl: String, authoritative: boolean, numberOfRetries: int)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

MLTransactionLogImpl1462729559[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)MLTransactionLogImpl</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   cursor: ManagedCursor [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   entryQueue: SpscArrayQueue&lt;Entry&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   managedLedger: ManagedLedger [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   managedLedgerConfig: ManagedLedgerConfig [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   managedLedgerFactory: ManagedLedgerFactory [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   tcId: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   topicName: TopicName [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ append(transactionMetadataEntry: TransactionMetadataEntry): CompletableFuture&lt;Position&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ closeAsync(): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ deletePosition(positions: List&lt;Position&gt;): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getMLTransactionLogName(tcID: TransactionCoordinatorID): TopicName</TD></TR>
<TR><TD ALIGN="LEFT" >+ initialize(): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- readAsync(numberOfEntriesToRead: int, readEntriesCallback: ReadEntriesCallback)</TD></TR>
<TR><TD ALIGN="LEFT" >+ replayAsync(transactionLogReplayCallback: TransactionLogReplayCallback)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

MLTransactionMetadataStore1462729559[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)MLTransactionMetadataStore</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   abortedTransactionCount: LongAdder [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   appendLogCount: LongAdder [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   committedTransactionCount: LongAdder [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   createdTransactionCount: LongAdder [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   internalPinnedExecutor: ExecutorService [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   sequenceIdGenerator: MLTransactionSequenceIdGenerator [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   tcID: TransactionCoordinatorID [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   timeoutTracker: TransactionTimeoutTracker [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   transactionLog: MLTransactionLogImpl [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   transactionMetadataStoreStats: TransactionMetadataStoreStats [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   transactionTimeoutCount: LongAdder [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   txnMetaMap: ConcurrentSkipListMap&lt;Long, Pair&lt;TxnMeta, List&lt;Position&gt;&gt;&gt; [0..*]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ addAckedPartitionToTxn(txnID: TxnID, txnSubscriptions: List&lt;TransactionSubscription&gt;): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ addProducedPartitionToTxn(txnID: TxnID, partitions: List&lt;String&gt;): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ closeAsync(): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getSlowTransactions(timeout: long): List&lt;TxnMeta&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getTxnMeta(txnID: TxnID): CompletableFuture&lt;TxnMeta&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- getTxnPositionPair(txnID: TxnID): CompletableFuture&lt;Pair&lt;TxnMeta, List&lt;Position&gt;&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getTxnStatus(txnID: TxnID): CompletableFuture&lt;TxnStatus&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ newTransaction(timeOut: long): CompletableFuture&lt;TxnID&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ subscriptionToTxnSubscription(subscriptions: List&lt;Subscription&gt;): List&lt;TransactionSubscription&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ txnSubscriptionToSubscription(tnxSubscriptions: List&lt;TransactionSubscription&gt;): List&lt;Subscription&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ updateTxnStatus(txnID: TxnID, newStatus: TxnStatus, expectedStatus: TxnStatus, isTimeout: boolean): CompletableFuture&lt;Void&gt;</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

MLTransactionMetadataStoreProvider1462729559[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)MLTransactionMetadataStoreProvider</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ openStore(transactionCoordinatorId: TransactionCoordinatorID, managedLedgerFactory: ManagedLedgerFactory, managedLedgerConfig: ManagedLedgerConfig, timeoutTracker: TransactionTimeoutTracker, recoverTracker: TransactionRecoverTracker): CompletableFuture&lt;TransactionMetadataStore&gt;</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

MLTransactionSequenceIdGenerator1462729559[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)MLTransactionSequenceIdGenerator</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   sequenceId: AtomicLong [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ beforeAddEntry(op: OpAddEntry, numberOfMessages: int): OpAddEntry</TD></TR>
<TR><TD ALIGN="LEFT" ># generateSequenceId(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ onManagedLedgerLastLedgerInitialize(name: String, lh: LedgerHandle): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ onManagedLedgerPropertiesInitialize(propertiesMap: Map&lt;String, String&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ onUpdateManagedLedgerInfo(propertiesMap: Map&lt;String, String&gt;)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

ManagedLedgerInterceptorImpl1588982040[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)ManagedLedgerInterceptorImpl</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   brokerEntryMetadataInterceptors: Set&lt;BrokerEntryMetadataInterceptor&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   inputProcessors: Set&lt;Processor&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   outputProcessors: Set&lt;Processor&gt; [0..*]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ beforeAddEntry(op: OpAddEntry, numberOfMessages: int): OpAddEntry</TD></TR>
<TR><TD ALIGN="LEFT" >+ onManagedLedgerLastLedgerInitialize(name: String, lh: LedgerHandle): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ onManagedLedgerPropertiesInitialize(propertiesMap: Map&lt;String, String&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ onUpdateManagedLedgerInfo(propertiesMap: Map&lt;String, String&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >- processPayload(processors: Set&lt;Processor&gt;, context: Object, payload: ByteBuf): PayloadProcessorHandle</TD></TR>
<TR><TD ALIGN="LEFT" >+ processPayloadBeforeEntryCache(ledgerData: ByteBuf): PayloadProcessorHandle</TD></TR>
<TR><TD ALIGN="LEFT" >+ processPayloadBeforeLedgerWrite(op: OpAddEntry, ledgerData: ByteBuf): PayloadProcessorHandle</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

MessageDeduplication1101090806[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)MessageDeduplication</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   highestSequencedPersisted: ConcurrentOpenHashMap&lt;String, Long&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   highestSequencedPushed: ConcurrentOpenHashMap&lt;String, Long&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   inactiveProducers: Map&lt;String, Long&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   lastSnapshotTimestamp: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   managedCursor: ManagedCursor [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   managedLedger: ManagedLedger [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   maxNumberOfProducers: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   pulsar: PulsarService [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   replicatorPrefix: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   snapshotCounter: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   snapshotInterval: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   status: Status [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   topic: PersistentTopic [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ checkStatus(): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getLastPublishedSequenceId(producerName: String): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ isDuplicate(publishContext: PublishContext, headersAndPayload: ByteBuf): MessageDupStatus</TD></TR>
<TR><TD ALIGN="LEFT" >+ producerAdded(producerName: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ producerRemoved(producerName: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ purgeInactiveProducers()</TD></TR>
<TR><TD ALIGN="LEFT" >+ recordMessagePersisted(publishContext: PublishContext, position: PositionImpl)</TD></TR>
<TR><TD ALIGN="LEFT" >- recoverSequenceIdsMap(): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- replayCursor(future: CompletableFuture&lt;Void&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ resetHighestSequenceIdPushed()</TD></TR>
<TR><TD ALIGN="LEFT" >- takeSnapshot(position: PositionImpl)</TD></TR>
<TR><TD ALIGN="LEFT" >+ takeSnapshot()</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

MessageIdData297559756[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)MessageIdData</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   _ackSetsCount: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _bitField0: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _cachedSize: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _parsedBuffer: ByteBuf [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   ackSets: long[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   batchIndex: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   batchSize: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   entryId: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   firstChunkMessageId: MessageIdData [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   ledgerId: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   partition: int [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ addAckSet(ackSet: long)</TD></TR>
<TR><TD ALIGN="LEFT" >- checkRequiredFields()</TD></TR>
<TR><TD ALIGN="LEFT" >+ clear(): MessageIdData</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearAckSet(): MessageIdData</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearBatchIndex(): MessageIdData</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearBatchSize(): MessageIdData</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearEntryId(): MessageIdData</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearFirstChunkMessageId(): MessageIdData</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearLedgerId(): MessageIdData</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearPartition(): MessageIdData</TD></TR>
<TR><TD ALIGN="LEFT" >+ copyFrom(_other: MessageIdData): MessageIdData</TD></TR>
<TR><TD ALIGN="LEFT" >+ getAckSetAt(idx: int): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(_buffer: ByteBuf, _size: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(a: byte[])</TD></TR>
<TR><TD ALIGN="LEFT" >+ setBatchIndex(batchIndex: int): MessageIdData</TD></TR>
<TR><TD ALIGN="LEFT" >+ setBatchSize(batchSize: int): MessageIdData</TD></TR>
<TR><TD ALIGN="LEFT" >+ setEntryId(entryId: long): MessageIdData</TD></TR>
<TR><TD ALIGN="LEFT" >+ setFirstChunkMessageId(): MessageIdData</TD></TR>
<TR><TD ALIGN="LEFT" >+ setLedgerId(ledgerId: long): MessageIdData</TD></TR>
<TR><TD ALIGN="LEFT" >+ setPartition(partition: int): MessageIdData</TD></TR>
<TR><TD ALIGN="LEFT" >+ toByteArray(): byte[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeTo(_b: ByteBuf): int</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

MessageIdImpl12001400[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)MessageIdImpl</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   entryId: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   ledgerId: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   partitionIndex: int [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ compareTo(o: MessageId): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ convertToMessageIdImpl(messageId: MessageId): MessageIdImpl</TD></TR>
<TR><TD ALIGN="LEFT" >+ fromByteArray(data: byte[]): MessageId</TD></TR>
<TR><TD ALIGN="LEFT" >+ fromByteArrayWithTopic(data: byte[], topicName: String): MessageId</TD></TR>
<TR><TD ALIGN="LEFT" >+ fromByteArrayWithTopic(data: byte[], topicName: TopicName): MessageId</TD></TR>
<TR><TD ALIGN="LEFT" ># messageIdCompare(ledgerId1: long, entryId1: long, partitionIndex1: int, batchIndex1: int, ledgerId2: long, entryId2: long, partitionIndex2: int, batchIndex2: int): int</TD></TR>
<TR><TD ALIGN="LEFT" ># messageIdEquals(ledgerId1: long, entryId1: long, partitionIndex1: int, batchIndex1: int, ledgerId2: long, entryId2: long, partitionIndex2: int, batchIndex2: int): boolean</TD></TR>
<TR><TD ALIGN="LEFT" ># messageIdHashCode(ledgerId: long, entryId: long, partitionIndex: int, batchIndex: int): int</TD></TR>
<TR><TD ALIGN="LEFT" ># toByteArray(batchIndex: int, batchSize: int): byte[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ toByteArray(): byte[]</TD></TR>
<TR><TD ALIGN="LEFT" ># writeMessageIdData(msgId: MessageIdData, batchIndex: int, batchSize: int): MessageIdData</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

MessageImpl12001400[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)MessageImpl&lt;T&gt;</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   brokerEntryMetadata: BrokerEntryMetadata [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   cnx: ClientCnx [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   consumerEpoch: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   encryptionCtx: Optional&lt;EncryptionContext&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   messageId: MessageId [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   msgMetadata: MessageMetadata [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   payload: ByteBuf [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   poolMessage: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   properties: Map&lt;String, String&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   recyclerHandle: Handle&lt;MessageImpl&lt;?&gt;&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   redeliveryCount: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   schema: Schema&lt;T&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   schemaInfoForReplicator: SchemaInfo [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   schemaState: SchemaState [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   topic: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   uncompressedSize: int [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ create(msgMetadata: MessageMetadata, payload: ByteBuffer, schema: Schema&lt;T&gt;, topic: String): MessageImpl&lt;T&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ create(topic: String, messageId: MessageIdImpl, msgMetadata: MessageMetadata, payload: ByteBuf, encryptionCtx: Optional&lt;EncryptionContext&gt;, cnx: ClientCnx, schema: Schema&lt;T&gt;, redeliveryCount: int, pooledMessage: boolean, consumerEpoch: long): MessageImpl&lt;T&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ create(topic: String, batchMessageIdImpl: BatchMessageIdImpl, batchMetadata: MessageMetadata, singleMessageMetadata: SingleMessageMetadata, payload: ByteBuf, encryptionCtx: Optional&lt;EncryptionContext&gt;, cnx: ClientCnx, schema: Schema&lt;T&gt;, redeliveryCount: int, pooledMessage: boolean, consumerEpoch: long): MessageImpl&lt;T&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- decode(schemaVersion: byte[]): T</TD></TR>
<TR><TD ALIGN="LEFT" >+ deserialize(headersAndPayload: ByteBuf): MessageImpl&lt;byte[]&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ deserializeSkipBrokerEntryMetaData(headersAndPayloadWithBrokerEntryMetadata: ByteBuf): MessageImpl&lt;byte[]&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- ensureSchemaIsLoaded()</TD></TR>
<TR><TD ALIGN="LEFT" >+ getProperty(name: String): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ hasProperty(name: String): boolean</TD></TR>
<TR><TD ALIGN="LEFT" ># init(msg: MessageImpl&lt;T&gt;, topic: String, messageId: MessageIdImpl, msgMetadata: MessageMetadata, payload: ByteBuf, encryptionCtx: Optional&lt;EncryptionContext&gt;, cnx: ClientCnx, schema: Schema&lt;T&gt;, redeliveryCount: int, poolMessage: boolean, consumerEpoch: long)</TD></TR>
<TR><TD ALIGN="LEFT" >- init(msg: MessageImpl&lt;T&gt;, topic: String, batchMessageIdImpl: BatchMessageIdImpl, msgMetadata: MessageMetadata, singleMessageMetadata: SingleMessageMetadata, payload: ByteBuf, encryptionCtx: Optional&lt;EncryptionContext&gt;, cnx: ClientCnx, schema: Schema&lt;T&gt;, redeliveryCount: int, poolMessage: boolean, consumerEpoch: long)</TD></TR>
<TR><TD ALIGN="LEFT" >+ isEntryExpired(messageTTLInSeconds: int, entryTimestamp: long): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ isEntryPublishedEarlierThan(entryTimestamp: long, timestamp: long): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ isExpired(messageTTLInSeconds: int): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ recycle()</TD></TR>
<TR><TD ALIGN="LEFT" >+ release()</TD></TR>
<TR><TD ALIGN="LEFT" >+ size(): int</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

MessageMetadata297559756[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)MessageMetadata</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   _bitField0: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _cachedSize: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _encryptionAlgoBufferIdx: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _encryptionAlgoBufferLen: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _encryptionKeysCount: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _encryptionParamIdx: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _encryptionParamLen: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _orderingKeyIdx: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _orderingKeyLen: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _parsedBuffer: ByteBuf [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _partitionKeyBufferIdx: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _partitionKeyBufferLen: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _producerNameBufferIdx: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _producerNameBufferLen: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _propertiesCount: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _replicateTosCount: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _replicatedFromBufferIdx: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _replicatedFromBufferLen: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _schemaVersionIdx: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _schemaVersionLen: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _uuidBufferIdx: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _uuidBufferLen: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   chunkId: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   compression: CompressionType [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   deliverAtTime: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   encryptionAlgo: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   encryptionKeys: List&lt;EncryptionKeys&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   encryptionParam: ByteBuf [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   eventTime: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   highestSequenceId: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   markerType: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   nullPartitionKey: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   nullValue: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   numChunksFromMsg: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   numMessagesInBatch: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   orderingKey: ByteBuf [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   partitionKey: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   partitionKeyB64Encoded: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   producerName: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   properties: List&lt;KeyValue&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   publishTime: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   replicateTos: List&lt;StringHolder&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   replicatedFrom: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   schemaVersion: ByteBuf [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   sequenceId: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   totalChunkMsgSize: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   txnidLeastBits: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   txnidMostBits: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   uncompressedSize: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   uuid: String [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- _newReplicateToStringHolder(): StringHolder</TD></TR>
<TR><TD ALIGN="LEFT" >+ addAllEncryptionKeys(encryptionKeys: Iterable&lt;EncryptionKeys&gt;): MessageMetadata</TD></TR>
<TR><TD ALIGN="LEFT" >+ addAllProperties(properties: Iterable&lt;KeyValue&gt;): MessageMetadata</TD></TR>
<TR><TD ALIGN="LEFT" >+ addAllReplicateTos(replicateTos: Iterable&lt;String&gt;): MessageMetadata</TD></TR>
<TR><TD ALIGN="LEFT" >+ addEncryptionKey(): EncryptionKeys</TD></TR>
<TR><TD ALIGN="LEFT" >+ addProperty(): KeyValue</TD></TR>
<TR><TD ALIGN="LEFT" >+ addReplicateTo(replicateTo: String)</TD></TR>
<TR><TD ALIGN="LEFT" >- checkRequiredFields()</TD></TR>
<TR><TD ALIGN="LEFT" >+ clear(): MessageMetadata</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearChunkId(): MessageMetadata</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearCompression(): MessageMetadata</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearDeliverAtTime(): MessageMetadata</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearEncryptionAlgo(): MessageMetadata</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearEncryptionKeys(): MessageMetadata</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearEncryptionParam(): MessageMetadata</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearEventTime(): MessageMetadata</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearHighestSequenceId(): MessageMetadata</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearMarkerType(): MessageMetadata</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearNullPartitionKey(): MessageMetadata</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearNullValue(): MessageMetadata</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearNumChunksFromMsg(): MessageMetadata</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearNumMessagesInBatch(): MessageMetadata</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearOrderingKey(): MessageMetadata</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearPartitionKey(): MessageMetadata</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearPartitionKeyB64Encoded(): MessageMetadata</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearProducerName(): MessageMetadata</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearProperties(): MessageMetadata</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearPublishTime(): MessageMetadata</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearReplicateTo(): MessageMetadata</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearReplicatedFrom(): MessageMetadata</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearSchemaVersion(): MessageMetadata</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearSequenceId(): MessageMetadata</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearTotalChunkMsgSize(): MessageMetadata</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearTxnidLeastBits(): MessageMetadata</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearTxnidMostBits(): MessageMetadata</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearUncompressedSize(): MessageMetadata</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearUuid(): MessageMetadata</TD></TR>
<TR><TD ALIGN="LEFT" >+ copyFrom(_other: MessageMetadata): MessageMetadata</TD></TR>
<TR><TD ALIGN="LEFT" >+ getEncryptionKeyAt(idx: int): EncryptionKeys</TD></TR>
<TR><TD ALIGN="LEFT" >+ getPropertyAt(idx: int): KeyValue</TD></TR>
<TR><TD ALIGN="LEFT" >+ getReplicateToAt(idx: int): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(_buffer: ByteBuf, _size: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(a: byte[])</TD></TR>
<TR><TD ALIGN="LEFT" >+ setChunkId(chunkId: int): MessageMetadata</TD></TR>
<TR><TD ALIGN="LEFT" >+ setCompression(compression: CompressionType): MessageMetadata</TD></TR>
<TR><TD ALIGN="LEFT" >+ setDeliverAtTime(deliverAtTime: long): MessageMetadata</TD></TR>
<TR><TD ALIGN="LEFT" >+ setEncryptionAlgo(encryptionAlgo: String): MessageMetadata</TD></TR>
<TR><TD ALIGN="LEFT" >+ setEncryptionParam(encryptionParam: byte[]): MessageMetadata</TD></TR>
<TR><TD ALIGN="LEFT" >+ setEncryptionParam(encryptionParam: ByteBuf): MessageMetadata</TD></TR>
<TR><TD ALIGN="LEFT" >+ setEventTime(eventTime: long): MessageMetadata</TD></TR>
<TR><TD ALIGN="LEFT" >+ setHighestSequenceId(highestSequenceId: long): MessageMetadata</TD></TR>
<TR><TD ALIGN="LEFT" >+ setMarkerType(markerType: int): MessageMetadata</TD></TR>
<TR><TD ALIGN="LEFT" >+ setNullPartitionKey(nullPartitionKey: boolean): MessageMetadata</TD></TR>
<TR><TD ALIGN="LEFT" >+ setNullValue(nullValue: boolean): MessageMetadata</TD></TR>
<TR><TD ALIGN="LEFT" >+ setNumChunksFromMsg(numChunksFromMsg: int): MessageMetadata</TD></TR>
<TR><TD ALIGN="LEFT" >+ setNumMessagesInBatch(numMessagesInBatch: int): MessageMetadata</TD></TR>
<TR><TD ALIGN="LEFT" >+ setOrderingKey(orderingKey: byte[]): MessageMetadata</TD></TR>
<TR><TD ALIGN="LEFT" >+ setOrderingKey(orderingKey: ByteBuf): MessageMetadata</TD></TR>
<TR><TD ALIGN="LEFT" >+ setPartitionKey(partitionKey: String): MessageMetadata</TD></TR>
<TR><TD ALIGN="LEFT" >+ setPartitionKeyB64Encoded(partitionKeyB64Encoded: boolean): MessageMetadata</TD></TR>
<TR><TD ALIGN="LEFT" >+ setProducerName(producerName: String): MessageMetadata</TD></TR>
<TR><TD ALIGN="LEFT" >+ setPublishTime(publishTime: long): MessageMetadata</TD></TR>
<TR><TD ALIGN="LEFT" >+ setReplicatedFrom(replicatedFrom: String): MessageMetadata</TD></TR>
<TR><TD ALIGN="LEFT" >+ setSchemaVersion(schemaVersion: byte[]): MessageMetadata</TD></TR>
<TR><TD ALIGN="LEFT" >+ setSchemaVersion(schemaVersion: ByteBuf): MessageMetadata</TD></TR>
<TR><TD ALIGN="LEFT" >+ setSequenceId(sequenceId: long): MessageMetadata</TD></TR>
<TR><TD ALIGN="LEFT" >+ setTotalChunkMsgSize(totalChunkMsgSize: int): MessageMetadata</TD></TR>
<TR><TD ALIGN="LEFT" >+ setTxnidLeastBits(txnidLeastBits: long): MessageMetadata</TD></TR>
<TR><TD ALIGN="LEFT" >+ setTxnidMostBits(txnidMostBits: long): MessageMetadata</TD></TR>
<TR><TD ALIGN="LEFT" >+ setUncompressedSize(uncompressedSize: int): MessageMetadata</TD></TR>
<TR><TD ALIGN="LEFT" >+ setUuid(uuid: String): MessageMetadata</TD></TR>
<TR><TD ALIGN="LEFT" >+ toByteArray(): byte[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeTo(_b: ByteBuf): int</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

MessagePayloadContextImpl12001400[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)MessagePayloadContextImpl</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   ackBitSet: BitSetRecyclable [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   acker: BatchMessageAcker [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   brokerEntryMetadata: BrokerEntryMetadata [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   consumer: ConsumerImpl&lt;?&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   consumerEpoch: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   messageId: MessageIdImpl [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   messageMetadata: MessageMetadata [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   recyclerHandle: Handle&lt;MessagePayloadContextImpl&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   redeliveryCount: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   singleMessageMetadata: SingleMessageMetadata [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ asSingleMessage(payload: MessagePayload, schema: Schema&lt;T&gt;): Message&lt;T&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ get(brokerEntryMetadata: BrokerEntryMetadata, messageMetadata: MessageMetadata, messageId: MessageIdImpl, consumer: ConsumerImpl&lt;?&gt;, redeliveryCount: int, ackSet: List&lt;Long&gt;, consumerEpoch: long): MessagePayloadContextImpl</TD></TR>
<TR><TD ALIGN="LEFT" >+ getMessageAt(index: int, numMessages: int, payload: MessagePayload, containMetadata: boolean, schema: Schema&lt;T&gt;): Message&lt;T&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getProperty(key: String): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ recycle()</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

MessagePublishContext1660348955[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)MessagePublishContext</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   batchSize: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   chunked: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   entryId: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   highestSequenceId: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   isMarker: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   ledgerId: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   msgSize: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   originalHighestSequenceId: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   originalProducerName: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   originalSequenceId: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   producer: Producer [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   propertyMap: Map&lt;String, Object&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   rateIn: Rate [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   recyclerHandle: Handle&lt;MessagePublishContext&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   sequenceId: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   startTimeNs: long [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ completed(exception: Exception, ledgerId: long, entryId: long)</TD></TR>
<TR><TD ALIGN="LEFT" ># get(producer: Producer, sequenceId: long, rateIn: Rate, msgSize: int, batchSize: long, chunked: boolean, startTimeNs: long, isMarker: boolean): MessagePublishContext</TD></TR>
<TR><TD ALIGN="LEFT" ># get(producer: Producer, lowestSequenceId: long, highestSequenceId: long, rateIn: Rate, msgSize: int, batchSize: long, chunked: boolean, startTimeNs: long, isMarker: boolean): MessagePublishContext</TD></TR>
<TR><TD ALIGN="LEFT" >+ getProperty(propertyName: String): Object</TD></TR>
<TR><TD ALIGN="LEFT" >- getServerError(exception: Exception): ServerError</TD></TR>
<TR><TD ALIGN="LEFT" >+ recycle()</TD></TR>
<TR><TD ALIGN="LEFT" >+ run()</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

MessagesImpl12001400[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)MessagesImpl&lt;T&gt;</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   currentNumberOfMessages: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   currentSizeOfMessages: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   maxNumberOfMessages: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   maxSizeOfMessages: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   messageList: List&lt;Message&lt;T&gt;&gt; [0..*]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># add(message: Message&lt;T&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" ># canAdd(message: Message&lt;T&gt;): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ clear()</TD></TR>
<TR><TD ALIGN="LEFT" >+ iterator(): Iterator&lt;Message&lt;T&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ size(): int</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

Metadata1973581360[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)Metadata</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ validateMetadata(metadata: Map&lt;String, String&gt;)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

MetadataCacheImpl738260656[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)MetadataCacheImpl&lt;T&gt;</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   objCache: AsyncLoadingCache&lt;String, Optional&lt;CacheGetResult&lt;T&gt;&gt;&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   serde: MetadataSerde&lt;T&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   store: MetadataStore [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ accept(t: Notification)</TD></TR>
<TR><TD ALIGN="LEFT" >+ create(path: String, value: T): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ delete(path: String): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- executeWithRetry(op: Supplier&lt;CompletableFuture&lt;T&gt;&gt;, key: String): CompletableFuture&lt;T&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ exists(path: String): CompletableFuture&lt;Boolean&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ get(path: String): CompletableFuture&lt;Optional&lt;T&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getChildren(path: String): CompletableFuture&lt;List&lt;String&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getIfCached(path: String): Optional&lt;T&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getWithStats(path: String): CompletableFuture&lt;Optional&lt;CacheGetResult&lt;T&gt;&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ invalidate(path: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ invalidateAll()</TD></TR>
<TR><TD ALIGN="LEFT" >+ readModifyUpdate(path: String, modifyFunction: Function&lt;T, T&gt;): CompletableFuture&lt;T&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ readModifyUpdateOrCreate(path: String, modifyFunction: Function&lt;Optional&lt;T&gt;, T&gt;): CompletableFuture&lt;T&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- readValueFromStore(path: String): CompletableFuture&lt;Optional&lt;CacheGetResult&lt;T&gt;&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ refresh(path: String)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

MetadataStoreException845397418[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)MetadataStoreException</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ unwrap(t: Throwable): MetadataStoreException</TD></TR>
<TR><TD ALIGN="LEFT" >+ wrap(t: Throwable): MetadataStoreException</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

MetadataStoreFactoryImpl437280412[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)MetadataStoreFactoryImpl</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ create(metadataURL: String, metadataStoreConfig: MetadataStoreConfig): MetadataStore</TD></TR>
<TR><TD ALIGN="LEFT" >+ createExtended(metadataURL: String, metadataStoreConfig: MetadataStoreConfig): MetadataStoreExtended</TD></TR>
<TR><TD ALIGN="LEFT" >- newInstance(metadataURL: String, metadataStoreConfig: MetadataStoreConfig, enableSessionWatcher: boolean): MetadataStore</TD></TR>
<TR><TD ALIGN="LEFT" >+ removeIdentifierFromMetadataURL(metadataURL: String): String</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

Metrics1188434519[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)Metrics</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   dimensions: Map&lt;String, String&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >#   metrics: Map&lt;String, Object&gt; [0..*]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ create(dimensionMap: Map&lt;String, String&gt;): Metrics</TD></TR>
<TR><TD ALIGN="LEFT" >+ getDimension(dimensionName: String): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ put(metricsName: String, value: Object)</TD></TR>
<TR><TD ALIGN="LEFT" >+ putAll(metrics: Map&lt;String, Object&gt;)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

ModularLoadManagerImpl109292786[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)ModularLoadManagerImpl</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   brokerCandidateCache: Set&lt;String&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   brokerDataLock: ResourceLock&lt;LocalBrokerData&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   brokerHostUsage: BrokerHostUsage [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   brokerToFailureDomainMap: Map&lt;String, String&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   brokerToNamespaceToBundleRange: ConcurrentOpenHashMap&lt;String, ConcurrentOpenHashMap&lt;String, ConcurrentOpenHashSet&lt;String&gt;&gt;&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   brokerTopicLoadingPredicate: BrokerTopicLoadingPredicate [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   brokerZnodePath: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   brokersData: LockManager&lt;LocalBrokerData&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   bundleMetrics: AtomicReference&lt;List&lt;Metrics&gt;&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   bundleSplitCount: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   bundleSplitMetrics: AtomicReference&lt;List&lt;Metrics&gt;&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   bundleSplitStrategy: BundleSplitStrategy [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   bundleUnloadMetrics: AtomicReference&lt;List&lt;Metrics&gt;&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   bundlesCache: MetadataCache&lt;BundleData&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   conf: ServiceConfiguration [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   defaultStats: NamespaceBundleStats [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   filterPipeline: List&lt;BrokerFilter&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   lastBundleDataUpdate: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   lastData: LocalBrokerData [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   lastMetadataSessionEvent: SessionEvent [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   loadBalancingMetrics: AtomicReference&lt;List&lt;Metrics&gt;&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   loadData: LoadData [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   loadSheddingPipeline: List&lt;LoadSheddingStrategy&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   localData: LocalBrokerData [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   lock: Lock [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   placementStrategy: ModularLoadManagerStrategy [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   policies: SimpleResourceAllocationPolicies [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   preallocatedBundleToBroker: Map&lt;String, String&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   pulsar: PulsarService [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   resourceQuotaCache: MetadataCache&lt;ResourceQuota&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   scheduler: ScheduledExecutorService [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   timeAverageBrokerDataCache: MetadataCache&lt;TimeAverageBrokerData&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   unloadBrokerCount: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   unloadBundleCount: long [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ checkNamespaceBundleSplit()</TD></TR>
<TR><TD ALIGN="LEFT" >- createLoadSheddingStrategy(): LoadSheddingStrategy</TD></TR>
<TR><TD ALIGN="LEFT" >- deleteBundleDataFromMetadataStore(bundle: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ disableBroker()</TD></TR>
<TR><TD ALIGN="LEFT" >+ doLoadShedding()</TD></TR>
<TR><TD ALIGN="LEFT" >+ getBrokerLocalData(broker: String): LocalBrokerData</TD></TR>
<TR><TD ALIGN="LEFT" >+ getBundleDataOrDefault(bundle: String): BundleData</TD></TR>
<TR><TD ALIGN="LEFT" >+ getBundleDataPath(bundle: String): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ handleDataNotification(t: Notification)</TD></TR>
<TR><TD ALIGN="LEFT" >- handleMetadataSessionEvent(e: SessionEvent)</TD></TR>
<TR><TD ALIGN="LEFT" >+ initialize(pulsar: PulsarService)</TD></TR>
<TR><TD ALIGN="LEFT" >- needBrokerDataUpdate(): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >- percentChange(oldValue: double, newValue: double): double</TD></TR>
<TR><TD ALIGN="LEFT" >- reapDeadBrokerPreallocations(aliveBrokers: List&lt;String&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >- refreshBrokerToFailureDomainMap()</TD></TR>
<TR><TD ALIGN="LEFT" >+ selectBrokerForAssignment(serviceUnit: ServiceUnitId): Optional&lt;String&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ shouldAntiAffinityNamespaceUnload(namespace: String, bundle: String, currentBroker: String): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ start()</TD></TR>
<TR><TD ALIGN="LEFT" >+ stop()</TD></TR>
<TR><TD ALIGN="LEFT" >+ updateAll()</TD></TR>
<TR><TD ALIGN="LEFT" >- updateAllBrokerData()</TD></TR>
<TR><TD ALIGN="LEFT" >- updateBundleData()</TD></TR>
<TR><TD ALIGN="LEFT" >- updateBundleSplitMetrics(bundlesToBeSplit: Set&lt;String&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >- updateBundleUnloadingMetrics(bundlesToUnload: Multimap&lt;String, String&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >- updateLoadBalancingBundlesMetrics(bundlesData: Map&lt;String, NamespaceBundleStats&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >- updateLoadBalancingMetrics(systemResourceUsage: SystemResourceUsage)</TD></TR>
<TR><TD ALIGN="LEFT" >+ updateLocalBrokerData(): LocalBrokerData</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeBrokerDataOnZooKeeper()</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeBrokerDataOnZooKeeper(force: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeBundleDataOnZooKeeper()</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

ModularLoadManagerWrapper109292786[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)ModularLoadManagerWrapper</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   loadManager: ModularLoadManager [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ disableBroker()</TD></TR>
<TR><TD ALIGN="LEFT" >+ doLoadShedding()</TD></TR>
<TR><TD ALIGN="LEFT" >+ doNamespaceBundleSplit()</TD></TR>
<TR><TD ALIGN="LEFT" >+ generateLoadReport(): LoadManagerReport</TD></TR>
<TR><TD ALIGN="LEFT" >- getBrokerWebServiceUrl(broker: String): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ getLeastLoaded(serviceUnit: ServiceUnitId): Optional&lt;ResourceUnit&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ initialize(pulsar: PulsarService)</TD></TR>
<TR><TD ALIGN="LEFT" >+ start()</TD></TR>
<TR><TD ALIGN="LEFT" >+ stop()</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeLoadReportOnZookeeper()</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeLoadReportOnZookeeper(force: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeResourceQuotasToZooKeeper()</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

MultiConsumerPulsarSource1430540343[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)MultiConsumerPulsarSource&lt;T&gt;</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   functionClassLoader: ClassLoader [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   inputConsumers: List&lt;Consumer&lt;T&gt;&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   pulsarSourceConfig: MultiConsumerPulsarSourceConfig [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ open(config: Map&lt;String, Object&gt;, sourceContext: SourceContext)</TD></TR>
<TR><TD ALIGN="LEFT" >+ received(consumer: Consumer&lt;T&gt;, message: Message&lt;T&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >- setupConsumerConfigs(): Map&lt;String, PulsarSourceConsumerConfig&lt;T&gt;&gt;</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

MultiMessageIdImpl12001400[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)MultiMessageIdImpl</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   map: Map&lt;String, MessageId&gt; [0..*]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ compareTo(o: MessageId): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ toByteArray(): byte[]</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

MultiTopicsConsumerImpl12001400[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)MultiTopicsConsumerImpl&lt;T&gt;</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   allTopicPartitionsNumber: AtomicInteger [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   consumers: ConcurrentHashMap&lt;String, ConsumerImpl&lt;T&gt;&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   internalConfig: ConsumerConfigurationData&lt;T&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   lock: ReadWriteLock [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   partitionedTopics: ConcurrentHashMap&lt;String, Integer&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >#   partitionsAutoUpdateFuture: CompletableFuture&lt;Void&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   partitionsAutoUpdateTimeout: Timeout [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   partitionsAutoUpdateTimerTask: TimerTask [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   pauseMutex: Object [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   paused: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   pausedConsumers: ConcurrentLinkedQueue&lt;ConsumerImpl&lt;T&gt;&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   sharedQueueResumeThreshold: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   startMessageId: BatchMessageIdImpl [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   startMessageRollbackDurationInSec: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   stats: ConsumerStatsRecorder [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   topicsPartitionChangedListener: TopicsPartitionChangedListener [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   unAckedMessageTracker: UnAckedMessageTracker [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- cleanupMultiConsumer()</TD></TR>
<TR><TD ALIGN="LEFT" >+ closeAsync(): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># completeOpBatchReceive(op: OpBatchReceive&lt;T&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ createPartitionedConsumer(client: PulsarClientImpl, conf: ConsumerConfigurationData&lt;T&gt;, executorProvider: ExecutorProvider, subscribeFuture: CompletableFuture&lt;Consumer&lt;T&gt;&gt;, numPartitions: int, schema: Schema&lt;T&gt;, interceptors: ConsumerInterceptors&lt;T&gt;): MultiTopicsConsumerImpl&lt;T&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># doAcknowledge(messageId: MessageId, ackType: AckType, properties: Map&lt;String, Long&gt;, txnImpl: TransactionImpl): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># doAcknowledge(messageIdList: List&lt;MessageId&gt;, ackType: AckType, properties: Map&lt;String, Long&gt;, txn: TransactionImpl): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># doReconsumeLater(message: Message&lt;?&gt;, ackType: AckType, customProperties: Map&lt;String, String&gt;, delayTime: long, unit: TimeUnit): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- doSubscribeTopicPartitions(schema: Schema&lt;T&gt;, subscribeResult: CompletableFuture&lt;Void&gt;, topicName: String, numPartitions: int, createIfDoesNotExist: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >- getFullTopicName(topic: String): String</TD></TR>
<TR><TD ALIGN="LEFT" >- getTopicName(topic: String): TopicName</TD></TR>
<TR><TD ALIGN="LEFT" >- handleSubscribeOneTopicError(topicName: String, error: Throwable, subscribeFuture: CompletableFuture&lt;Void&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" ># internalBatchReceive(): Messages&lt;T&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># internalBatchReceiveAsync(): CompletableFuture&lt;Messages&lt;T&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># internalReceive(): Message&lt;T&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># internalReceive(timeout: int, unit: TimeUnit): Message&lt;T&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># internalReceiveAsync(): CompletableFuture&lt;Message&lt;T&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ isIllegalMultiTopicsMessageId(messageId: MessageId): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >- isValidConsumerEpoch(message: Message&lt;T&gt;): boolean</TD></TR>
<TR><TD ALIGN="LEFT" ># messageProcessed(msg: Message&lt;?&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >- messageReceived(consumer: ConsumerImpl&lt;T&gt;, message: Message&lt;T&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ negativeAcknowledge(messageId: MessageId)</TD></TR>
<TR><TD ALIGN="LEFT" >+ negativeAcknowledge(message: Message&lt;?&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ numMessagesInQueue(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ pause()</TD></TR>
<TR><TD ALIGN="LEFT" >- receiveMessageFromConsumer(consumer: ConsumerImpl&lt;T&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ redeliverUnacknowledgedMessages()</TD></TR>
<TR><TD ALIGN="LEFT" >+ redeliverUnacknowledgedMessages(messageIds: Set&lt;MessageId&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ removeConsumerAsync(topicName: String): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- removeExpiredMessagesFromQueue(messageIds: Set&lt;MessageId&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >- removeTopic(topic: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ resume()</TD></TR>
<TR><TD ALIGN="LEFT" >- resumeReceivingFromPausedConsumersIfNeeded()</TD></TR>
<TR><TD ALIGN="LEFT" >+ seek(messageId: MessageId)</TD></TR>
<TR><TD ALIGN="LEFT" >+ seek(timestamp: long)</TD></TR>
<TR><TD ALIGN="LEFT" >+ seek(function: Function&lt;String, Object&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ seekAsync(function: Function&lt;String, Object&gt;): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ seekAsync(messageId: MessageId): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ seekAsync(timestamp: long): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- startReceivingMessages(newConsumers: List&lt;ConsumerImpl&lt;T&gt;&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ subscribeAsync(topicName: String, createTopicIfDoesNotExist: boolean): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># subscribeAsync(topicName: String, numberPartitions: int): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- subscribeIncreasedTopicPartitions(topicName: String): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- subscribeTopicPartitions(subscribeResult: CompletableFuture&lt;Void&gt;, topicName: String, numPartitions: int, createIfDoesNotExist: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >- topicNamesValid(topics: Collection&lt;String&gt;): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ tryAcknowledgeMessage(msg: Message&lt;T&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ unsubscribeAsync(): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ unsubscribeAsync(topicName: String): CompletableFuture&lt;Void&gt;</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

MultiTopicsReaderImpl12001400[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)MultiTopicsReaderImpl&lt;T&gt;</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   multiTopicsConsumer: MultiTopicsConsumerImpl&lt;T&gt; [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ closeAsync(): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ readNext(): Message&lt;T&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ readNext(timeout: int, unit: TimeUnit): Message&lt;T&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ readNextAsync(): CompletableFuture&lt;Message&lt;T&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ seek(messageId: MessageId)</TD></TR>
<TR><TD ALIGN="LEFT" >+ seek(timestamp: long)</TD></TR>
<TR><TD ALIGN="LEFT" >+ seek(function: Function&lt;String, Object&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ seekAsync(messageId: MessageId): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ seekAsync(timestamp: long): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ seekAsync(function: Function&lt;String, Object&gt;): CompletableFuture&lt;Void&gt;</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

MultiVersionGenericProtobufNativeReader75672144[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)MultiVersionGenericProtobufNativeReader</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   descriptor: Descriptor [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   schemaInfo: SchemaInfo [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   useProvidedSchemaAsReaderSchema: boolean [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># loadReader(schemaVersion: BytesSchemaVersion): SchemaReader&lt;GenericRecord&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># parseProtobufSchema(schemaInfo: SchemaInfo): Descriptor</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

MultiVersionSchemaInfoProvider75672144[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)MultiVersionSchemaInfoProvider</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   cache: LoadingCache&lt;BytesSchemaVersion, CompletableFuture&lt;SchemaInfo&gt;&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   pulsarClient: PulsarClientImpl [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   topicName: TopicName [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ getSchemaByVersion(schemaVersion: byte[]): CompletableFuture&lt;SchemaInfo&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- loadSchema(schemaVersion: byte[]): CompletableFuture&lt;SchemaInfo&gt;</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

NamedEntity1973581360[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)NamedEntity</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ checkName(name: String)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

NamespaceBundle1973581360[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)NamespaceBundle</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   bundleRange: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   factory: NamespaceBundleFactory [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   hasNonPersistentTopic: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   key: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   keyRange: Range&lt;Long&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   nsname: NamespaceName [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ compareTo(other: NamespaceBundle): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ getBundleNamespace(namespaceBundle: String): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ getBundleRange(namespaceBundle: String): String</TD></TR>
<TR><TD ALIGN="LEFT" >- getKey(nsname: NamespaceName, keyRange: Range&lt;Long&gt;): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ includes(topicName: TopicName): boolean</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

NamespaceBundleFactory1973581360[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)NamespaceBundleFactory</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   bundlesCache: AsyncLoadingCache&lt;NamespaceName, NamespaceBundles&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   hashFunc: HashFunction [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   maxRetryDuration: Duration [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   policiesCache: MetadataCache&lt;Policies&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   pulsar: PulsarService [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ canSplitBundle(bundle: NamespaceBundle): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >- copyToLocalPolicies(namespace: NamespaceName): CompletableFuture&lt;NamespaceBundles&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- createBackoff(): Backoff</TD></TR>
<TR><TD ALIGN="LEFT" >+ createFactory(pulsar: PulsarService, hashFunc: HashFunction): NamespaceBundleFactory</TD></TR>
<TR><TD ALIGN="LEFT" >- doLoadBundles(namespace: NamespaceName, future: CompletableFuture&lt;NamespaceBundles&gt;, backoff: Backoff, retryDeadline: long)</TD></TR>
<TR><TD ALIGN="LEFT" >+ getBundle(topic: TopicName): NamespaceBundle</TD></TR>
<TR><TD ALIGN="LEFT" >+ getBundle(nsname: NamespaceName, hashRange: Range&lt;Long&gt;): NamespaceBundle</TD></TR>
<TR><TD ALIGN="LEFT" >+ getBundle(namespace: String, bundleRange: String): NamespaceBundle</TD></TR>
<TR><TD ALIGN="LEFT" >+ getBundleWithHighestThroughput(nsName: NamespaceName): NamespaceBundle</TD></TR>
<TR><TD ALIGN="LEFT" >+ getBundleWithHighestTopics(nsname: NamespaceName): NamespaceBundle</TD></TR>
<TR><TD ALIGN="LEFT" >+ getBundleWithHighestTopicsAsync(nsname: NamespaceName): CompletableFuture&lt;NamespaceBundle&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getBundles(nsname: NamespaceName): NamespaceBundles</TD></TR>
<TR><TD ALIGN="LEFT" >+ getBundles(nsname: NamespaceName, bundleData: BundlesData): NamespaceBundles</TD></TR>
<TR><TD ALIGN="LEFT" >- getBundles(nsname: NamespaceName, localPolicies: Optional&lt;Pair&lt;LocalPolicies, Long&gt;&gt;): NamespaceBundles</TD></TR>
<TR><TD ALIGN="LEFT" >+ getBundlesAsync(nsname: NamespaceName): CompletableFuture&lt;NamespaceBundles&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getBundlesIfPresent(nsname: NamespaceName): Optional&lt;NamespaceBundles&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getFullBundle(fqnn: NamespaceName): NamespaceBundle</TD></TR>
<TR><TD ALIGN="LEFT" >+ getFullBundleAsync(fqnn: NamespaceName): CompletableFuture&lt;NamespaceBundle&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getLongHashCode(name: String): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ getNamespaceFromPoliciesPath(path: String): String</TD></TR>
<TR><TD ALIGN="LEFT" >- handleLoadBundlesRetry(namespace: NamespaceName, future: CompletableFuture&lt;NamespaceBundles&gt;, backoff: Backoff, retryDeadline: long, e: Throwable)</TD></TR>
<TR><TD ALIGN="LEFT" >- handleMetadataStoreNotification(n: Notification)</TD></TR>
<TR><TD ALIGN="LEFT" >+ invalidateBundleCache(namespace: NamespaceName)</TD></TR>
<TR><TD ALIGN="LEFT" >+ isFullBundle(bundleRange: String): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >- loadBundles(namespace: NamespaceName, executor: Executor): CompletableFuture&lt;NamespaceBundles&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- readBundles(namespace: NamespaceName, localPolicies: LocalPolicies, version: long): NamespaceBundles</TD></TR>
<TR><TD ALIGN="LEFT" >+ splitBundles(targetBundle: NamespaceBundle, argNumBundles: int, splitBoundary: Long): CompletableFuture&lt;Pair&lt;NamespaceBundles, List&lt;NamespaceBundle&gt;&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ validateFullRange(partitions: SortedSet&lt;String&gt;)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

NamespaceBundleStats842356003[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)NamespaceBundleStats</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+   cacheSize: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   consumerCount: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   msgRateIn: double [1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   msgRateOut: double [1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   msgThroughputIn: double [1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   msgThroughputOut: double [1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   producerCount: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   topics: long [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># canEqual(other: Object): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ compareByBandwidthIn(other: NamespaceBundleStats): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ compareByBandwidthOut(other: NamespaceBundleStats): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ compareByCacheSize(other: NamespaceBundleStats): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ compareByMsgRate(other: NamespaceBundleStats): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ compareByTopicConnections(other: NamespaceBundleStats): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ compareTo(other: NamespaceBundleStats): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ reset()</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

NamespaceBundles1973581360[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)NamespaceBundles</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   bundles: ArrayList&lt;NamespaceBundle&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   factory: NamespaceBundleFactory [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   fullBundle: NamespaceBundle [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   localPolicies: Optional&lt;Pair&lt;LocalPolicies, Long&gt;&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   nsname: NamespaceName [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   partitions: long[] [0..*]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- convertPartitions(partitionsSet: SortedSet&lt;Long&gt;): long[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ findBundle(topicName: TopicName): NamespaceBundle</TD></TR>
<TR><TD ALIGN="LEFT" ># getBundle(hash: long): NamespaceBundle</TD></TR>
<TR><TD ALIGN="LEFT" ># getPartitions(bundlesData: BundlesData): long[]</TD></TR>
<TR><TD ALIGN="LEFT" >- getPartitions(lp: Optional&lt;LocalPolicies&gt;): long[]</TD></TR>
<TR><TD ALIGN="LEFT" >- getPartitions(partitions: Collection&lt;Long&gt;): long[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ size(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ toLocalPolicies(): LocalPolicies</TD></TR>
<TR><TD ALIGN="LEFT" >+ validateBundle(nsBundle: NamespaceBundle)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

NamespaceEventsSystemTopicFactory1970406500[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)NamespaceEventsSystemTopicFactory</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   client: PulsarClient [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ createTopicPoliciesSystemTopicClient(namespaceName: NamespaceName): TopicPoliciesSystemTopicClient</TD></TR>
<TR><TD ALIGN="LEFT" >+ createTransactionBufferSystemTopicClient(namespaceName: NamespaceName, transactionBufferSnapshotService: TransactionBufferSnapshotService): TransactionBufferSystemTopicClient</TD></TR>
<TR><TD ALIGN="LEFT" >+ getSystemTopicName(namespaceName: NamespaceName, eventType: EventType): TopicName</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

NamespaceIsolationDataImpl896442176[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)NamespaceIsolationDataImpl</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   autoFailoverPolicy: AutoFailoverPolicyData [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   namespaces: List&lt;String&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   primary: List&lt;String&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   secondary: List&lt;String&gt; [0..*]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ builder(): NamespaceIsolationDataImplBuilder</TD></TR>
<TR><TD ALIGN="LEFT" ># canEqual(other: Object): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ validate()</TD></TR>
<TR><TD ALIGN="LEFT" >- validateRegex(policies: List&lt;String&gt;): boolean</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

NamespaceIsolationPolicies896602550[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)NamespaceIsolationPolicies</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   policies: Map&lt;String, NamespaceIsolationDataImpl&gt; [0..*]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ assignBroker(nsname: NamespaceName, brkStatus: BrokerStatus, primaryCandidates: SortedSet&lt;BrokerStatus&gt;, secondaryCandidates: SortedSet&lt;BrokerStatus&gt;, sharedCandidates: SortedSet&lt;BrokerStatus&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ deletePolicy(policyName: String)</TD></TR>
<TR><TD ALIGN="LEFT" >- getBrokerAssignment(nsPolicy: NamespaceIsolationPolicy, brokerAddress: String): BrokerAssignment</TD></TR>
<TR><TD ALIGN="LEFT" >+ getPolicyByName(policyName: String): NamespaceIsolationPolicy</TD></TR>
<TR><TD ALIGN="LEFT" >+ getPolicyByNamespace(namespace: NamespaceName): NamespaceIsolationPolicy</TD></TR>
<TR><TD ALIGN="LEFT" >+ isSharedBroker(host: String): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >- namespaceMatches(namespace: NamespaceName, nsPolicyData: NamespaceIsolationData): boolean</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

NamespaceIsolationPolicyImpl896602550[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)NamespaceIsolationPolicyImpl</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   autoFailoverPolicy: AutoFailoverPolicy [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   namespaces: List&lt;String&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   primary: List&lt;String&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   secondary: List&lt;String&gt; [0..*]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ findPrimaryBrokers(availableBrokers: List&lt;URL&gt;, namespace: NamespaceName): List&lt;URL&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ findSecondaryBrokers(availableBrokers: List&lt;URL&gt;, namespace: NamespaceName): List&lt;URL&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getAvailablePrimaryBrokers(primaryCandidates: SortedSet&lt;BrokerStatus&gt;): SortedSet&lt;BrokerStatus&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- getMatchedBrokers(brkRegexList: List&lt;String&gt;, availableBrokers: List&lt;URL&gt;): List&lt;URL&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ isPrimaryBroker(broker: String): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ isPrimaryBrokerAvailable(brkStatus: BrokerStatus): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ isSecondaryBroker(broker: String): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >- matchNamespaces(fqnn: String): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >- matchesBrokerRegex(brkRegexList: List&lt;String&gt;, broker: String): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ shouldFailover(brokerStatus: SortedSet&lt;BrokerStatus&gt;): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ shouldFailover(totalPrimaryResourceUnits: int): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ shouldFallback(primaryBrokers: SortedSet&lt;BrokerStatus&gt;): boolean</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

NamespaceName1973581360[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)NamespaceName</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   cluster: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   localName: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   namespace: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   tenant: String [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ get(tenant: String, namespace: String): NamespaceName</TD></TR>
<TR><TD ALIGN="LEFT" >+ get(tenant: String, cluster: String, namespace: String): NamespaceName</TD></TR>
<TR><TD ALIGN="LEFT" >+ get(namespace: String): NamespaceName</TD></TR>
<TR><TD ALIGN="LEFT" >+ getIfValid(namespace: String): Optional&lt;NamespaceName&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getPersistentTopicName(localTopic: String): String</TD></TR>
<TR><TD ALIGN="LEFT" ># getTopicName(domain: TopicDomain, topic: String): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ includes(topicName: TopicName): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ validateNamespaceName(tenant: String, namespace: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ validateNamespaceName(tenant: String, cluster: String, namespace: String)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

NamespaceResources220376139[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)NamespaceResources</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   configurationStore: MetadataStore [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   isolationPolicies: IsolationPolicyResources [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   localPoliciesCache: MetadataCache&lt;LocalPolicies&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   partitionedTopicResources: PartitionedTopicResources [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ createPolicies(ns: NamespaceName, policies: Policies)</TD></TR>
<TR><TD ALIGN="LEFT" >+ deleteBundleDataAsync(ns: NamespaceName): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ deleteBundleDataTenantAsync(tenant: String): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ deleteNamespaceAsync(ns: NamespaceName): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ deletePolicies(ns: NamespaceName)</TD></TR>
<TR><TD ALIGN="LEFT" >+ deletePoliciesAsync(ns: NamespaceName): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ deleteTenantAsync(tenant: String): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getPolicies(ns: NamespaceName): Optional&lt;Policies&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getPoliciesAsync(ns: NamespaceName): CompletableFuture&lt;Optional&lt;Policies&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getPoliciesIfCached(ns: NamespaceName): Optional&lt;Policies&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ listNamespacesAsync(tenant: String): CompletableFuture&lt;List&lt;String&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ namespaceExists(ns: NamespaceName): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ namespaceExistsAsync(ns: NamespaceName): CompletableFuture&lt;Boolean&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ namespaceFromPath(path: String): NamespaceName</TD></TR>
<TR><TD ALIGN="LEFT" >+ pathIsFromNamespace(path: String): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ setPoliciesAsync(ns: NamespaceName, function: Function&lt;Policies, Policies&gt;): CompletableFuture&lt;Void&gt;</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

NamespaceService839302271[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)NamespaceService</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   bundleFactory: NamespaceBundleFactory [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   bundleOwnershipListeners: List&lt;NamespaceBundleOwnershipListener&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   config: ServiceConfiguration [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   findingBundlesAuthoritative: ConcurrentOpenHashMap&lt;NamespaceBundle, CompletableFuture&lt;Optional&lt;LookupResult&gt;&gt;&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   findingBundlesNotAuthoritative: ConcurrentOpenHashMap&lt;NamespaceBundle, CompletableFuture&lt;Optional&lt;LookupResult&gt;&gt;&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   host: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   loadManager: AtomicReference&lt;LoadManager&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   localBrokerDataCache: MetadataCache&lt;LocalBrokerData&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   localPoliciesCache: MetadataCache&lt;LocalPolicies&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   namespaceClients: ConcurrentOpenHashMap&lt;ClusterDataImpl, PulsarClientImpl&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   ownershipCache: OwnershipCache [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   pulsar: PulsarService [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   uncountedNamespaces: int [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ addNamespaceBundleOwnershipListener(listeners: NamespaceBundleOwnershipListener...)</TD></TR>
<TR><TD ALIGN="LEFT" >+ checkHeartbeatNamespace(ns: ServiceUnitId): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ checkHeartbeatNamespaceV2(ns: ServiceUnitId): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ checkTopicExists(topic: TopicName): CompletableFuture&lt;Boolean&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ checkTopicOwnership(topicName: TopicName): CompletableFuture&lt;Boolean&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" ># createLookupResult(candidateBroker: String, authoritativeRedirect: boolean, advertisedListenerName: String): CompletableFuture&lt;LookupResult&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- findBrokerServiceUrl(bundle: NamespaceBundle, options: LookupOptions): CompletableFuture&lt;Optional&lt;LookupResult&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getAllPartitions(namespaceName: NamespaceName): CompletableFuture&lt;List&lt;String&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getBrokerServiceUrlAsync(topic: TopicName, options: LookupOptions): CompletableFuture&lt;Optional&lt;LookupResult&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getBundle(topicName: TopicName): NamespaceBundle</TD></TR>
<TR><TD ALIGN="LEFT" >+ getBundleAsync(topic: TopicName): CompletableFuture&lt;NamespaceBundle&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getBundleCount(namespace: NamespaceName): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ getBundleIfPresent(topicName: TopicName): Optional&lt;NamespaceBundle&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- getFullBundle(fqnn: NamespaceName): NamespaceBundle</TD></TR>
<TR><TD ALIGN="LEFT" >- getFullBundleAsync(fqnn: NamespaceName): CompletableFuture&lt;NamespaceBundle&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getFullListOfTopics(namespaceName: NamespaceName): CompletableFuture&lt;List&lt;String&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getHeartbeatNamespace(host: String, config: ServiceConfiguration): NamespaceName</TD></TR>
<TR><TD ALIGN="LEFT" >+ getHeartbeatNamespaceV2(host: String, config: ServiceConfiguration): NamespaceName</TD></TR>
<TR><TD ALIGN="LEFT" >- getLeastLoadedFromLoadManager(serviceUnit: ServiceUnitId): Optional&lt;String&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getListOfNonPersistentTopics(namespaceName: NamespaceName): CompletableFuture&lt;List&lt;String&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getListOfPersistentTopics(namespaceName: NamespaceName): CompletableFuture&lt;List&lt;String&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getListOfTopics(namespaceName: NamespaceName, mode: Mode): CompletableFuture&lt;List&lt;String&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getNamespaceClient(cluster: ClusterDataImpl): PulsarClientImpl</TD></TR>
<TR><TD ALIGN="LEFT" >- getNamespaceOwnershipStatus(nsObj: OwnedBundle, nsIsolationPolicy: NamespaceIsolationPolicy): NamespaceOwnershipStatus</TD></TR>
<TR><TD ALIGN="LEFT" >- getNonPersistentTopicsFromPeerCluster(peerClusterData: ClusterDataImpl, namespace: NamespaceName): CompletableFuture&lt;List&lt;String&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getOwnedTopicListForNamespaceBundle(bundle: NamespaceBundle): CompletableFuture&lt;List&lt;String&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getOwner(bundle: NamespaceBundle): Optional&lt;NamespaceEphemeralData&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getOwnerAsync(bundle: NamespaceBundle): CompletableFuture&lt;Optional&lt;NamespaceEphemeralData&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getPartitions(namespaceName: NamespaceName, topicDomain: TopicDomain): CompletableFuture&lt;List&lt;String&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- getPartitionsForTopic(topicName: TopicName): CompletableFuture&lt;List&lt;String&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getSLAMonitorBrokerName(ns: ServiceUnitId): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ getSLAMonitorNamespace(host: String, config: ServiceConfiguration): NamespaceName</TD></TR>
<TR><TD ALIGN="LEFT" >+ getServiceUnitId(topicName: TopicName): ServiceUnitId</TD></TR>
<TR><TD ALIGN="LEFT" >+ getWebServiceUrl(suName: ServiceUnitId, options: LookupOptions): Optional&lt;URL&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getWebServiceUrlAsync(suName: ServiceUnitId, options: LookupOptions): CompletableFuture&lt;Optional&lt;URL&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ initialize()</TD></TR>
<TR><TD ALIGN="LEFT" >- internalGetWebServiceUrl(bundle: NamespaceBundle, options: LookupOptions): CompletableFuture&lt;Optional&lt;URL&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- isBrokerActive(candidateBroker: String): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ isNamespaceBundleDisabled(bundle: NamespaceBundle): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ isNamespaceBundleOwned(bundle: NamespaceBundle): CompletableFuture&lt;Boolean&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- isNamespaceOwned(fqnn: NamespaceName): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >- isNamespaceOwnedAsync(fqnn: NamespaceName): CompletableFuture&lt;Boolean&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ isServiceUnitActive(topicName: TopicName): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ isServiceUnitOwned(suName: ServiceUnitId): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ isServiceUnitOwnedAsync(suName: ServiceUnitId): CompletableFuture&lt;Boolean&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ isSystemServiceNamespace(namespace: String): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >- isTopicOwnedAsync(topic: TopicName): CompletableFuture&lt;Boolean&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- notifyNamespaceBundleOwnershipListener(bundle: NamespaceBundle, listeners: NamespaceBundleOwnershipListener...)</TD></TR>
<TR><TD ALIGN="LEFT" ># onNamespaceBundleOwned(bundle: NamespaceBundle)</TD></TR>
<TR><TD ALIGN="LEFT" ># onNamespaceBundleUnload(bundle: NamespaceBundle)</TD></TR>
<TR><TD ALIGN="LEFT" >- parseHostAndPort(candidateBroker: String): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ registerBootstrapNamespaces()</TD></TR>
<TR><TD ALIGN="LEFT" >+ registerNamespace(nsname: NamespaceName, ensureOwned: boolean): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ registerSLANamespace(): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ removeOwnedServiceUnit(nsBundle: NamespaceBundle)</TD></TR>
<TR><TD ALIGN="LEFT" >- searchForCandidateBroker(bundle: NamespaceBundle, lookupFuture: CompletableFuture&lt;Optional&lt;LookupResult&gt;&gt;, options: LookupOptions)</TD></TR>
<TR><TD ALIGN="LEFT" >+ splitAndOwnBundle(bundle: NamespaceBundle, unload: boolean, splitAlgorithm: NamespaceBundleSplitAlgorithm): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># splitAndOwnBundleOnceAndRetry(bundle: NamespaceBundle, unload: boolean, counter: AtomicInteger, completionFuture: CompletableFuture&lt;Void&gt;, splitAlgorithm: NamespaceBundleSplitAlgorithm)</TD></TR>
<TR><TD ALIGN="LEFT" >+ unloadNamespaceBundle(bundle: NamespaceBundle): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ unloadNamespaceBundle(bundle: NamespaceBundle, timeout: long, timeoutUnit: TimeUnit): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ unloadNamespaceBundle(bundle: NamespaceBundle, timeout: long, timeoutUnit: TimeUnit, closeWithoutWaitingClientDisconnect: boolean): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ unloadSLANamespace()</TD></TR>
<TR><TD ALIGN="LEFT" >- updateNamespaceBundles(nsname: NamespaceName, nsBundles: NamespaceBundles): CompletableFuture&lt;Void&gt;</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

NamespaceStats2102807099[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)NamespaceStats</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+   addLatencyBucket: long[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >+   consumerCount: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   maxMsgReplDelayInSeconds: double [1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   msgBacklog: double [1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   msgRateIn: double [1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   msgRateOut: double [1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   msgReplBacklog: double [1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   msgThroughputIn: double [1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   msgThroughputOut: double [1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   producerCount: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   ratePeriodInSeconds: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   replicatorCount: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   storageSize: double [1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   subsCount: int [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ add(namespace: String): Metrics</TD></TR>
<TR><TD ALIGN="LEFT" >+ add(src: long[], dest: long[])</TD></TR>
<TR><TD ALIGN="LEFT" >+ clear(list: long[])</TD></TR>
<TR><TD ALIGN="LEFT" >+ reset()</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

NamespacesBase229910521[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)NamespacesBase</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- checkQuotas(policies: Policies, retention: RetentionPolicies): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >- clearBacklog(nsName: NamespaceName, bundleRange: String, subscription: String)</TD></TR>
<TR><TD ALIGN="LEFT" >- doUpdatePersistence(persistence: PersistencePolicies)</TD></TR>
<TR><TD ALIGN="LEFT" >- findHotBundle(namespaceName: NamespaceName): NamespaceBundle</TD></TR>
<TR><TD ALIGN="LEFT" >- findLargestBundleWithTopics(namespaceName: NamespaceName): NamespaceBundle</TD></TR>
<TR><TD ALIGN="LEFT" >- getBundleRange(bundleName: String): String</TD></TR>
<TR><TD ALIGN="LEFT" >- getNamespaceBundleSplitAlgorithmByName(algorithmName: String): NamespaceBundleSplitAlgorithm</TD></TR>
<TR><TD ALIGN="LEFT" ># internalClearNamespaceBacklog(asyncResponse: AsyncResponse, authoritative: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" ># internalClearNamespaceBacklogForSubscription(asyncResponse: AsyncResponse, subscription: String, authoritative: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" ># internalClearNamespaceBundleBacklog(bundleRange: String, authoritative: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" ># internalClearNamespaceBundleBacklogForSubscription(subscription: String, bundleRange: String, authoritative: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" ># internalClearProperties(asyncResponse: AsyncResponse)</TD></TR>
<TR><TD ALIGN="LEFT" ># internalClearZkSources(): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># internalCreateNamespace(policies: Policies)</TD></TR>
<TR><TD ALIGN="LEFT" ># internalDeleteBookieAffinityGroup()</TD></TR>
<TR><TD ALIGN="LEFT" ># internalDeleteNamespace(asyncResponse: AsyncResponse, authoritative: boolean, force: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" ># internalDeleteNamespace(asyncResponse: AsyncResponse, authoritative: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" ># internalDeleteNamespaceBundle(bundleRange: String, authoritative: boolean, force: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" ># internalDeleteNamespaceBundle(bundleRange: String, authoritative: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" ># internalDeleteNamespaceBundleForcefully(bundleRange: String, authoritative: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" ># internalDeleteNamespaceForcefully(asyncResponse: AsyncResponse, authoritative: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" ># internalDeletePersistence()</TD></TR>
<TR><TD ALIGN="LEFT" ># internalDeleteSubscribeRate()</TD></TR>
<TR><TD ALIGN="LEFT" ># internalDeleteSubscriptionDispatchRate()</TD></TR>
<TR><TD ALIGN="LEFT" ># internalDeleteTopicDispatchRate()</TD></TR>
<TR><TD ALIGN="LEFT" ># internalGetAntiAffinityNamespaces(cluster: String, antiAffinityGroup: String, tenant: String): List&lt;String&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># internalGetAutoSubscriptionCreation(): AutoSubscriptionCreationOverride</TD></TR>
<TR><TD ALIGN="LEFT" ># internalGetAutoTopicCreation(): AutoTopicCreationOverride</TD></TR>
<TR><TD ALIGN="LEFT" ># internalGetBookieAffinityGroup(): BookieAffinityGroupData</TD></TR>
<TR><TD ALIGN="LEFT" ># internalGetCompactionThreshold(): Long</TD></TR>
<TR><TD ALIGN="LEFT" ># internalGetDeduplication(): Boolean</TD></TR>
<TR><TD ALIGN="LEFT" ># internalGetDeduplicationSnapshotInterval(): Integer</TD></TR>
<TR><TD ALIGN="LEFT" ># internalGetDelayedDelivery(): DelayedDeliveryPolicies</TD></TR>
<TR><TD ALIGN="LEFT" ># internalGetEncryptionRequired(): Boolean</TD></TR>
<TR><TD ALIGN="LEFT" ># internalGetInactiveTopic(): InactiveTopicPolicies</TD></TR>
<TR><TD ALIGN="LEFT" ># internalGetIsAllowAutoUpdateSchema(): boolean</TD></TR>
<TR><TD ALIGN="LEFT" ># internalGetMaxConsumersPerSubscription(): Integer</TD></TR>
<TR><TD ALIGN="LEFT" ># internalGetMaxConsumersPerTopic(): Integer</TD></TR>
<TR><TD ALIGN="LEFT" ># internalGetMaxProducersPerTopic(): Integer</TD></TR>
<TR><TD ALIGN="LEFT" ># internalGetMaxSubscriptionsPerTopic(): Integer</TD></TR>
<TR><TD ALIGN="LEFT" ># internalGetMaxTopicsPerNamespace(): int</TD></TR>
<TR><TD ALIGN="LEFT" ># internalGetMaxUnackedMessagesPerConsumer(): Integer</TD></TR>
<TR><TD ALIGN="LEFT" ># internalGetMaxUnackedMessagesPerSubscription(): Integer</TD></TR>
<TR><TD ALIGN="LEFT" ># internalGetNamespaceAntiAffinityGroup(): String</TD></TR>
<TR><TD ALIGN="LEFT" ># internalGetNamespaceReplicationClusters(): Set&lt;String&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># internalGetOffloadDeletionLag(): Long</TD></TR>
<TR><TD ALIGN="LEFT" ># internalGetOffloadPolicies(): OffloadPoliciesImpl</TD></TR>
<TR><TD ALIGN="LEFT" ># internalGetOffloadThreshold(): long</TD></TR>
<TR><TD ALIGN="LEFT" ># internalGetPersistence(): PersistencePolicies</TD></TR>
<TR><TD ALIGN="LEFT" ># internalGetProperties(asyncResponse: AsyncResponse)</TD></TR>
<TR><TD ALIGN="LEFT" ># internalGetProperty(key: String, asyncResponse: AsyncResponse)</TD></TR>
<TR><TD ALIGN="LEFT" ># internalGetPublishRate(): PublishRate</TD></TR>
<TR><TD ALIGN="LEFT" ># internalGetReplicatorDispatchRate(): DispatchRate</TD></TR>
<TR><TD ALIGN="LEFT" ># internalGetRetention(): RetentionPolicies</TD></TR>
<TR><TD ALIGN="LEFT" ># internalGetSchemaAutoUpdateCompatibilityStrategy(): SchemaAutoUpdateCompatibilityStrategy</TD></TR>
<TR><TD ALIGN="LEFT" ># internalGetSchemaCompatibilityStrategy(): SchemaCompatibilityStrategy</TD></TR>
<TR><TD ALIGN="LEFT" ># internalGetSchemaValidationEnforced(applied: boolean): boolean</TD></TR>
<TR><TD ALIGN="LEFT" ># internalGetSubscribeRate(): SubscribeRate</TD></TR>
<TR><TD ALIGN="LEFT" ># internalGetSubscriptionAuthMode(): SubscriptionAuthMode</TD></TR>
<TR><TD ALIGN="LEFT" ># internalGetSubscriptionDispatchRate(): DispatchRate</TD></TR>
<TR><TD ALIGN="LEFT" ># internalGetSubscriptionTypesEnabled(): Set&lt;SubscriptionType&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># internalGetTenantNamespaces(tenant: String): List&lt;String&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># internalGetTopicDispatchRate(): DispatchRate</TD></TR>
<TR><TD ALIGN="LEFT" ># internalGrantPermissionOnNamespace(role: String, actions: Set&lt;AuthAction&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" ># internalGrantPermissionOnSubscription(subscription: String, roles: Set&lt;String&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" ># internalModifyDeduplication(enableDeduplication: Boolean)</TD></TR>
<TR><TD ALIGN="LEFT" ># internalModifyEncryptionRequired(encryptionRequired: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" ># internalRemoveAutoSubscriptionCreation(asyncResponse: AsyncResponse)</TD></TR>
<TR><TD ALIGN="LEFT" ># internalRemoveAutoTopicCreation(asyncResponse: AsyncResponse)</TD></TR>
<TR><TD ALIGN="LEFT" ># internalRemoveBacklogQuota(backlogQuotaType: BacklogQuotaType)</TD></TR>
<TR><TD ALIGN="LEFT" ># internalRemoveMaxTopicsPerNamespace()</TD></TR>
<TR><TD ALIGN="LEFT" ># internalRemoveNamespaceAntiAffinityGroup()</TD></TR>
<TR><TD ALIGN="LEFT" ># internalRemoveOffloadPolicies(asyncResponse: AsyncResponse)</TD></TR>
<TR><TD ALIGN="LEFT" ># internalRemoveProperty(key: String, asyncResponse: AsyncResponse)</TD></TR>
<TR><TD ALIGN="LEFT" ># internalRemovePublishRate()</TD></TR>
<TR><TD ALIGN="LEFT" ># internalRemoveReplicatorDispatchRate()</TD></TR>
<TR><TD ALIGN="LEFT" ># internalRevokePermissionsOnNamespace(role: String)</TD></TR>
<TR><TD ALIGN="LEFT" ># internalRevokePermissionsOnSubscription(subscriptionName: String, role: String)</TD></TR>
<TR><TD ALIGN="LEFT" ># internalSetAutoSubscriptionCreation(asyncResponse: AsyncResponse, autoSubscriptionCreationOverride: AutoSubscriptionCreationOverride)</TD></TR>
<TR><TD ALIGN="LEFT" ># internalSetAutoTopicCreation(asyncResponse: AsyncResponse, autoTopicCreationOverride: AutoTopicCreationOverride)</TD></TR>
<TR><TD ALIGN="LEFT" ># internalSetBacklogQuota(backlogQuotaType: BacklogQuotaType, backlogQuota: BacklogQuota)</TD></TR>
<TR><TD ALIGN="LEFT" ># internalSetBookieAffinityGroup(bookieAffinityGroup: BookieAffinityGroupData)</TD></TR>
<TR><TD ALIGN="LEFT" ># internalSetCompactionThreshold(newThreshold: Long)</TD></TR>
<TR><TD ALIGN="LEFT" ># internalSetDeduplicationSnapshotInterval(interval: Integer)</TD></TR>
<TR><TD ALIGN="LEFT" ># internalSetDelayedDelivery(delayedDeliveryPolicies: DelayedDeliveryPolicies)</TD></TR>
<TR><TD ALIGN="LEFT" ># internalSetInactiveTopic(inactiveTopicPolicies: InactiveTopicPolicies)</TD></TR>
<TR><TD ALIGN="LEFT" ># internalSetIsAllowAutoUpdateSchema(isAllowAutoUpdateSchema: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" ># internalSetMaxConsumersPerSubscription(maxConsumersPerSubscription: Integer)</TD></TR>
<TR><TD ALIGN="LEFT" ># internalSetMaxConsumersPerTopic(maxConsumersPerTopic: Integer)</TD></TR>
<TR><TD ALIGN="LEFT" ># internalSetMaxProducersPerTopic(maxProducersPerTopic: Integer)</TD></TR>
<TR><TD ALIGN="LEFT" ># internalSetMaxSubscriptionsPerTopic(maxSubscriptionsPerTopic: Integer)</TD></TR>
<TR><TD ALIGN="LEFT" ># internalSetMaxTopicsPerNamespace(maxTopicsPerNamespace: Integer)</TD></TR>
<TR><TD ALIGN="LEFT" ># internalSetMaxUnackedMessagesPerConsumer(maxUnackedMessagesPerConsumer: Integer)</TD></TR>
<TR><TD ALIGN="LEFT" ># internalSetMaxUnackedMessagesPerSubscription(maxUnackedMessagesPerSubscription: Integer)</TD></TR>
<TR><TD ALIGN="LEFT" ># internalSetNamespaceAntiAffinityGroup(antiAffinityGroup: String)</TD></TR>
<TR><TD ALIGN="LEFT" ># internalSetNamespaceMessageTTL(messageTTL: Integer)</TD></TR>
<TR><TD ALIGN="LEFT" ># internalSetNamespaceReplicationClusters(clusterIds: List&lt;String&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" ># internalSetNamespaceResourceGroup(rgName: String)</TD></TR>
<TR><TD ALIGN="LEFT" ># internalSetOffloadDeletionLag(newDeletionLagMs: Long)</TD></TR>
<TR><TD ALIGN="LEFT" ># internalSetOffloadPolicies(asyncResponse: AsyncResponse, offloadPolicies: OffloadPoliciesImpl)</TD></TR>
<TR><TD ALIGN="LEFT" ># internalSetOffloadThreshold(newThreshold: long)</TD></TR>
<TR><TD ALIGN="LEFT" ># internalSetPersistence(persistence: PersistencePolicies)</TD></TR>
<TR><TD ALIGN="LEFT" ># internalSetPolicies(fieldName: String, value: Object)</TD></TR>
<TR><TD ALIGN="LEFT" ># internalSetProperties(properties: Map&lt;String, String&gt;, asyncResponse: AsyncResponse)</TD></TR>
<TR><TD ALIGN="LEFT" ># internalSetProperty(key: String, value: String, asyncResponse: AsyncResponse)</TD></TR>
<TR><TD ALIGN="LEFT" ># internalSetPublishRate(maxPublishMessageRate: PublishRate)</TD></TR>
<TR><TD ALIGN="LEFT" ># internalSetReplicatorDispatchRate(dispatchRate: DispatchRateImpl)</TD></TR>
<TR><TD ALIGN="LEFT" ># internalSetRetention(retention: RetentionPolicies)</TD></TR>
<TR><TD ALIGN="LEFT" ># internalSetSchemaAutoUpdateCompatibilityStrategy(strategy: SchemaAutoUpdateCompatibilityStrategy)</TD></TR>
<TR><TD ALIGN="LEFT" ># internalSetSchemaCompatibilityStrategy(strategy: SchemaCompatibilityStrategy)</TD></TR>
<TR><TD ALIGN="LEFT" ># internalSetSchemaValidationEnforced(schemaValidationEnforced: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" ># internalSetSubscribeRate(subscribeRate: SubscribeRate)</TD></TR>
<TR><TD ALIGN="LEFT" ># internalSetSubscriptionAuthMode(subscriptionAuthMode: SubscriptionAuthMode)</TD></TR>
<TR><TD ALIGN="LEFT" ># internalSetSubscriptionDispatchRate(dispatchRate: DispatchRateImpl)</TD></TR>
<TR><TD ALIGN="LEFT" ># internalSetSubscriptionExpirationTime(expirationTime: Integer)</TD></TR>
<TR><TD ALIGN="LEFT" ># internalSetSubscriptionTypesEnabled(subscriptionTypesEnabled: Set&lt;SubscriptionType&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" ># internalSetTopicDispatchRate(dispatchRate: DispatchRateImpl)</TD></TR>
<TR><TD ALIGN="LEFT" ># internalSplitNamespaceBundle(asyncResponse: AsyncResponse, bundleName: String, authoritative: boolean, unload: boolean, splitAlgorithmName: String)</TD></TR>
<TR><TD ALIGN="LEFT" ># internalUnloadNamespace(asyncResponse: AsyncResponse)</TD></TR>
<TR><TD ALIGN="LEFT" >+ internalUnloadNamespaceBundle(asyncResponse: AsyncResponse, bundleRange: String, authoritative: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" ># internalUnsubscribeNamespace(asyncResponse: AsyncResponse, subscription: String, authoritative: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" ># internalUnsubscribeNamespaceBundle(subscription: String, bundleRange: String, authoritative: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >- mutatePolicy(policyTransformation: Function&lt;Policies, Policies&gt;, getter: Function&lt;Policies, T&gt;, policyName: String)</TD></TR>
<TR><TD ALIGN="LEFT" >- unsubscribe(nsName: NamespaceName, bundleRange: String, subscription: String)</TD></TR>
<TR><TD ALIGN="LEFT" >- updatePolicies(ns: NamespaceName, updateFunction: Function&lt;Policies, Policies&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >- updatePoliciesAsync(ns: NamespaceName, updateFunction: Function&lt;Policies, Policies&gt;): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># validateBundlesData(initialBundles: BundlesData): BundlesData</TD></TR>
<TR><TD ALIGN="LEFT" >- validateOffloadPolicies(offloadPolicies: OffloadPoliciesImpl)</TD></TR>
<TR><TD ALIGN="LEFT" >- validatePolicies(ns: NamespaceName, policies: Policies)</TD></TR>
<TR><TD ALIGN="LEFT" ># validateRetentionPolicies(retention: RetentionPolicies)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

NamespacesImpl1292556772[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)NamespacesImpl</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   adminNamespaces: WebTarget [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   adminV2Namespaces: WebTarget [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ clearNamespaceBacklog(namespace: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearNamespaceBacklogAsync(namespace: String): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearNamespaceBacklogForSubscription(namespace: String, subscription: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearNamespaceBacklogForSubscriptionAsync(namespace: String, subscription: String): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearNamespaceBundleBacklog(namespace: String, bundle: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearNamespaceBundleBacklogAsync(namespace: String, bundle: String): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearNamespaceBundleBacklogForSubscription(namespace: String, bundle: String, subscription: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearNamespaceBundleBacklogForSubscriptionAsync(namespace: String, bundle: String, subscription: String): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearOffloadDeleteLag(namespace: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearOffloadDeleteLagAsync(namespace: String): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearProperties(namespace: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearPropertiesAsync(namespace: String): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ createNamespace(namespace: String, clusters: Set&lt;String&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ createNamespace(namespace: String, numBundles: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ createNamespace(namespace: String, policies: Policies)</TD></TR>
<TR><TD ALIGN="LEFT" >+ createNamespace(namespace: String, bundlesData: BundlesData)</TD></TR>
<TR><TD ALIGN="LEFT" >+ createNamespace(namespace: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ createNamespaceAsync(namespace: String, clusters: Set&lt;String&gt;): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ createNamespaceAsync(namespace: String, numBundles: int): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ createNamespaceAsync(namespace: String, policies: Policies): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ createNamespaceAsync(namespace: String, bundlesData: BundlesData): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ createNamespaceAsync(namespace: String): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ deleteBookieAffinityGroup(namespace: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ deleteBookieAffinityGroupAsync(namespace: String): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ deleteNamespace(namespace: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ deleteNamespace(namespace: String, force: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ deleteNamespaceAntiAffinityGroup(namespace: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ deleteNamespaceAntiAffinityGroupAsync(namespace: String): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ deleteNamespaceAsync(namespace: String): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ deleteNamespaceAsync(namespace: String, force: boolean): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ deleteNamespaceBundle(namespace: String, bundleRange: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ deleteNamespaceBundle(namespace: String, bundleRange: String, force: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ deleteNamespaceBundleAsync(namespace: String, bundleRange: String): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ deleteNamespaceBundleAsync(namespace: String, bundleRange: String, force: boolean): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getAntiAffinityNamespaces(tenant: String, cluster: String, namespaceAntiAffinityGroup: String): List&lt;String&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getAntiAffinityNamespacesAsync(tenant: String, cluster: String, namespaceAntiAffinityGroup: String): CompletableFuture&lt;List&lt;String&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getAutoSubscriptionCreation(namespace: String): AutoSubscriptionCreationOverride</TD></TR>
<TR><TD ALIGN="LEFT" >+ getAutoSubscriptionCreationAsync(namespace: String): CompletableFuture&lt;AutoSubscriptionCreationOverride&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getAutoTopicCreation(namespace: String): AutoTopicCreationOverride</TD></TR>
<TR><TD ALIGN="LEFT" >+ getAutoTopicCreationAsync(namespace: String): CompletableFuture&lt;AutoTopicCreationOverride&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getBacklogQuotaMap(namespace: String): Map&lt;BacklogQuotaType, BacklogQuota&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getBacklogQuotaMapAsync(namespace: String): CompletableFuture&lt;Map&lt;BacklogQuotaType, BacklogQuota&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getBookieAffinityGroup(namespace: String): BookieAffinityGroupData</TD></TR>
<TR><TD ALIGN="LEFT" >+ getBookieAffinityGroupAsync(namespace: String): CompletableFuture&lt;BookieAffinityGroupData&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getBundles(namespace: String): BundlesData</TD></TR>
<TR><TD ALIGN="LEFT" >+ getBundlesAsync(namespace: String): CompletableFuture&lt;BundlesData&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getCompactionThreshold(namespace: String): Long</TD></TR>
<TR><TD ALIGN="LEFT" >+ getCompactionThresholdAsync(namespace: String): CompletableFuture&lt;Long&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getDeduplicationSnapshotInterval(namespace: String): Integer</TD></TR>
<TR><TD ALIGN="LEFT" >+ getDeduplicationSnapshotIntervalAsync(namespace: String): CompletableFuture&lt;Integer&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getDeduplicationStatus(namespace: String): Boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ getDeduplicationStatusAsync(namespace: String): CompletableFuture&lt;Boolean&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getDelayedDelivery(namespace: String): DelayedDeliveryPolicies</TD></TR>
<TR><TD ALIGN="LEFT" >+ getDelayedDeliveryAsync(namespace: String): CompletableFuture&lt;DelayedDeliveryPolicies&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getDispatchRate(namespace: String): DispatchRate</TD></TR>
<TR><TD ALIGN="LEFT" >+ getDispatchRateAsync(namespace: String): CompletableFuture&lt;DispatchRate&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getEncryptionRequiredStatus(namespace: String): Boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ getEncryptionRequiredStatusAsync(namespace: String): CompletableFuture&lt;Boolean&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getInactiveTopicPolicies(namespace: String): InactiveTopicPolicies</TD></TR>
<TR><TD ALIGN="LEFT" >+ getInactiveTopicPoliciesAsync(namespace: String): CompletableFuture&lt;InactiveTopicPolicies&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getIsAllowAutoUpdateSchema(namespace: String): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ getIsAllowAutoUpdateSchemaAsync(namespace: String): CompletableFuture&lt;Boolean&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getMaxConsumersPerSubscription(namespace: String): Integer</TD></TR>
<TR><TD ALIGN="LEFT" >+ getMaxConsumersPerSubscriptionAsync(namespace: String): CompletableFuture&lt;Integer&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getMaxConsumersPerTopic(namespace: String): Integer</TD></TR>
<TR><TD ALIGN="LEFT" >+ getMaxConsumersPerTopicAsync(namespace: String): CompletableFuture&lt;Integer&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getMaxProducersPerTopic(namespace: String): Integer</TD></TR>
<TR><TD ALIGN="LEFT" >+ getMaxProducersPerTopicAsync(namespace: String): CompletableFuture&lt;Integer&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getMaxSubscriptionsPerTopic(namespace: String): Integer</TD></TR>
<TR><TD ALIGN="LEFT" >+ getMaxSubscriptionsPerTopicAsync(namespace: String): CompletableFuture&lt;Integer&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getMaxTopicsPerNamespace(namespace: String): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ getMaxTopicsPerNamespaceAsync(namespace: String): CompletableFuture&lt;Integer&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getMaxUnackedMessagesPerConsumer(namespace: String): Integer</TD></TR>
<TR><TD ALIGN="LEFT" >+ getMaxUnackedMessagesPerConsumerAsync(namespace: String): CompletableFuture&lt;Integer&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getMaxUnackedMessagesPerSubscription(namespace: String): Integer</TD></TR>
<TR><TD ALIGN="LEFT" >+ getMaxUnackedMessagesPerSubscriptionAsync(namespace: String): CompletableFuture&lt;Integer&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getNamespaceAntiAffinityGroup(namespace: String): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ getNamespaceAntiAffinityGroupAsync(namespace: String): CompletableFuture&lt;String&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getNamespaceMessageTTL(namespace: String): Integer</TD></TR>
<TR><TD ALIGN="LEFT" >+ getNamespaceMessageTTLAsync(namespace: String): CompletableFuture&lt;Integer&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getNamespaceReplicationClusters(namespace: String): List&lt;String&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getNamespaceReplicationClustersAsync(namespace: String): CompletableFuture&lt;List&lt;String&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getNamespaceResourceGroup(namespace: String): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ getNamespaceResourceGroupAsync(namespace: String): CompletableFuture&lt;String&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getNamespaces(tenant: String): List&lt;String&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getNamespaces(tenant: String, cluster: String): List&lt;String&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getNamespacesAsync(tenant: String): CompletableFuture&lt;List&lt;String&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getNamespacesAsync(tenant: String, cluster: String): CompletableFuture&lt;List&lt;String&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getOffloadDeleteLagMs(namespace: String): Long</TD></TR>
<TR><TD ALIGN="LEFT" >+ getOffloadDeleteLagMsAsync(namespace: String): CompletableFuture&lt;Long&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getOffloadPolicies(namespace: String): OffloadPolicies</TD></TR>
<TR><TD ALIGN="LEFT" >+ getOffloadPoliciesAsync(namespace: String): CompletableFuture&lt;OffloadPolicies&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getOffloadThreshold(namespace: String): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ getOffloadThresholdAsync(namespace: String): CompletableFuture&lt;Long&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getPermissionOnSubscription(namespace: String): Map&lt;String, Set&lt;String&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getPermissionOnSubscriptionAsync(namespace: String): CompletableFuture&lt;Map&lt;String, Set&lt;String&gt;&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getPermissions(namespace: String): Map&lt;String, Set&lt;AuthAction&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getPermissionsAsync(namespace: String): CompletableFuture&lt;Map&lt;String, Set&lt;AuthAction&gt;&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getPersistence(namespace: String): PersistencePolicies</TD></TR>
<TR><TD ALIGN="LEFT" >+ getPersistenceAsync(namespace: String): CompletableFuture&lt;PersistencePolicies&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getPolicies(namespace: String): Policies</TD></TR>
<TR><TD ALIGN="LEFT" >+ getPoliciesAsync(namespace: String): CompletableFuture&lt;Policies&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getProperties(namespace: String): Map&lt;String, String&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getPropertiesAsync(namespace: String): CompletableFuture&lt;Map&lt;String, String&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getProperty(namespace: String, key: String): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ getPropertyAsync(namespace: String, key: String): CompletableFuture&lt;String&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getPublishRate(namespace: String): PublishRate</TD></TR>
<TR><TD ALIGN="LEFT" >+ getPublishRateAsync(namespace: String): CompletableFuture&lt;PublishRate&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getReplicationConfigVersion(namespace: String): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ getReplicationConfigVersionAsync(namespace: String): CompletableFuture&lt;String&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getReplicatorDispatchRate(namespace: String): DispatchRate</TD></TR>
<TR><TD ALIGN="LEFT" >+ getReplicatorDispatchRateAsync(namespace: String): CompletableFuture&lt;DispatchRate&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getRetention(namespace: String): RetentionPolicies</TD></TR>
<TR><TD ALIGN="LEFT" >+ getRetentionAsync(namespace: String): CompletableFuture&lt;RetentionPolicies&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getSchemaAutoUpdateCompatibilityStrategy(namespace: String): SchemaAutoUpdateCompatibilityStrategy</TD></TR>
<TR><TD ALIGN="LEFT" >+ getSchemaCompatibilityStrategy(namespace: String): SchemaCompatibilityStrategy</TD></TR>
<TR><TD ALIGN="LEFT" >+ getSchemaCompatibilityStrategyAsync(namespace: String): CompletableFuture&lt;SchemaCompatibilityStrategy&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getSchemaValidationEnforced(namespace: String): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ getSchemaValidationEnforced(namespace: String, applied: boolean): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ getSchemaValidationEnforcedAsync(namespace: String): CompletableFuture&lt;Boolean&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getSchemaValidationEnforcedAsync(namespace: String, applied: boolean): CompletableFuture&lt;Boolean&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getSubscribeRate(namespace: String): SubscribeRate</TD></TR>
<TR><TD ALIGN="LEFT" >+ getSubscribeRateAsync(namespace: String): CompletableFuture&lt;SubscribeRate&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getSubscriptionAuthMode(namespace: String): SubscriptionAuthMode</TD></TR>
<TR><TD ALIGN="LEFT" >+ getSubscriptionAuthModeAsync(namespace: String): CompletableFuture&lt;SubscriptionAuthMode&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getSubscriptionDispatchRate(namespace: String): DispatchRate</TD></TR>
<TR><TD ALIGN="LEFT" >+ getSubscriptionDispatchRateAsync(namespace: String): CompletableFuture&lt;DispatchRate&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getSubscriptionExpirationTime(namespace: String): Integer</TD></TR>
<TR><TD ALIGN="LEFT" >+ getSubscriptionExpirationTimeAsync(namespace: String): CompletableFuture&lt;Integer&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getSubscriptionTypesEnabled(namespace: String): Set&lt;SubscriptionType&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getSubscriptionTypesEnabledAsync(namespace: String): CompletableFuture&lt;Set&lt;SubscriptionType&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getTopics(namespace: String): List&lt;String&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getTopicsAsync(namespace: String): CompletableFuture&lt;List&lt;String&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ grantPermissionOnNamespace(namespace: String, role: String, actions: Set&lt;AuthAction&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ grantPermissionOnNamespaceAsync(namespace: String, role: String, actions: Set&lt;AuthAction&gt;): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ grantPermissionOnSubscription(namespace: String, subscription: String, roles: Set&lt;String&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ grantPermissionOnSubscriptionAsync(namespace: String, subscription: String, roles: Set&lt;String&gt;): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- namespacePath(namespace: NamespaceName, parts: String...): WebTarget</TD></TR>
<TR><TD ALIGN="LEFT" >+ removeAutoSubscriptionCreation(namespace: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ removeAutoSubscriptionCreationAsync(namespace: String): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ removeAutoTopicCreation(namespace: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ removeAutoTopicCreationAsync(namespace: String): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ removeBacklogQuota(namespace: String, backlogQuotaType: BacklogQuotaType)</TD></TR>
<TR><TD ALIGN="LEFT" >+ removeBacklogQuotaAsync(namespace: String, backlogQuotaType: BacklogQuotaType): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ removeCompactionThreshold(namespace: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ removeCompactionThresholdAsync(namespace: String): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ removeDeduplicationSnapshotInterval(namespace: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ removeDeduplicationSnapshotIntervalAsync(namespace: String): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ removeDeduplicationStatus(namespace: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ removeDeduplicationStatusAsync(namespace: String): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ removeDelayedDeliveryMessages(namespace: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ removeDelayedDeliveryMessagesAsync(namespace: String): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ removeDispatchRate(namespace: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ removeDispatchRateAsync(namespace: String): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ removeInactiveTopicPolicies(namespace: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ removeInactiveTopicPoliciesAsync(namespace: String): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ removeMaxConsumersPerSubscription(namespace: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ removeMaxConsumersPerSubscriptionAsync(namespace: String): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ removeMaxConsumersPerTopic(namespace: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ removeMaxConsumersPerTopicAsync(namespace: String): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ removeMaxProducersPerTopic(namespace: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ removeMaxProducersPerTopicAsync(namespace: String): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ removeMaxSubscriptionsPerTopic(namespace: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ removeMaxSubscriptionsPerTopicAsync(namespace: String): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ removeMaxTopicsPerNamespace(namespace: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ removeMaxTopicsPerNamespaceAsync(namespace: String): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ removeMaxUnackedMessagesPerConsumer(namespace: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ removeMaxUnackedMessagesPerConsumerAsync(namespace: String): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ removeMaxUnackedMessagesPerSubscription(namespace: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ removeMaxUnackedMessagesPerSubscriptionAsync(namespace: String): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ removeNamespaceMessageTTL(namespace: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ removeNamespaceMessageTTLAsync(namespace: String): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ removeNamespaceResourceGroup(namespace: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ removeNamespaceResourceGroupAsync(namespace: String): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ removeOffloadPolicies(namespace: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ removeOffloadPoliciesAsync(namespace: String): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ removePersistence(namespace: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ removePersistenceAsync(namespace: String): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ removeProperty(namespace: String, key: String): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ removePropertyAsync(namespace: String, key: String): CompletableFuture&lt;String&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ removePublishRate(namespace: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ removePublishRateAsync(namespace: String): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ removeReplicatorDispatchRate(namespace: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ removeReplicatorDispatchRateAsync(namespace: String): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ removeRetention(namespace: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ removeRetentionAsync(namespace: String): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ removeSubscribeRate(namespace: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ removeSubscribeRateAsync(namespace: String): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ removeSubscriptionDispatchRate(namespace: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ removeSubscriptionDispatchRateAsync(namespace: String): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ removeSubscriptionExpirationTime(namespace: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ removeSubscriptionExpirationTimeAsync(namespace: String): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ removeSubscriptionTypesEnabled(namespace: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ removeSubscriptionTypesEnabledAsync(namespace: String): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ revokePermissionOnSubscription(namespace: String, subscription: String, role: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ revokePermissionOnSubscriptionAsync(namespace: String, subscription: String, role: String): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ revokePermissionsOnNamespace(namespace: String, role: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ revokePermissionsOnNamespaceAsync(namespace: String, role: String): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ setAutoSubscriptionCreationAsync(namespace: String, autoSubscriptionCreationOverride: AutoSubscriptionCreationOverride): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ setAutoTopicCreationAsync(namespace: String, autoTopicCreationOverride: AutoTopicCreationOverride): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ setBacklogQuotaAsync(namespace: String, backlogQuota: BacklogQuota, backlogQuotaType: BacklogQuotaType): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ setBookieAffinityGroupAsync(namespace: String, bookieAffinityGroup: BookieAffinityGroupData): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ setCompactionThresholdAsync(namespace: String, compactionThreshold: long): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ setDeduplicationSnapshotIntervalAsync(namespace: String, interval: Integer): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ setDeduplicationStatusAsync(namespace: String, enableDeduplication: boolean): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ setDelayedDeliveryMessagesAsync(namespace: String, delayedDeliveryPolicies: DelayedDeliveryPolicies): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ setDispatchRateAsync(namespace: String, dispatchRate: DispatchRate): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ setEncryptionRequiredStatusAsync(namespace: String, encryptionRequired: boolean): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ setInactiveTopicPoliciesAsync(namespace: String, inactiveTopicPolicies: InactiveTopicPolicies): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ setIsAllowAutoUpdateSchemaAsync(namespace: String, isAllowAutoUpdateSchema: boolean): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ setMaxConsumersPerSubscriptionAsync(namespace: String, maxConsumersPerSubscription: int): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ setMaxConsumersPerTopicAsync(namespace: String, maxConsumersPerTopic: int): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ setMaxProducersPerTopicAsync(namespace: String, maxProducersPerTopic: int): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ setMaxSubscriptionsPerTopicAsync(namespace: String, maxSubscriptionsPerTopic: int): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ setMaxTopicsPerNamespaceAsync(namespace: String, maxTopicsPerNamespace: int): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ setMaxUnackedMessagesPerConsumerAsync(namespace: String, maxUnackedMessagesPerConsumer: int): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ setMaxUnackedMessagesPerSubscriptionAsync(namespace: String, maxUnackedMessagesPerSubscription: int): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ setNamespaceAntiAffinityGroupAsync(namespace: String, namespaceAntiAffinityGroup: String): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ setNamespaceMessageTTLAsync(namespace: String, ttlInSeconds: int): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ setNamespaceReplicationClustersAsync(namespace: String, clusterIds: Set&lt;String&gt;): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ setNamespaceResourceGroupAsync(namespace: String, resourcegroupname: String): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ setOffloadDeleteLagAsync(namespace: String, lag: long, unit: TimeUnit): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ setOffloadPoliciesAsync(namespace: String, offloadPolicies: OffloadPolicies): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ setOffloadThresholdAsync(namespace: String, offloadThreshold: long): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ setPersistenceAsync(namespace: String, persistence: PersistencePolicies): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ setPropertiesAsync(namespace: String, properties: Map&lt;String, String&gt;): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ setPropertyAsync(namespace: String, key: String, value: String): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ setPublishRateAsync(namespace: String, publishMsgRate: PublishRate): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ setReplicatorDispatchRateAsync(namespace: String, dispatchRate: DispatchRate): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ setRetentionAsync(namespace: String, retention: RetentionPolicies): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ setSchemaCompatibilityStrategyAsync(namespace: String, strategy: SchemaCompatibilityStrategy): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ setSchemaValidationEnforcedAsync(namespace: String, schemaValidationEnforced: boolean): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ setSubscribeRateAsync(namespace: String, subscribeRate: SubscribeRate): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ setSubscriptionAuthModeAsync(namespace: String, subscriptionAuthMode: SubscriptionAuthMode): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ setSubscriptionDispatchRateAsync(namespace: String, dispatchRate: DispatchRate): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ setSubscriptionExpirationTimeAsync(namespace: String, expirationTime: int): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ setSubscriptionTypesEnabledAsync(namespace: String, subscriptionTypes: Set&lt;SubscriptionType&gt;): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ splitNamespaceBundle(namespace: String, bundle: String, unloadSplitBundles: boolean, splitAlgorithmName: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ splitNamespaceBundleAsync(namespace: String, bundle: String, unloadSplitBundles: boolean, splitAlgorithmName: String): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ unload(namespace: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ unloadAsync(namespace: String): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ unloadNamespaceBundle(namespace: String, bundle: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ unloadNamespaceBundleAsync(namespace: String, bundle: String): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ unsubscribeNamespace(namespace: String, subscription: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ unsubscribeNamespaceAsync(namespace: String, subscription: String): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ unsubscribeNamespaceBundle(namespace: String, bundle: String, subscription: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ unsubscribeNamespaceBundleAsync(namespace: String, bundle: String, subscription: String): CompletableFuture&lt;Void&gt;</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

NamingException1254029274[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)NamingException</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

NarClassLoader1605698775[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)NarClassLoader</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   narWorkingDirectory: File [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># findLibrary(libname: String): String</TD></TR>
<TR><TD ALIGN="LEFT" ># getFromArchive(narPath: File, additionalJars: Set&lt;String&gt;, parent: ClassLoader, narExtractionDirectory: String): NarClassLoader</TD></TR>
<TR><TD ALIGN="LEFT" >- getNarExtractionDirectory(configuredDirectory: String): File</TD></TR>
<TR><TD ALIGN="LEFT" >+ getServiceDefinition(serviceName: String): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ getServiceImplementation(serviceName: String): List&lt;String&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- updateClasspath(root: File)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

NativeAvroBytesSchema1622012615[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)NativeAvroBytesSchema&lt;T&gt;</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   nativeSchema: Schema [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   schema: Schema&lt;T&gt; [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ clone(): Schema&lt;byte[]&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ decode(bytes: byte[], schemaVersion: byte[]): byte[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ encode(message: byte[]): byte[]</TD></TR>
<TR><TD ALIGN="LEFT" >- ensureSchemaInitialized()</TD></TR>
<TR><TD ALIGN="LEFT" >+ schemaInitialized(): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >- validateSchema(schema: Object): Schema</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

NegativeAcksTracker12001400[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)NegativeAcksTracker</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   consumer: ConsumerBase&lt;?&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   nackDelayNanos: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   nackedMessages: HashMap&lt;MessageId, Long&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   negativeAckRedeliveryBackoff: RedeliveryBackoff [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   timeout: Timeout [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   timer: Timer [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   timerIntervalNanos: long [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ add(messageId: MessageId)</TD></TR>
<TR><TD ALIGN="LEFT" >+ add(message: Message&lt;?&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >- add(messageId: MessageId, redeliveryCount: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >- triggerRedelivery(t: Timeout)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

NettyFutureUtil343630530[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)NettyFutureUtil</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ toCompletableFuture(future: Future&lt;V&gt;): CompletableFuture&lt;V&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ toCompletableFutureVoid(future: Future&lt;?&gt;): CompletableFuture&lt;Void&gt;</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

NonPersistentAcknowledgmentGroupingTracker12001400[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)NonPersistentAcknowledgmentGroupingTracker</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ addAcknowledgment(msgId: MessageIdImpl, ackType: AckType, properties: Map&lt;String, Long&gt;): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ addListAcknowledgment(messageIds: List&lt;MessageId&gt;, ackType: AckType, properties: Map&lt;String, Long&gt;): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ flush()</TD></TR>
<TR><TD ALIGN="LEFT" >+ flushAndClean()</TD></TR>
<TR><TD ALIGN="LEFT" >+ isDuplicate(messageId: MessageId): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ of(): NonPersistentAcknowledgmentGroupingTracker</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

NonPersistentDispatcherMultipleConsumers442146095[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)NonPersistentDispatcherMultipleConsumers</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   closeFuture: CompletableFuture&lt;Void&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   msgDrop: Rate [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   name: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   redeliveryTracker: RedeliveryTracker [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   subscription: Subscription [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   topic: NonPersistentTopic [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   totalAvailablePermits: int [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ addConsumer(consumer: Consumer)</TD></TR>
<TR><TD ALIGN="LEFT" >+ canUnsubscribe(consumer: Consumer): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ close(): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ consumerFlow(consumer: Consumer, additionalNumberOfMessages: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ disconnectActiveConsumers(isResetCursor: boolean): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ disconnectAllConsumers(isResetCursor: boolean): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ isConsumerAvailable(consumer: Consumer): boolean</TD></TR>
<TR><TD ALIGN="LEFT" ># reScheduleRead()</TD></TR>
<TR><TD ALIGN="LEFT" >+ removeConsumer(consumer: Consumer)</TD></TR>
<TR><TD ALIGN="LEFT" >+ reset()</TD></TR>
<TR><TD ALIGN="LEFT" >+ resetCloseFuture()</TD></TR>
<TR><TD ALIGN="LEFT" >+ sendMessages(entries: List&lt;Entry&gt;)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

NonPersistentDispatcherSingleActiveConsumer442146095[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)NonPersistentDispatcherSingleActiveConsumer</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   msgDrop: Rate [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   redeliveryTracker: RedeliveryTracker [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   subscription: Subscription [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   topic: NonPersistentTopic [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># cancelPendingRead()</TD></TR>
<TR><TD ALIGN="LEFT" >+ consumerFlow(consumer: Consumer, additionalNumberOfMessages: int)</TD></TR>
<TR><TD ALIGN="LEFT" ># reScheduleRead()</TD></TR>
<TR><TD ALIGN="LEFT" ># readMoreEntries(consumer: Consumer)</TD></TR>
<TR><TD ALIGN="LEFT" ># scheduleReadOnActiveConsumer()</TD></TR>
<TR><TD ALIGN="LEFT" >+ sendMessages(entries: List&lt;Entry&gt;)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

NonPersistentPartitionedTopicStatsImpl2018762865[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)NonPersistentPartitionedTopicStatsImpl</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+   metadata: PartitionedTopicMetadata [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   partitions: Map&lt;String, NonPersistentTopicStatsImpl&gt; [0..*]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ reset()</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

NonPersistentPublisherStatsImpl2018762865[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)NonPersistentPublisherStatsImpl</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+   msgDropRate: double [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ add(stats: NonPersistentPublisherStatsImpl): NonPersistentPublisherStatsImpl</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

NonPersistentReplicator442146095[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)NonPersistentReplicator</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   msgDrop: Rate [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   msgOut: Rate [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   stats: NonPersistentReplicatorStatsImpl [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># disableReplicatorRead()</TD></TR>
<TR><TD ALIGN="LEFT" ># readEntries(producer: Producer&lt;byte[]&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ sendMessage(entry: Entry)</TD></TR>
<TR><TD ALIGN="LEFT" >+ updateRates()</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

NonPersistentReplicatorStatsImpl2018762865[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)NonPersistentReplicatorStatsImpl</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+   msgDropRate: double [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ add(stats: NonPersistentReplicatorStatsImpl): NonPersistentReplicatorStatsImpl</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

NonPersistentStickyKeyDispatcherMultipleConsumers442146095[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)NonPersistentStickyKeyDispatcherMultipleConsumers</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   keySharedMode: KeySharedMode [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   selector: StickyKeyConsumerSelector [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ addConsumer(consumer: Consumer)</TD></TR>
<TR><TD ALIGN="LEFT" >+ hasSameKeySharedPolicy(ksm: KeySharedMeta): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ removeConsumer(consumer: Consumer)</TD></TR>
<TR><TD ALIGN="LEFT" >+ sendMessages(entries: List&lt;Entry&gt;)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

NonPersistentSubscription442146095[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)NonPersistentSubscription</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   bytesOutFromRemovedConsumers: LongAdder [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   dispatcher: NonPersistentDispatcher [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   fullName: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   isDurable: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   isFenced: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   keySharedMode: KeySharedMode [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   lastActive: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   msgOutFromRemovedConsumer: LongAdder [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   subName: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   topic: NonPersistentTopic [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   topicName: String [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ acknowledgeMessage(position: List&lt;Position&gt;, ackType: AckType, properties: Map&lt;String, Long&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ addConsumer(consumer: Consumer): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ addUnAckedMessages(unAckMessages: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearBacklog(): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ close(): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ consumerFlow(consumer: Consumer, additionalNumberOfMessages: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ delete(): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- delete(closeIfConsumersConnected: boolean): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ deleteForcefully(): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ disconnect(): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ doUnsubscribe(consumer: Consumer): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ endTxn(txnidMostBits: long, txnidLeastBits: long, txnAction: int, lowWaterMark: long): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ expireMessages(messageTTLInSeconds: int): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ expireMessages(position: Position): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ getNumberOfEntriesInBacklog(getPreciseBacklog: boolean): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ interceptor(): BrokerInterceptor</TD></TR>
<TR><TD ALIGN="LEFT" >+ markTopicWithBatchMessagePublished()</TD></TR>
<TR><TD ALIGN="LEFT" >+ peekNthMessage(messagePosition: int): CompletableFuture&lt;Entry&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ redeliverUnacknowledgedMessages(consumer: Consumer, consumerEpoch: long)</TD></TR>
<TR><TD ALIGN="LEFT" >+ redeliverUnacknowledgedMessages(consumer: Consumer, positions: List&lt;PositionImpl&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ removeConsumer(consumer: Consumer, isResetCursor: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ resetCursor(timestamp: long): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ resetCursor(position: Position): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ skipMessages(numMessagesToSkip: int): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ updateLastActive()</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

NonPersistentSubscriptionStatsImpl2018762865[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)NonPersistentSubscriptionStatsImpl</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+   msgDropRate: double [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ add(stats: NonPersistentSubscriptionStatsImpl): NonPersistentSubscriptionStatsImpl</TD></TR>
<TR><TD ALIGN="LEFT" >+ reset()</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

NonPersistentTopic442146095[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)NonPersistentTopic</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   bytesOutFromRemovedSubscriptions: LongAdder [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   entriesAddedCounter: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   msgOutFromRemovedSubscriptions: LongAdder [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   replicators: ConcurrentOpenHashMap&lt;String, NonPersistentReplicator&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   subscriptions: ConcurrentOpenHashMap&lt;String, NonPersistentSubscription&gt; [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># addReplicationCluster(remoteCluster: String, nonPersistentTopic: NonPersistentTopic, localCluster: String): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ addSchemaIfIdleOrCheckCompatible(schema: SchemaData): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ asyncGetStats(getPreciseBacklog: boolean, subscriptionBacklogSize: boolean, getEarliestTimeInBacklog: boolean): CompletableFuture&lt;NonPersistentTopicStatsImpl&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ checkBacklogQuotaExceeded(producerName: String, backlogQuotaType: BacklogQuotaType): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ checkBackloggedCursors()</TD></TR>
<TR><TD ALIGN="LEFT" >+ checkDeduplicationSnapshot()</TD></TR>
<TR><TD ALIGN="LEFT" >+ checkGC()</TD></TR>
<TR><TD ALIGN="LEFT" >+ checkIfTransactionBufferRecoverCompletely(isTxnEnabled: boolean): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ checkInactiveSubscriptions()</TD></TR>
<TR><TD ALIGN="LEFT" >+ checkMessageDeduplicationInfo()</TD></TR>
<TR><TD ALIGN="LEFT" >+ checkMessageExpiry()</TD></TR>
<TR><TD ALIGN="LEFT" >+ checkReplication(): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- checkReplicationAndRetryOnFailure(): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ close(closeWithoutWaitingClientDisconnect: boolean): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ createSubscription(subscriptionName: String, initialPosition: InitialPosition, replicateSubscriptionState: boolean): CompletableFuture&lt;Subscription&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ delete(): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- delete(failIfHasSubscriptions: boolean, closeIfClientsConnected: boolean, deleteSchema: boolean): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ deleteForcefully(): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ endTxn(txnID: TxnID, txnAction: int, lowWaterMark: long): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getBacklogQuota(backlogQuotaType: BacklogQuotaType): BacklogQuota</TD></TR>
<TR><TD ALIGN="LEFT" >+ getInternalStats(includeLedgerMetadata: boolean): CompletableFuture&lt;PersistentTopicInternalStats&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getNumberOfSameAddressConsumers(clientAddress: String): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ getPersistentReplicator(remoteCluster: String): Replicator</TD></TR>
<TR><TD ALIGN="LEFT" >+ getStats(getPreciseBacklog: boolean, subscriptionBacklogSize: boolean, getEarliestTimeInBacklog: boolean): NonPersistentTopicStatsImpl</TD></TR>
<TR><TD ALIGN="LEFT" >+ getSubscription(subscription: String): Subscription</TD></TR>
<TR><TD ALIGN="LEFT" ># incrementTopicEpoch(currentEpoch: Optional&lt;Long&gt;): CompletableFuture&lt;Long&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ initialize(): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- internalSubscribe(cnx: TransportCnx, subscriptionName: String, consumerId: long, subType: SubType, priorityLevel: int, consumerName: String, isDurable: boolean, startMessageId: MessageId, metadata: Map&lt;String, String&gt;, readCompacted: boolean, initialPosition: InitialPosition, resetStartMessageBackInSec: long, replicateSubscriptionState: boolean, keySharedMeta: KeySharedMeta): CompletableFuture&lt;Consumer&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ onPoliciesUpdate(data: Policies): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ onUpdate(data: TopicPolicies)</TD></TR>
<TR><TD ALIGN="LEFT" >+ publishMessage(data: ByteBuf, callback: PublishContext)</TD></TR>
<TR><TD ALIGN="LEFT" >+ publishTxnMessage(txnID: TxnID, headersAndPayload: ByteBuf, publishContext: PublishContext)</TD></TR>
<TR><TD ALIGN="LEFT" >+ removeProducer(producer: Producer)</TD></TR>
<TR><TD ALIGN="LEFT" ># removeReplicator(remoteCluster: String): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># setTopicEpoch(newEpoch: long): CompletableFuture&lt;Long&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># startReplicator(remoteCluster: String): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ stopReplProducers(): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ subscribe(option: SubscriptionOption): CompletableFuture&lt;Consumer&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ subscribe(cnx: TransportCnx, subscriptionName: String, consumerId: long, subType: SubType, priorityLevel: int, consumerName: String, isDurable: boolean, startMessageId: MessageId, metadata: Map&lt;String, String&gt;, readCompacted: boolean, initialPosition: InitialPosition, resetStartMessageBackInSec: long, replicateSubscriptionState: boolean, keySharedMeta: KeySharedMeta): CompletableFuture&lt;Consumer&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ truncate(): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- tryToDeletePartitionedMetadata(): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ unsubscribe(subscriptionName: String): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ updateRates(nsStats: NamespaceStats, bundleStats: NamespaceBundleStats, topicStatsStream: StatsOutputStream, replStats: ClusterReplicationMetrics, namespace: String, hydratePublishers: boolean)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

NonPersistentTopicStatsImpl2018762865[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)NonPersistentTopicStatsImpl</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+   msgDropRate: double [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   nonPersistentPublishers: List&lt;NonPersistentPublisherStats&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   nonPersistentPublishersMap: Map&lt;String, NonPersistentPublisherStats&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >+   nonPersistentReplicators: Map&lt;String, ? extends NonPersistentReplicatorStats&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >+   nonPersistentSubscriptions: Map&lt;String, ? extends NonPersistentSubscriptionStats&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >+   publishers: List&lt;PublisherStatsImpl&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >+   replication: Map&lt;String, ReplicatorStatsImpl&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >+   subscriptions: Map&lt;String, SubscriptionStatsImpl&gt; [0..*]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ add(ts: NonPersistentTopicStats): NonPersistentTopicStatsImpl</TD></TR>
<TR><TD ALIGN="LEFT" >+ addPublisher(stats: NonPersistentPublisherStatsImpl)</TD></TR>
<TR><TD ALIGN="LEFT" >+ reset()</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

NonPersistentTopics620988779[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)NonPersistentTopics</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ createPartitionedTopic(asyncResponse: AsyncResponse, tenant: String, namespace: String, encodedTopic: String, numPartitions: int, createLocalTopicOnly: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ getInternalStats(tenant: String, namespace: String, encodedTopic: String, authoritative: boolean, metadata: boolean): PersistentTopicInternalStats</TD></TR>
<TR><TD ALIGN="LEFT" >+ getList(asyncResponse: AsyncResponse, tenant: String, namespace: String, nsBundle: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ getListFromBundle(asyncResponse: AsyncResponse, tenant: String, namespace: String, bundleRange: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ getPartitionedMetadata(tenant: String, namespace: String, encodedTopic: String, authoritative: boolean, checkAllowAutoCreation: boolean): PartitionedTopicMetadata</TD></TR>
<TR><TD ALIGN="LEFT" >+ getPartitionedStats(asyncResponse: AsyncResponse, tenant: String, namespace: String, encodedTopic: String, perPartition: boolean, authoritative: boolean, getPreciseBacklog: boolean, subscriptionBacklogSize: boolean, getEarliestTimeInBacklog: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ getStats(tenant: String, namespace: String, encodedTopic: String, authoritative: boolean, getPreciseBacklog: boolean, subscriptionBacklogSize: boolean, getEarliestTimeInBacklog: boolean): NonPersistentTopicStats</TD></TR>
<TR><TD ALIGN="LEFT" >- getTopicReference(topicName: TopicName): Topic</TD></TR>
<TR><TD ALIGN="LEFT" >+ truncateTopic(asyncResponse: AsyncResponse, tenant: String, namespace: String, encodedTopic: String, authoritative: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ unloadTopic(asyncResponse: AsyncResponse, tenant: String, namespace: String, encodedTopic: String, authoritative: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" ># validateAdminOperationOnTopic(topicName: TopicName, authoritative: boolean)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

NonPersistentTopics620988780[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)NonPersistentTopics</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ createPartitionedTopic(asyncResponse: AsyncResponse, property: String, cluster: String, namespace: String, encodedTopic: String, numPartitions: int, createLocalTopicOnly: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ getInternalStats(property: String, cluster: String, namespace: String, encodedTopic: String, authoritative: boolean, metadata: boolean): PersistentTopicInternalStats</TD></TR>
<TR><TD ALIGN="LEFT" >+ getList(asyncResponse: AsyncResponse, property: String, cluster: String, namespace: String, nsBundle: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ getListFromBundle(property: String, cluster: String, namespace: String, bundleRange: String): List&lt;String&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getPartitionedMetadata(property: String, cluster: String, namespace: String, encodedTopic: String, authoritative: boolean, checkAllowAutoCreation: boolean): PartitionedTopicMetadata</TD></TR>
<TR><TD ALIGN="LEFT" >+ getStats(property: String, cluster: String, namespace: String, encodedTopic: String, authoritative: boolean, getPreciseBacklog: boolean): NonPersistentTopicStats</TD></TR>
<TR><TD ALIGN="LEFT" >- getTopicReference(topicName: TopicName): Topic</TD></TR>
<TR><TD ALIGN="LEFT" >+ unloadTopic(asyncResponse: AsyncResponse, property: String, cluster: String, namespace: String, encodedTopic: String, authoritative: boolean)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

NonPersistentTopicsImpl1292556772[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)NonPersistentTopicsImpl</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   adminNonPersistentTopics: WebTarget [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   adminV2NonPersistentTopics: WebTarget [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ createPartitionedTopic(topic: String, numPartitions: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ createPartitionedTopicAsync(topic: String, numPartitions: int): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getInternalStats(topic: String): PersistentTopicInternalStats</TD></TR>
<TR><TD ALIGN="LEFT" >+ getInternalStatsAsync(topic: String): CompletableFuture&lt;PersistentTopicInternalStats&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getList(namespace: String): List&lt;String&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getListAsync(namespace: String): CompletableFuture&lt;List&lt;String&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getListInBundle(namespace: String, bundleRange: String): List&lt;String&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getListInBundleAsync(namespace: String, bundleRange: String): CompletableFuture&lt;List&lt;String&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getPartitionedTopicMetadata(topic: String): PartitionedTopicMetadata</TD></TR>
<TR><TD ALIGN="LEFT" >+ getPartitionedTopicMetadataAsync(topic: String): CompletableFuture&lt;PartitionedTopicMetadata&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getStats(topic: String): NonPersistentTopicStats</TD></TR>
<TR><TD ALIGN="LEFT" >+ getStatsAsync(topic: String): CompletableFuture&lt;NonPersistentTopicStats&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- namespacePath(domain: String, namespace: NamespaceName, parts: String...): WebTarget</TD></TR>
<TR><TD ALIGN="LEFT" >- topicPath(topic: TopicName, parts: String...): WebTarget</TD></TR>
<TR><TD ALIGN="LEFT" >+ unload(topic: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ unloadAsync(topic: String): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- validateTopic(topic: String): TopicName</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

NoopLoadManager1871869916[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)NoopLoadManager</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   localResourceUnit: ResourceUnit [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   lockManager: LockManager&lt;LocalBrokerData&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   lookupServiceAddress: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   pulsar: PulsarService [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ disableBroker()</TD></TR>
<TR><TD ALIGN="LEFT" >+ doLoadShedding()</TD></TR>
<TR><TD ALIGN="LEFT" >+ doNamespaceBundleSplit()</TD></TR>
<TR><TD ALIGN="LEFT" >+ generateLoadReport(): LoadManagerReport</TD></TR>
<TR><TD ALIGN="LEFT" >+ getLeastLoaded(su: ServiceUnitId): Optional&lt;ResourceUnit&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ initialize(pulsar: PulsarService)</TD></TR>
<TR><TD ALIGN="LEFT" >+ start()</TD></TR>
<TR><TD ALIGN="LEFT" >+ stop()</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeLoadReportOnZookeeper()</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeResourceQuotasToZooKeeper()</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

NotAllowedException1254029274[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)NotAllowedException</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

ObjectMapperFactory1762718902[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)ObjectMapperFactory</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ create(): ObjectMapper</TD></TR>
<TR><TD ALIGN="LEFT" >+ createYaml(): ObjectMapper</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

ObserverGauge1852472696[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)ObserverGauge</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   supplier: Supplier&lt;Number&gt; [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ build(name: String, help: String): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ build(): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ collect(): List&lt;MetricFamilySamples&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ describe(): List&lt;MetricFamilySamples&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># newChild(): Child</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

OffloadPoliciesImpl896442176[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)OffloadPoliciesImpl</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   fileSystemProfilePath: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   fileSystemURI: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   gcsManagedLedgerOffloadBucket: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   gcsManagedLedgerOffloadMaxBlockSizeInBytes: Integer [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   gcsManagedLedgerOffloadReadBufferSizeInBytes: Integer [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   gcsManagedLedgerOffloadRegion: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   gcsManagedLedgerOffloadServiceAccountKeyFile: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   managedLedgerOffloadBucket: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   managedLedgerOffloadDeletionLagInMillis: Long [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   managedLedgerOffloadDriver: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   managedLedgerOffloadMaxBlockSizeInBytes: Integer [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   managedLedgerOffloadMaxThreads: Integer [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   managedLedgerOffloadPrefetchRounds: Integer [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   managedLedgerOffloadReadBufferSizeInBytes: Integer [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   managedLedgerOffloadRegion: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   managedLedgerOffloadServiceEndpoint: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   managedLedgerOffloadThresholdInBytes: Long [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   managedLedgerOffloadedReadPriority: OffloadedReadPriority [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   offloadersDirectory: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   s3ManagedLedgerOffloadBucket: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   s3ManagedLedgerOffloadCredentialId: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   s3ManagedLedgerOffloadCredentialSecret: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   s3ManagedLedgerOffloadMaxBlockSizeInBytes: Integer [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   s3ManagedLedgerOffloadReadBufferSizeInBytes: Integer [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   s3ManagedLedgerOffloadRegion: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   s3ManagedLedgerOffloadRole: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   s3ManagedLedgerOffloadRoleSessionName: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   s3ManagedLedgerOffloadServiceEndpoint: String [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ bucketValid(): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ builder(): OffloadPoliciesImplBuilder</TD></TR>
<TR><TD ALIGN="LEFT" ># canEqual(other: Object): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ compatibleWithBrokerConfigFile(properties: Properties)</TD></TR>
<TR><TD ALIGN="LEFT" >+ create(driver: String, region: String, bucket: String, endpoint: String, role: String, roleSessionName: String, credentialId: String, credentialSecret: String, maxBlockSizeInBytes: Integer, readBufferSizeInBytes: Integer, offloadThresholdInBytes: Long, offloadDeletionLagInMillis: Long, readPriority: OffloadedReadPriority): OffloadPoliciesImpl</TD></TR>
<TR><TD ALIGN="LEFT" >+ create(properties: Properties): OffloadPoliciesImpl</TD></TR>
<TR><TD ALIGN="LEFT" >+ driverSupported(): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >- getCompatibleValue(properties: Properties, field: Field): Object</TD></TR>
<TR><TD ALIGN="LEFT" >+ mergeConfiguration(topicLevelPolicies: OffloadPoliciesImpl, nsLevelPolicies: OffloadPoliciesImpl, brokerProperties: Properties): OffloadPoliciesImpl</TD></TR>
<TR><TD ALIGN="LEFT" >+ oldPoliciesCompatible(nsLevelPolicies: OffloadPoliciesImpl, policies: Policies): OffloadPoliciesImpl</TD></TR>
<TR><TD ALIGN="LEFT" >+ toProperties(): Properties</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

OffloadPoliciesImplBuilder747653943[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)OffloadPoliciesImplBuilder</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   impl: OffloadPoliciesImpl [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ build(): OffloadPoliciesImpl</TD></TR>
<TR><TD ALIGN="LEFT" >+ fileSystemProfilePath(fileSystemProfilePath: String): OffloadPoliciesImplBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ fileSystemURI(fileSystemURI: String): OffloadPoliciesImplBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ gcsManagedLedgerOffloadBucket(gcsManagedLedgerOffloadBucket: String): OffloadPoliciesImplBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ gcsManagedLedgerOffloadMaxBlockSizeInBytes(gcsManagedLedgerOffloadMaxBlockSizeInBytes: Integer): OffloadPoliciesImplBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ gcsManagedLedgerOffloadReadBufferSizeInBytes(gcsManagedLedgerOffloadReadBufferSizeInBytes: Integer): OffloadPoliciesImplBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ gcsManagedLedgerOffloadRegion(gcsManagedLedgerOffloadRegion: String): OffloadPoliciesImplBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ gcsManagedLedgerOffloadServiceAccountKeyFile(gcsManagedLedgerOffloadServiceAccountKeyFile: String): OffloadPoliciesImplBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ managedLedgerOffloadBucket(managedLedgerOffloadBucket: String): OffloadPoliciesImplBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ managedLedgerOffloadDeletionLagInMillis(managedLedgerOffloadDeletionLagInMillis: Long): OffloadPoliciesImplBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ managedLedgerOffloadDriver(managedLedgerOffloadDriver: String): OffloadPoliciesImplBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ managedLedgerOffloadMaxBlockSizeInBytes(managedLedgerOffloadMaxBlockSizeInBytes: Integer): OffloadPoliciesImplBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ managedLedgerOffloadMaxThreads(managedLedgerOffloadMaxThreads: Integer): OffloadPoliciesImplBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ managedLedgerOffloadPrefetchRounds(managedLedgerOffloadPrefetchRounds: Integer): OffloadPoliciesImplBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ managedLedgerOffloadReadBufferSizeInBytes(managedLedgerOffloadReadBufferSizeInBytes: Integer): OffloadPoliciesImplBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ managedLedgerOffloadRegion(managedLedgerOffloadRegion: String): OffloadPoliciesImplBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ managedLedgerOffloadServiceEndpoint(managedLedgerOffloadServiceEndpoint: String): OffloadPoliciesImplBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ managedLedgerOffloadThresholdInBytes(managedLedgerOffloadThresholdInBytes: Long): OffloadPoliciesImplBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ managedLedgerOffloadedReadPriority(managedLedgerOffloadedReadPriority: OffloadedReadPriority): OffloadPoliciesImplBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ offloadersDirectory(offloadersDirectory: String): OffloadPoliciesImplBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ s3ManagedLedgerOffloadBucket(s3ManagedLedgerOffloadBucket: String): OffloadPoliciesImplBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ s3ManagedLedgerOffloadCredentialId(s3ManagedLedgerOffloadCredentialId: String): OffloadPoliciesImplBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ s3ManagedLedgerOffloadCredentialSecret(s3ManagedLedgerOffloadCredentialSecret: String): OffloadPoliciesImplBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ s3ManagedLedgerOffloadMaxBlockSizeInBytes(s3ManagedLedgerOffloadMaxBlockSizeInBytes: Integer): OffloadPoliciesImplBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ s3ManagedLedgerOffloadReadBufferSizeInBytes(s3ManagedLedgerOffloadReadBufferSizeInBytes: Integer): OffloadPoliciesImplBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ s3ManagedLedgerOffloadRegion(s3ManagedLedgerOffloadRegion: String): OffloadPoliciesImplBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ s3ManagedLedgerOffloadRole(s3ManagedLedgerOffloadRole: String): OffloadPoliciesImplBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ s3ManagedLedgerOffloadRoleSessionName(s3ManagedLedgerOffloadRoleSessionName: String): OffloadPoliciesImplBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ s3ManagedLedgerOffloadServiceEndpoint(s3ManagedLedgerOffloadServiceEndpoint: String): OffloadPoliciesImplBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ setS3ManagedLedgerOffloadRoleSessionName(s3ManagedLedgerOffloadRoleSessionName: String): Builder</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

OneStageAuthenticationState978396142[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)OneStageAuthenticationState</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   authRole: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   authenticationDataSource: AuthenticationDataSource [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ authenticate(authData: AuthData): AuthData</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

OpRequestSend934907670[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)OpRequestSend</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   byteBuf: ByteBuf [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   cb: CompletableFuture&lt;TxnID&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   createdAt: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   recyclerHandle: Handle&lt;OpRequestSend&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   requestId: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   topic: String [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># create(requestId: long, topic: String, byteBuf: ByteBuf, cb: CompletableFuture&lt;TxnID&gt;): OpRequestSend</TD></TR>
<TR><TD ALIGN="LEFT" ># recycle()</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

PackagesBase229910521[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)PackagesBase</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   authorizationService: AuthorizationService [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- checkPermissions(tenant: String, namespace: String): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- getPackageNameAsync(type: String, tenant: String, namespace: String, packageName: String, version: String): CompletableFuture&lt;PackageName&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- handleError(throwable: Throwable, asyncResponse: AsyncResponse): Void</TD></TR>
<TR><TD ALIGN="LEFT" ># internalDelete(type: String, tenant: String, namespace: String, packageName: String, version: String, asyncResponse: AsyncResponse)</TD></TR>
<TR><TD ALIGN="LEFT" ># internalDownload(type: String, tenant: String, namespace: String, packageName: String, version: String): StreamingOutput</TD></TR>
<TR><TD ALIGN="LEFT" ># internalGetMetadata(type: String, tenant: String, namespace: String, packageName: String, version: String, asyncResponse: AsyncResponse)</TD></TR>
<TR><TD ALIGN="LEFT" ># internalListPackages(type: String, tenant: String, namespace: String, asyncResponse: AsyncResponse)</TD></TR>
<TR><TD ALIGN="LEFT" ># internalListVersions(type: String, tenant: String, namespace: String, packageName: String, asyncResponse: AsyncResponse)</TD></TR>
<TR><TD ALIGN="LEFT" ># internalUpdateMetadata(type: String, tenant: String, namespace: String, packageName: String, version: String, metadata: PackageMetadata, asyncResponse: AsyncResponse)</TD></TR>
<TR><TD ALIGN="LEFT" ># internalUpload(type: String, tenant: String, namespace: String, packageName: String, version: String, metadata: PackageMetadata, uploadedInputStream: InputStream, asyncResponse: AsyncResponse)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

ParserProxyHandler79518146[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)ParserProxyHandler</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   channel: Channel [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   cmd: BaseCommand [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   connType: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   maxMessageSize: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   peerChannelId: ChannelId [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   service: ProxyService [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ channelRead(ctx: ChannelHandlerContext, msg: Object)</TD></TR>
<TR><TD ALIGN="LEFT" >- logging(conn: Channel, cmdtype: Type, info: String, messages: List&lt;RawMessage&gt;)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

PartitionedProducerImpl12001400[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)PartitionedProducerImpl&lt;T&gt;</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   firstPartitionIndex: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   overrideProducerName: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   partitionsAutoUpdateFuture: CompletableFuture&lt;Void&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   partitionsAutoUpdateTimeout: Timeout [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   partitionsAutoUpdateTimerTask: TimerTask [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   producers: ConcurrentOpenHashMap&lt;Integer, ProducerImpl&lt;T&gt;&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   routerPolicy: MessageRouter [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   stats: ProducerStatsRecorderImpl [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   topicMetadata: TopicMetadata [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   topicsPartitionChangedListener: TopicsPartitionChangedListener [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ closeAsync(): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- createProducer(partitionIndex: int): ProducerImpl&lt;T&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- createProducer(partitionIndex: int, overrideProducerName: Optional&lt;String&gt;): ProducerImpl&lt;T&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ flushAsync(): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># internalSendAsync(message: Message&lt;?&gt;): CompletableFuture&lt;MessageId&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># internalSendWithTxnAsync(message: Message&lt;?&gt;, txn: Transaction): CompletableFuture&lt;MessageId&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- start(indexList: List&lt;Integer&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" ># triggerFlush()</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

PartitionedTopicMetadata21576542[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)PartitionedTopicMetadata</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+   partitions: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   properties: Map&lt;String, String&gt; [0..*]</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

PartitionedTopicResources2098679213[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)PartitionedTopicResources</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ clearPartitionedTopicMetadataAsync(namespaceName: NamespaceName): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearPartitionedTopicTenantAsync(tenant: String): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ createPartitionedTopic(tn: TopicName, tm: PartitionedTopicMetadata)</TD></TR>
<TR><TD ALIGN="LEFT" >+ createPartitionedTopicAsync(tn: TopicName, tm: PartitionedTopicMetadata): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ deletePartitionedTopicAsync(tn: TopicName): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getPartitionedTopicMetadataAsync(tn: TopicName): CompletableFuture&lt;Optional&lt;PartitionedTopicMetadata&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ listPartitionedTopicsAsync(ns: NamespaceName, domain: TopicDomain): CompletableFuture&lt;List&lt;String&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ partitionedTopicExists(tn: TopicName): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ partitionedTopicExistsAsync(tn: TopicName): CompletableFuture&lt;Boolean&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ updatePartitionedTopicAsync(tn: TopicName, f: Function&lt;PartitionedTopicMetadata, PartitionedTopicMetadata&gt;): CompletableFuture&lt;Void&gt;</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

PartitionedTopicStatsImpl2018762865[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)PartitionedTopicStatsImpl</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+   metadata: PartitionedTopicMetadata [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   partitions: Map&lt;String, TopicStats&gt; [0..*]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ reset()</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

PendingAckHandleDisabled1598175378[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)PendingAckHandleDisabled</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   pendingAckHandleCompletableFuture: CompletableFuture&lt;PendingAckHandle&gt; [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ abortTxn(txnId: TxnID, consumer: Consumer, lowWaterMark: long): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ checkIfPendingAckStoreInit(): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ checkIsCanDeleteConsumerPendingAck(position: PositionImpl): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearIndividualPosition(position: Position)</TD></TR>
<TR><TD ALIGN="LEFT" >+ close(): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ commitTxn(txnID: TxnID, properties: Map&lt;String, Long&gt;, lowWaterMark: long): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ cumulativeAcknowledgeMessage(txnID: TxnID, positions: List&lt;PositionImpl&gt;): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getTransactionInPendingAckStats(txnID: TxnID): TransactionInPendingAckStats</TD></TR>
<TR><TD ALIGN="LEFT" >+ individualAcknowledgeMessage(txnID: TxnID, positions: List&lt;MutablePair&lt;PositionImpl, Integer&gt;&gt;): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ pendingAckHandleFuture(): CompletableFuture&lt;PendingAckHandle&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ syncBatchPositionAckSetForTransaction(position: PositionImpl)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

PendingAckHandleImpl1598175378[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)PendingAckHandleImpl</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   acceptQueue: BlockingQueue&lt;Runnable&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   cumulativeAckOfTransaction: Pair&lt;TxnID, PositionImpl&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   individualAckOfTransaction: LinkedMap&lt;TxnID, HashMap&lt;PositionImpl, PositionImpl&gt;&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   individualAckPositions: Map&lt;PositionImpl, MutablePair&lt;PositionImpl, Integer&gt;&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   internalPinnedExecutor: ExecutorService [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   pendingAckHandleCompletableFuture: CompletableFuture&lt;PendingAckHandle&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   pendingAckStoreFuture: CompletableFuture&lt;PendingAckStore&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   pendingAckStoreProvider: TransactionPendingAckStoreProvider [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   persistentSubscription: PersistentSubscription [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   subName: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   topicName: String [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ abortTxn(txnId: TxnID, consumer: Consumer, lowWaterMark: long): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- addAbortTxnRequest(txnId: TxnID, consumer: Consumer, lowWaterMark: long, completableFuture: CompletableFuture&lt;Void&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >- addCommitTxnRequest(txnId: TxnID, properties: Map&lt;String, Long&gt;, lowWaterMark: long, completableFuture: CompletableFuture&lt;Void&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >- addCumulativeAcknowledgeMessageRequest(txnID: TxnID, positions: List&lt;PositionImpl&gt;, completableFuture: CompletableFuture&lt;Void&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >- addIndividualAcknowledgeMessageRequest(txnID: TxnID, positions: List&lt;MutablePair&lt;PositionImpl, Integer&gt;&gt;, completableFuture: CompletableFuture&lt;Void&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ checkIfPendingAckStoreInit(): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ checkIsCanDeleteConsumerPendingAck(position: PositionImpl): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearIndividualPosition(position: Position)</TD></TR>
<TR><TD ALIGN="LEFT" >+ close(): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ commitTxn(txnID: TxnID, properties: Map&lt;String, Long&gt;, lowWaterMark: long): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ completeHandleFuture()</TD></TR>
<TR><TD ALIGN="LEFT" >+ cumulativeAcknowledgeMessage(txnID: TxnID, positions: List&lt;PositionImpl&gt;): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ exceptionHandleFuture(t: Throwable)</TD></TR>
<TR><TD ALIGN="LEFT" >+ getTransactionInPendingAckStats(txnID: TxnID): TransactionInPendingAckStats</TD></TR>
<TR><TD ALIGN="LEFT" ># handleAbort(txnID: TxnID, ackType: AckType)</TD></TR>
<TR><TD ALIGN="LEFT" ># handleCacheRequest()</TD></TR>
<TR><TD ALIGN="LEFT" ># handleCommit(txnID: TxnID, ackType: AckType, properties: Map&lt;String, Long&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >- handleCumulativeAck(txnID: TxnID, position: PositionImpl)</TD></TR>
<TR><TD ALIGN="LEFT" ># handleCumulativeAckRecover(txnID: TxnID, position: PositionImpl)</TD></TR>
<TR><TD ALIGN="LEFT" >- handleIndividualAck(txnID: TxnID, positions: List&lt;MutablePair&lt;PositionImpl, Integer&gt;&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" ># handleIndividualAckRecover(txnID: TxnID, positions: List&lt;MutablePair&lt;PositionImpl, Integer&gt;&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >- handleLowWaterMark(txnID: TxnID, lowWaterMark: long)</TD></TR>
<TR><TD ALIGN="LEFT" >- individualAckAbortCommon(txnID: TxnID, currentTxn: HashMap&lt;PositionImpl, PositionImpl&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >- individualAckCommitCommon(txnID: TxnID, currentTxn: HashMap&lt;PositionImpl, PositionImpl&gt;, properties: Map&lt;String, Long&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ individualAcknowledgeMessage(txnID: TxnID, positions: List&lt;MutablePair&lt;PositionImpl, Integer&gt;&gt;): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- initPendingAckStore()</TD></TR>
<TR><TD ALIGN="LEFT" >+ internalAbortTxn(txnId: TxnID, consumer: Consumer, lowWaterMark: long, abortFuture: CompletableFuture&lt;Void&gt;): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- internalCommitTxn(txnID: TxnID, properties: Map&lt;String, Long&gt;, lowWaterMark: long, commitFuture: CompletableFuture&lt;Void&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ internalCumulativeAcknowledgeMessage(txnID: TxnID, positions: List&lt;PositionImpl&gt;, completableFuture: CompletableFuture&lt;Void&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ internalIndividualAcknowledgeMessage(txnID: TxnID, positions: List&lt;MutablePair&lt;PositionImpl, Integer&gt;&gt;, completableFuture: CompletableFuture&lt;Void&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ pendingAckHandleFuture(): CompletableFuture&lt;PendingAckHandle&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ syncBatchPositionAckSetForTransaction(position: PositionImpl)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

PersistenceException1254029274[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)PersistenceException</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

PersistentAcknowledgmentsGroupingTracker12001400[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)PersistentAcknowledgmentsGroupingTracker</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   ackReceiptEnabled: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   acknowledgementGroupTimeMicros: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   batchIndexAckEnabled: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   consumer: ConsumerImpl&lt;?&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   cumulativeAckFlushRequired: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   currentCumulativeAckFuture: TimedCompletableFuture&lt;Void&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   currentIndividualAckFuture: TimedCompletableFuture&lt;Void&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   lastCumulativeAck: LastCumulativeAck [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   lock: ReentrantReadWriteLock [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   pendingIndividualAcks: ConcurrentSkipListSet&lt;MessageIdImpl&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   pendingIndividualBatchIndexAcks: ConcurrentHashMap&lt;MessageIdImpl, ConcurrentBitSetRecyclable&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   scheduledTask: ScheduledFuture&lt;?&gt; [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ addAcknowledgment(msgId: MessageIdImpl, ackType: AckType, properties: Map&lt;String, Long&gt;): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ addListAcknowledgment(messageIds: List&lt;MessageId&gt;, ackType: AckType, properties: Map&lt;String, Long&gt;): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- addListAcknowledgment(messageIds: List&lt;MessageId&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >- clearMessageIdFromUnAckTrackerAndDeadLetter(messageId: MessageIdImpl)</TD></TR>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >- doCumulativeAck(messageId: MessageIdImpl, properties: Map&lt;String, Long&gt;, bitSet: BitSetRecyclable): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- doCumulativeAckAsync(msgId: MessageIdImpl, bitSet: BitSetRecyclable)</TD></TR>
<TR><TD ALIGN="LEFT" >- doCumulativeBatchIndexAck(batchMessageId: BatchMessageIdImpl, properties: Map&lt;String, Long&gt;): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- doImmediateAck(msgId: MessageIdImpl, ackType: AckType, properties: Map&lt;String, Long&gt;, bitSet: BitSetRecyclable): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- doImmediateBatchIndexAck(msgId: BatchMessageIdImpl, batchIndex: int, batchSize: int, ackType: AckType, properties: Map&lt;String, Long&gt;): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- doIndividualAck(messageId: MessageIdImpl, properties: Map&lt;String, Long&gt;): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- doIndividualAckAsync(messageId: MessageIdImpl)</TD></TR>
<TR><TD ALIGN="LEFT" >- doIndividualBatchAck(batchMessageId: BatchMessageIdImpl, properties: Map&lt;String, Long&gt;): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- doIndividualBatchAck(batchMessageId: BatchMessageIdImpl): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- doIndividualBatchAckAsync(batchMessageId: BatchMessageIdImpl)</TD></TR>
<TR><TD ALIGN="LEFT" >+ flush()</TD></TR>
<TR><TD ALIGN="LEFT" >+ flushAndClean()</TD></TR>
<TR><TD ALIGN="LEFT" >- flushAsync(cnx: ClientCnx)</TD></TR>
<TR><TD ALIGN="LEFT" >- isAckReceiptEnabled(cnx: ClientCnx): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ isDuplicate(messageId: MessageId): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >- modifyBatchMessageIdAndStatesInConsumer(batchMessageId: BatchMessageIdImpl): MessageIdImpl</TD></TR>
<TR><TD ALIGN="LEFT" >- modifyMessageIdStatesInConsumer(messageId: MessageIdImpl)</TD></TR>
<TR><TD ALIGN="LEFT" >- newImmediateAckAndFlush(consumerId: long, msgId: MessageIdImpl, bitSet: BitSetRecyclable, ackType: AckType, map: Map&lt;String, Long&gt;, cnx: ClientCnx): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- newMessageAckCommandAndWrite(cnx: ClientCnx, consumerId: long, ledgerId: long, entryId: long, ackSet: BitSetRecyclable, ackType: AckType, validationError: ValidationError, properties: Map&lt;String, Long&gt;, flush: boolean, timedCompletableFuture: TimedCompletableFuture&lt;Void&gt;, entriesToAck: List&lt;Triple&lt;Long, Long, ConcurrentBitSetRecyclable&gt;&gt;): CompletableFuture&lt;Void&gt;</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

PersistentDispatcherMultipleConsumers1101090806[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)PersistentDispatcherMultipleConsumers</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   blockedDispatcherOnUnackedMsgs: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   closeFuture: CompletableFuture&lt;Void&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   cursor: ManagedCursor [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   delayedDeliveryTracker: Optional&lt;DelayedDeliveryTracker&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   dispatchRateLimiter: Optional&lt;DispatchRateLimiter&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   havePendingRead: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   havePendingReplayRead: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   lastIndividualDeletedRangeFromCursorRecovery: Range&lt;PositionImpl&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   minReplayedPosition: PositionImpl [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   name: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   readBatchSize: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   readFailureBackoff: Backoff [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   redeliveryMessages: MessageRedeliveryController [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   redeliveryTracker: RedeliveryTracker [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   shouldRewindBeforeReadingOrReplaying: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   topic: PersistentTopic [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   totalAvailablePermits: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   totalUnackedMessages: int [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ addConsumer(consumer: Consumer)</TD></TR>
<TR><TD ALIGN="LEFT" ># addMessageToReplay(ledgerId: long, entryId: long, stickyKeyHash: long): boolean</TD></TR>
<TR><TD ALIGN="LEFT" ># addMessageToReplay(ledgerId: long, entryId: long): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ addUnAckedMessages(numberOfMessages: int)</TD></TR>
<TR><TD ALIGN="LEFT" ># asyncReplayEntries(positions: Set&lt;? extends Position&gt;): Set&lt;? extends Position&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># asyncReplayEntriesInOrder(positions: Set&lt;? extends Position&gt;): Set&lt;? extends Position&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ blockDispatcherOnUnackedMsgs()</TD></TR>
<TR><TD ALIGN="LEFT" ># calculateToRead(currentTotalAvailablePermits: int): Pair&lt;Integer, Long&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ canUnsubscribe(consumer: Consumer): boolean</TD></TR>
<TR><TD ALIGN="LEFT" ># cancelPendingRead()</TD></TR>
<TR><TD ALIGN="LEFT" >+ checkAndUnblockIfStuck(): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >- checkIfMessageIsUnacked(ledgerId: long, entryId: long): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearDelayedMessages()</TD></TR>
<TR><TD ALIGN="LEFT" >+ close(): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ consumerFlow(consumer: Consumer, additionalNumberOfMessages: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ cursorIsReset()</TD></TR>
<TR><TD ALIGN="LEFT" >+ disconnectActiveConsumers(isResetCursor: boolean): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ disconnectAllConsumers(isResetCursor: boolean): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># getMessagesToReplayNow(maxMessagesToRead: int): Set&lt;PositionImpl&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># getStickyKeyHash(entry: Entry): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ initializeDispatchRateLimiterIfNeeded(): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ isConsumerAvailable(consumer: Consumer): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >- needTrimAckedMessages(): boolean</TD></TR>
<TR><TD ALIGN="LEFT" ># reScheduleRead()</TD></TR>
<TR><TD ALIGN="LEFT" >+ readEntriesComplete(entries: List&lt;Entry&gt;, ctx: Object)</TD></TR>
<TR><TD ALIGN="LEFT" >+ readEntriesFailed(exception: ManagedLedgerException, ctx: Object)</TD></TR>
<TR><TD ALIGN="LEFT" >+ readMoreEntries()</TD></TR>
<TR><TD ALIGN="LEFT" >+ redeliverUnacknowledgedMessages(consumer: Consumer, consumerEpoch: long)</TD></TR>
<TR><TD ALIGN="LEFT" >+ redeliverUnacknowledgedMessages(consumer: Consumer, positions: List&lt;PositionImpl&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ removeConsumer(consumer: Consumer)</TD></TR>
<TR><TD ALIGN="LEFT" >+ reset()</TD></TR>
<TR><TD ALIGN="LEFT" >+ resetCloseFuture()</TD></TR>
<TR><TD ALIGN="LEFT" ># sendMessagesToConsumers(readType: ReadType, entries: List&lt;Entry&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ trackDelayedDelivery(ledgerId: long, entryId: long, msgMetadata: MessageMetadata): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ unBlockDispatcherOnUnackedMsgs()</TD></TR>
<TR><TD ALIGN="LEFT" >+ updateRateLimiter()</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

PersistentDispatcherSingleActiveConsumer1101090806[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)PersistentDispatcherSingleActiveConsumer</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   dispatchRateLimiter: Optional&lt;DispatchRateLimiter&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   havePendingRead: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   name: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   readBatchSize: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   readFailureBackoff: Backoff [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   readOnActiveConsumerTask: ScheduledFuture&lt;?&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   redeliveryTracker: RedeliveryTracker [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   topic: PersistentTopic [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ addUnAckedMessages(unAckMessages: int)</TD></TR>
<TR><TD ALIGN="LEFT" ># calculateToRead(consumer: Consumer): Pair&lt;Integer, Long&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># cancelPendingRead()</TD></TR>
<TR><TD ALIGN="LEFT" >+ checkAndUnblockIfStuck(): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ close(): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ consumerFlow(consumer: Consumer, additionalNumberOfMessages: int)</TD></TR>
<TR><TD ALIGN="LEFT" ># dispatchEntriesToConsumer(currentConsumer: Consumer, entries: List&lt;Entry&gt;, batchSizes: EntryBatchSizes, batchIndexesAcks: EntryBatchIndexesAcks, sendMessageInfo: SendMessageInfo, epoch: long)</TD></TR>
<TR><TD ALIGN="LEFT" >+ initializeDispatchRateLimiterIfNeeded(): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >- internalConsumerFlow(consumer: Consumer)</TD></TR>
<TR><TD ALIGN="LEFT" >+ internalReadEntriesComplete(entries: List&lt;Entry&gt;, obj: Object)</TD></TR>
<TR><TD ALIGN="LEFT" >- internalReadEntriesFailed(exception: ManagedLedgerException, ctx: Object)</TD></TR>
<TR><TD ALIGN="LEFT" >- internalRedeliverUnacknowledgedMessages(consumer: Consumer, consumerEpoch: long)</TD></TR>
<TR><TD ALIGN="LEFT" ># reScheduleRead()</TD></TR>
<TR><TD ALIGN="LEFT" >+ readEntriesComplete(entries: List&lt;Entry&gt;, obj: Object)</TD></TR>
<TR><TD ALIGN="LEFT" >+ readEntriesFailed(exception: ManagedLedgerException, ctx: Object)</TD></TR>
<TR><TD ALIGN="LEFT" ># readMoreEntries(consumer: Consumer)</TD></TR>
<TR><TD ALIGN="LEFT" >+ redeliverUnacknowledgedMessages(consumer: Consumer, consumerEpoch: long)</TD></TR>
<TR><TD ALIGN="LEFT" >+ redeliverUnacknowledgedMessages(consumer: Consumer, positions: List&lt;PositionImpl&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" ># scheduleReadOnActiveConsumer()</TD></TR>
<TR><TD ALIGN="LEFT" >+ updateRateLimiter()</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

PersistentMessageExpiryMonitor1101090806[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)PersistentMessageExpiryMonitor</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   autoSkipNonRecoverableData: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   cursor: ManagedCursor [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   expirationCheckInProgress: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   markDeleteCallback: MarkDeleteCallback [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   msgExpired: Rate [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   subName: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   subscription: PersistentSubscription [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   topicName: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   totalMsgExpired: LongAdder [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ expireMessages(messageTTLInSeconds: int): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ expireMessages(messagePosition: Position): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ findEntryComplete(position: Position, ctx: Object)</TD></TR>
<TR><TD ALIGN="LEFT" >+ findEntryFailed(exception: ManagedLedgerException, failedReadPosition: Optional&lt;Position&gt;, ctx: Object)</TD></TR>
<TR><TD ALIGN="LEFT" >+ updateRates()</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

PersistentMessageFinder1101090806[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)PersistentMessageFinder</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   cursor: ManagedCursor [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   messageFindInProgress: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   subName: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   timestamp: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   topicName: String [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ findEntryComplete(position: Position, ctx: Object)</TD></TR>
<TR><TD ALIGN="LEFT" >+ findEntryFailed(exception: ManagedLedgerException, failedReadPosition: Optional&lt;Position&gt;, ctx: Object)</TD></TR>
<TR><TD ALIGN="LEFT" >+ findMessages(timestamp: long, callback: FindEntryCallback)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

PersistentOfflineTopicStats896442176[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)PersistentOfflineTopicStats</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+   brokerName: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   cursorDetails: Map&lt;String, CursorDetails&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >+   dataLedgerDetails: List&lt;LedgerDetails&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >+   messageBacklog: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   statGeneratedAt: Date [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   storageSize: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   topicName: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   totalMessages: long [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ addCursorDetails(cursor: String, backlog: long, ledgerId: long)</TD></TR>
<TR><TD ALIGN="LEFT" >+ addLedgerDetails(entries: long, timestamp: long, size: long, ledgerId: long)</TD></TR>
<TR><TD ALIGN="LEFT" >+ reset()</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

PersistentReplicator1101090806[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)PersistentReplicator</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   cursor: ManagedCursor [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   dispatchRateLimiter: Optional&lt;DispatchRateLimiter&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   expiryMonitor: PersistentMessageExpiryMonitor [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   havePendingRead: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   messageTTLInSeconds: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   msgExpired: Rate [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   msgOut: Rate [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   pendingMessages: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   producerQueueThreshold: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   readBatchSize: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   readFailureBackoff: Backoff [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   readMaxSizeBytes: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   stats: ReplicatorStatsImpl [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   topic: PersistentTopic [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- checkReplicatedSubscriptionMarker(position: Position, msg: MessageImpl&lt;?&gt;, payload: ByteBuf)</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearBacklog(): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ deleteComplete(ctx: Object)</TD></TR>
<TR><TD ALIGN="LEFT" >+ deleteFailed(exception: ManagedLedgerException, ctx: Object)</TD></TR>
<TR><TD ALIGN="LEFT" ># disableReplicatorRead()</TD></TR>
<TR><TD ALIGN="LEFT" >+ disconnect(): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ disconnect(failIfHasBacklog: boolean): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ expireMessages(messageTTLInSeconds: int): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ expireMessages(position: Position): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >- getSchemaInfo(msg: MessageImpl): CompletableFuture&lt;SchemaInfo&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ initializeDispatchRateLimiterIfNeeded(policies: Optional&lt;Policies&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ peekNthMessage(messagePosition: int): CompletableFuture&lt;Entry&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># readEntries(producer: Producer&lt;byte[]&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ readEntriesComplete(entries: List&lt;Entry&gt;, ctx: Object)</TD></TR>
<TR><TD ALIGN="LEFT" >+ readEntriesFailed(exception: ManagedLedgerException, ctx: Object)</TD></TR>
<TR><TD ALIGN="LEFT" ># readMoreEntries()</TD></TR>
<TR><TD ALIGN="LEFT" >+ skipMessages(numMessagesToSkip: int): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ updateCursorState()</TD></TR>
<TR><TD ALIGN="LEFT" >+ updateMessageTTL(messageTTLInSeconds: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ updateRates()</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

PersistentStickyKeyDispatcherMultipleConsumers1101090806[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)PersistentStickyKeyDispatcherMultipleConsumers</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   allowOutOfOrderDelivery: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   isDispatcherStuckOnReplays: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   keySharedMode: KeySharedMode [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   nextStuckConsumers: Set&lt;Consumer&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   recentlyJoinedConsumers: LinkedHashMap&lt;Consumer, PositionImpl&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   selector: StickyKeyConsumerSelector [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   stuckConsumers: Set&lt;Consumer&gt; [0..*]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ addConsumer(consumer: Consumer)</TD></TR>
<TR><TD ALIGN="LEFT" ># asyncReplayEntries(positions: Set&lt;? extends Position&gt;): Set&lt;? extends Position&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># getMessagesToReplayNow(maxMessagesToRead: int): Set&lt;PositionImpl&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- getRestrictedMaxEntriesForConsumer(consumer: Consumer, entries: List&lt;Entry&gt;, maxMessages: int, readType: ReadType, stickyKeyHashes: Set&lt;Integer&gt;): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ hasSameKeySharedPolicy(ksm: KeySharedMeta): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ markDeletePositionMoveForward()</TD></TR>
<TR><TD ALIGN="LEFT" >+ removeConsumer(consumer: Consumer)</TD></TR>
<TR><TD ALIGN="LEFT" >- removeConsumersFromRecentJoinedConsumers(): boolean</TD></TR>
<TR><TD ALIGN="LEFT" ># sendMessagesToConsumers(readType: ReadType, entries: List&lt;Entry&gt;)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

PersistentStreamingDispatcherMultipleConsumers1101090806[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)PersistentStreamingDispatcherMultipleConsumers</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   streamingEntryReader: StreamingEntryReader [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ canReadMoreEntries(withBackoff: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" ># cancelPendingRead()</TD></TR>
<TR><TD ALIGN="LEFT" >+ notifyConsumersEndOfTopic()</TD></TR>
<TR><TD ALIGN="LEFT" >+ readEntryComplete(entry: Entry, ctx: PendingReadEntryRequest)</TD></TR>
<TR><TD ALIGN="LEFT" >+ readMoreEntries()</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

PersistentStreamingDispatcherSingleActiveConsumer1101090806[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)PersistentStreamingDispatcherSingleActiveConsumer</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   streamingEntryReader: StreamingEntryReader [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ canReadMoreEntries(withBackoff: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" ># cancelPendingRead()</TD></TR>
<TR><TD ALIGN="LEFT" >+ internalReadEntryComplete(entry: Entry, ctx: PendingReadEntryRequest)</TD></TR>
<TR><TD ALIGN="LEFT" >+ notifyConsumersEndOfTopic()</TD></TR>
<TR><TD ALIGN="LEFT" >+ readEntryComplete(entry: Entry, ctx: PendingReadEntryRequest)</TD></TR>
<TR><TD ALIGN="LEFT" ># readMoreEntries(consumer: Consumer)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

PersistentSubscription1101090806[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)PersistentSubscription</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   bytesOutFromRemovedConsumers: LongAdder [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   cursor: ManagedCursor [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   deleteCallback: DeleteCallback [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   dispatcher: Dispatcher [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   expiryMonitor: PersistentMessageExpiryMonitor [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   fullName: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   isFenced: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   lastConsumedFlowTimestamp: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   lastExpireTimestamp: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   lastMarkDeleteAdvancedTimestamp: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   markDeleteCallback: MarkDeleteCallback [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   msgOutFromRemovedConsumer: LongAdder [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   pendingAckHandle: PendingAckHandle [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   replicatedSubscriptionSnapshotCache: ReplicatedSubscriptionSnapshotCache [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   subName: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   subscriptionProperties: Map&lt;String, String&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >#   topic: PersistentTopic [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   topicName: String [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ acknowledgeMessage(positions: List&lt;Position&gt;, ackType: AckType, properties: Map&lt;String, Long&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ addConsumer(consumer: Consumer): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ addUnAckedMessages(unAckMessages: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ checkAndUnblockIfStuck(): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ checkIfPendingAckStoreInit(): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ checkIsCanDeleteConsumerPendingAck(position: PositionImpl): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearBacklog(): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ close(): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ consumerFlow(consumer: Consumer, additionalNumberOfMessages: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ deactivateCursor()</TD></TR>
<TR><TD ALIGN="LEFT" >+ delete(): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- delete(closeIfConsumersConnected: boolean): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ deleteForcefully(): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ disconnect(): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ doUnsubscribe(consumer: Consumer): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ endTxn(txnidMostBits: long, txnidLeastBits: long, txnAction: int, lowWaterMark: long): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ estimateBacklogSize(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ expireMessages(messageTTLInSeconds: int): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ expireMessages(position: Position): boolean</TD></TR>
<TR><TD ALIGN="LEFT" ># getBaseCursorProperties(isReplicated: boolean): Map&lt;String, Long&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getNumberOfEntriesInBacklog(getPreciseBacklog: boolean): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ getStats(getPreciseBacklog: Boolean, subscriptionBacklogSize: boolean, getEarliestTimeInBacklog: boolean): SubscriptionStatsImpl</TD></TR>
<TR><TD ALIGN="LEFT" >+ getTransactionInPendingAckStats(txnID: TxnID): TransactionInPendingAckStats</TD></TR>
<TR><TD ALIGN="LEFT" >+ interceptor(): BrokerInterceptor</TD></TR>
<TR><TD ALIGN="LEFT" ># isCursorFromReplicatedSubscription(cursor: ManagedCursor): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ markTopicWithBatchMessagePublished()</TD></TR>
<TR><TD ALIGN="LEFT" ># mergeCursorProperties(userProperties: Map&lt;String, Long&gt;): Map&lt;String, Long&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- notifyTheMarkDeletePositionMoveForwardIfNeeded(oldPosition: Position)</TD></TR>
<TR><TD ALIGN="LEFT" >+ peekNthMessage(messagePosition: int): CompletableFuture&lt;Entry&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ processReplicatedSubscriptionSnapshot(snapshot: ReplicatedSubscriptionsSnapshot)</TD></TR>
<TR><TD ALIGN="LEFT" >+ redeliverUnacknowledgedMessages(consumer: Consumer, consumerEpoch: long)</TD></TR>
<TR><TD ALIGN="LEFT" >+ redeliverUnacknowledgedMessages(consumer: Consumer, positions: List&lt;PositionImpl&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ removeConsumer(consumer: Consumer, isResetCursor: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ resetCursor(timestamp: long): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ resetCursor(position: Position): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- resetCursor(finalPosition: Position, future: CompletableFuture&lt;Void&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ setReplicated(replicated: boolean): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ skipMessages(numMessagesToSkip: int): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ syncBatchPositionBitSetForPendingAck(position: PositionImpl)</TD></TR>
<TR><TD ALIGN="LEFT" ># topicTerminated()</TD></TR>
<TR><TD ALIGN="LEFT" >+ transactionCumulativeAcknowledge(txnId: TxnID, positions: List&lt;PositionImpl&gt;): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ transactionIndividualAcknowledge(txnId: TxnID, positions: List&lt;MutablePair&lt;PositionImpl, Integer&gt;&gt;): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- trimByMarkDeletePosition(positions: List&lt;PositionImpl&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ updateLastMarkDeleteAdvancedTimestamp()</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

PersistentTopic1101090806[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)PersistentTopic</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   backloggedCursorThresholdEntries: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   bytesOutFromRemovedSubscriptions: LongAdder [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   compactedTopic: CompactedTopic [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   currentCompaction: CompletableFuture&lt;Long&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   currentOffload: CompletableFuture&lt;MessageIdImpl&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   dispatchRateLimiter: Optional&lt;DispatchRateLimiter&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   fencedTopicMonitoringTask: ScheduledFuture&lt;?&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   isClosingOrDeleting: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   lastDataMessagePublishedTimestamp: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   lastUpdatedAvgPublishRateInByte: double [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   lastUpdatedAvgPublishRateInMsg: double [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   ledger: ManagedLedger [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   maxUnackedMessagesOnSubscriptionApplied: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   messageDeduplication: MessageDeduplication [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   msgChunkPublished: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   msgOutFromRemovedSubscriptions: LongAdder [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   pendingWriteOps: AtomicLong [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   replicatedSubscriptionsController: Optional&lt;ReplicatedSubscriptionsController&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   replicators: ConcurrentOpenHashMap&lt;String, Replicator&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   subscribeRateLimiter: Optional&lt;SubscribeRateLimiter&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   subscriptions: ConcurrentOpenHashMap&lt;String, PersistentSubscription&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   transactionBuffer: TransactionBuffer [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ addComplete(pos: Position, entryData: ByteBuf, ctx: Object)</TD></TR>
<TR><TD ALIGN="LEFT" >+ addFailed(exception: ManagedLedgerException, ctx: Object)</TD></TR>
<TR><TD ALIGN="LEFT" >+ addProducer(producer: Producer, producerQueuedFuture: CompletableFuture&lt;Void&gt;): CompletableFuture&lt;Optional&lt;Long&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># addReplicationCluster(remoteCluster: String, cursor: ManagedCursor, localCluster: String): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ addSchemaIfIdleOrCheckCompatible(schema: SchemaData): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- asyncAddEntry(headersAndPayload: ByteBuf, publishContext: PublishContext)</TD></TR>
<TR><TD ALIGN="LEFT" >- asyncDeleteCursor(subscriptionName: String, unsubscribeFuture: CompletableFuture&lt;Void&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ asyncGetStats(getPreciseBacklog: boolean, subscriptionBacklogSize: boolean, getEarliestTimeInBacklog: boolean): CompletableFuture&lt;TopicStatsImpl&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ asyncReadEntry(position: PositionImpl, callback: ReadEntryCallback, ctx: Object)</TD></TR>
<TR><TD ALIGN="LEFT" >+ checkBacklogQuotaExceeded(producerName: String, backlogQuotaType: BacklogQuotaType): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ checkBackloggedCursors()</TD></TR>
<TR><TD ALIGN="LEFT" >+ checkCompaction()</TD></TR>
<TR><TD ALIGN="LEFT" >+ checkDeduplicationSnapshot()</TD></TR>
<TR><TD ALIGN="LEFT" >+ checkDeduplicationStatus(): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ checkGC()</TD></TR>
<TR><TD ALIGN="LEFT" >+ checkIfTransactionBufferRecoverCompletely(isTxnEnabled: boolean): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ checkInactiveLedgers()</TD></TR>
<TR><TD ALIGN="LEFT" >+ checkInactiveSubscriptions()</TD></TR>
<TR><TD ALIGN="LEFT" >- checkMaxSubscriptionsPerTopicExceed(subscriptionName: String): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ checkMessageDeduplicationInfo()</TD></TR>
<TR><TD ALIGN="LEFT" >+ checkMessageExpiry()</TD></TR>
<TR><TD ALIGN="LEFT" >- checkPersistencePolicies(): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ checkReplicatedSubscriptionControllerState()</TD></TR>
<TR><TD ALIGN="LEFT" >- checkReplicatedSubscriptionControllerState(shouldBeEnabled: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ checkReplication(): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># checkReplicationAndRetryOnFailure(): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ checkSubscriptionTypesEnable(subType: SubType): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ checkTimeBacklogExceeded(): CompletableFuture&lt;Boolean&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearBacklog(): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearBacklog(cursorName: String): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ close(): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ close(closeWithoutWaitingClientDisconnect: boolean): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- closeFencedTopicForcefully()</TD></TR>
<TR><TD ALIGN="LEFT" >- closeReplProducersIfNoBacklog(): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ compactionStatus(): LongRunningProcessStatus</TD></TR>
<TR><TD ALIGN="LEFT" >- createPersistentSubscription(subscriptionName: String, cursor: ManagedCursor, replicated: boolean, subscriptionProperties: Map&lt;String, String&gt;): PersistentSubscription</TD></TR>
<TR><TD ALIGN="LEFT" >+ createSubscription(subscriptionName: String, initialPosition: InitialPosition, replicateSubscriptionState: boolean): CompletableFuture&lt;Subscription&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- decrementPendingWriteOpsAndCheck()</TD></TR>
<TR><TD ALIGN="LEFT" >+ delete(): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- delete(failIfHasSubscriptions: boolean, failIfHasBacklogs: boolean, deleteSchema: boolean): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- delete(failIfHasSubscriptions: boolean, failIfHasBacklogs: boolean, closeIfClientsConnected: boolean, deleteSchema: boolean): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ deleteForcefully(): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ endTxn(txnID: TxnID, txnAction: int, lowWaterMark: long): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- fence()</TD></TR>
<TR><TD ALIGN="LEFT" >- fenceTopicToCloseOrDelete()</TD></TR>
<TR><TD ALIGN="LEFT" >+ getBacklogQuota(backlogQuotaType: BacklogQuotaType): BacklogQuota</TD></TR>
<TR><TD ALIGN="LEFT" >- getDurableSubscription(subscriptionName: String, initialPosition: InitialPosition, startMessageRollbackDurationSec: long, replicated: boolean, subscriptionProperties: Map&lt;String, String&gt;): CompletableFuture&lt;Subscription&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getInternalStats(includeLedgerMetadata: boolean): CompletableFuture&lt;PersistentTopicInternalStats&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getLastPublishedSequenceId(producerName: String): long</TD></TR>
<TR><TD ALIGN="LEFT" >- getNonDurableSubscription(subscriptionName: String, startMessageId: MessageId, initialPosition: InitialPosition, startMessageRollbackDurationSec: long, isReadCompacted: boolean): CompletableFuture&lt;? extends Subscription&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getNumberOfSameAddressConsumers(clientAddress: String): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ getPendingAckManagedLedger(subName: String): CompletableFuture&lt;ManagedLedger&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getPersistentReplicator(remoteCluster: String): Replicator</TD></TR>
<TR><TD ALIGN="LEFT" >+ getPositionAfterN(startPosition: PositionImpl, n: long): PositionImpl</TD></TR>
<TR><TD ALIGN="LEFT" >+ getStats(getPreciseBacklog: boolean, subscriptionBacklogSize: boolean, getEarliestTimeInBacklog: boolean): TopicStatsImpl</TD></TR>
<TR><TD ALIGN="LEFT" >+ getSubscription(subscriptionName: String): PersistentSubscription</TD></TR>
<TR><TD ALIGN="LEFT" >+ getTransactionInBufferStats(txnID: TxnID): TransactionInBufferStats</TD></TR>
<TR><TD ALIGN="LEFT" >+ getTransactionInPendingAckStats(txnID: TxnID, subName: String): TransactionInPendingAckStats</TD></TR>
<TR><TD ALIGN="LEFT" >+ getTransactionPendingAckStats(subName: String): TransactionPendingAckStats</TD></TR>
<TR><TD ALIGN="LEFT" ># handleProducerRemoved(producer: Producer)</TD></TR>
<TR><TD ALIGN="LEFT" ># incrementTopicEpoch(currentEpoch: Optional&lt;Long&gt;): CompletableFuture&lt;Long&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># initTopicPolicy(): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ initialize(): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- initializeRateLimiterIfNeeded(policies: Optional&lt;Policies&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >- initializeTopicDispatchRateLimiterIfNeeded(policies: TopicPolicies)</TD></TR>
<TR><TD ALIGN="LEFT" >- initializeTopicSubscribeRateLimiterIfNeeded(policies: Optional&lt;TopicPolicies&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >- internalSubscribe(cnx: TransportCnx, subscriptionName: String, consumerId: long, subType: SubType, priorityLevel: int, consumerName: String, isDurable: boolean, startMessageId: MessageId, metadata: Map&lt;String, String&gt;, readCompacted: boolean, initialPosition: InitialPosition, startMessageRollbackDurationSec: long, replicatedSubscriptionStateArg: boolean, keySharedMeta: KeySharedMeta, subscriptionProperties: Map&lt;String, String&gt;, consumerEpoch: long): CompletableFuture&lt;Consumer&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ isActive(deleteMode: InactiveTopicDeleteMode): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ isOldestMessageExpired(cursor: ManagedCursor, messageTTLInSeconds: int): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ isTxnAborted(txnID: TxnID): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ offloadStatus(): OffloadProcessStatus</TD></TR>
<TR><TD ALIGN="LEFT" >+ onPoliciesUpdate(data: Policies): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ onUpdate(policies: TopicPolicies)</TD></TR>
<TR><TD ALIGN="LEFT" >+ preCreateSubscriptionForCompactionIfNeeded(): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ publishMessage(headersAndPayload: ByteBuf, publishContext: PublishContext)</TD></TR>
<TR><TD ALIGN="LEFT" >+ publishTxnMessage(txnID: TxnID, headersAndPayload: ByteBuf, publishContext: PublishContext)</TD></TR>
<TR><TD ALIGN="LEFT" ># receivedReplicatedSubscriptionMarker(position: Position, markerType: int, payload: ByteBuf)</TD></TR>
<TR><TD ALIGN="LEFT" ># removeReplicator(remoteCluster: String): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># removeSubscription(subscriptionName: String)</TD></TR>
<TR><TD ALIGN="LEFT" >- resetSubscriptionCursor(subscription: Subscription, subscriptionFuture: CompletableFuture&lt;Subscription&gt;, startMessageRollbackDurationSec: long)</TD></TR>
<TR><TD ALIGN="LEFT" ># setTopicEpoch(newEpoch: long): CompletableFuture&lt;Long&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- shouldTopicBeRetained(): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ startReplProducers(): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># startReplicator(remoteCluster: String): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ stopReplProducers(): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ subscribe(option: SubscriptionOption): CompletableFuture&lt;Consumer&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ subscribe(cnx: TransportCnx, subscriptionName: String, consumerId: long, subType: SubType, priorityLevel: int, consumerName: String, isDurable: boolean, startMessageId: MessageId, metadata: Map&lt;String, String&gt;, readCompacted: boolean, initialPosition: InitialPosition, startMessageRollbackDurationSec: long, replicatedSubscriptionStateArg: boolean, keySharedMeta: KeySharedMeta): CompletableFuture&lt;Consumer&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ terminate(): CompletableFuture&lt;MessageId&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ triggerCompaction()</TD></TR>
<TR><TD ALIGN="LEFT" >+ triggerOffload(messageId: MessageIdImpl)</TD></TR>
<TR><TD ALIGN="LEFT" >+ truncate(): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- tryToDeletePartitionedMetadata(): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- unfence()</TD></TR>
<TR><TD ALIGN="LEFT" >- unfenceTopicToResume()</TD></TR>
<TR><TD ALIGN="LEFT" >+ unsubscribe(subscriptionName: String): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ updateRates(nsStats: NamespaceStats, bundleStats: NamespaceBundleStats, topicStatsStream: StatsOutputStream, replStats: ClusterReplicationMetrics, namespace: String, hydratePublishers: boolean)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

PersistentTopics620988779[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)PersistentTopics</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ compact(asyncResponse: AsyncResponse, tenant: String, namespace: String, encodedTopic: String, authoritative: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ compactionStatus(tenant: String, namespace: String, encodedTopic: String, authoritative: boolean): LongRunningProcessStatus</TD></TR>
<TR><TD ALIGN="LEFT" >+ createMissedPartitions(asyncResponse: AsyncResponse, tenant: String, namespace: String, encodedTopic: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ createNonPartitionedTopic(tenant: String, namespace: String, encodedTopic: String, authoritative: boolean, properties: Map&lt;String, String&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ createPartitionedTopic(asyncResponse: AsyncResponse, tenant: String, namespace: String, encodedTopic: String, numPartitions: int, createLocalTopicOnly: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ createPartitionedTopic(asyncResponse: AsyncResponse, tenant: String, namespace: String, encodedTopic: String, metadata: PartitionedTopicMetadata, createLocalTopicOnly: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ createSubscription(asyncResponse: AsyncResponse, tenant: String, namespace: String, topic: String, encodedSubName: String, authoritative: boolean, resetCursorData: ResetCursorData, replicated: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ deleteDeduplicationSnapshotInterval(asyncResponse: AsyncResponse, tenant: String, namespace: String, encodedTopic: String, isGlobal: boolean, authoritative: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ deleteDelayedDeliveryPolicies(asyncResponse: AsyncResponse, tenant: String, namespace: String, encodedTopic: String, isGlobal: boolean, authoritative: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ deleteInactiveTopicPolicies(asyncResponse: AsyncResponse, tenant: String, namespace: String, encodedTopic: String, isGlobal: boolean, authoritative: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ deleteMaxUnackedMessagesOnConsumer(asyncResponse: AsyncResponse, tenant: String, namespace: String, encodedTopic: String, isGlobal: boolean, authoritative: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ deleteMaxUnackedMessagesOnSubscription(asyncResponse: AsyncResponse, tenant: String, namespace: String, encodedTopic: String, isGlobal: boolean, authoritative: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ deletePartitionedTopic(asyncResponse: AsyncResponse, tenant: String, namespace: String, encodedTopic: String, force: boolean, authoritative: boolean, deleteSchema: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ deleteSubscription(asyncResponse: AsyncResponse, tenant: String, namespace: String, encodedTopic: String, encodedSubName: String, force: boolean, authoritative: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ deleteTopic(tenant: String, namespace: String, encodedTopic: String, force: boolean, authoritative: boolean, deleteSchema: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ examineMessage(tenant: String, namespace: String, encodedTopic: String, initialPosition: String, messagePosition: long, authoritative: boolean): Response</TD></TR>
<TR><TD ALIGN="LEFT" >+ expireMessagesForAllSubscriptions(asyncResponse: AsyncResponse, tenant: String, namespace: String, encodedTopic: String, expireTimeInSeconds: int, authoritative: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ expireTopicMessages(asyncResponse: AsyncResponse, tenant: String, namespace: String, encodedTopic: String, encodedSubName: String, expireTimeInSeconds: int, authoritative: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ expireTopicMessages(asyncResponse: AsyncResponse, tenant: String, namespace: String, encodedTopic: String, encodedSubName: String, authoritative: boolean, resetCursorData: ResetCursorData)</TD></TR>
<TR><TD ALIGN="LEFT" >+ getBacklog(tenant: String, namespace: String, encodedTopic: String, authoritative: boolean): PersistentOfflineTopicStats</TD></TR>
<TR><TD ALIGN="LEFT" >+ getBacklogQuotaMap(asyncResponse: AsyncResponse, tenant: String, namespace: String, encodedTopic: String, applied: boolean, authoritative: boolean, isGlobal: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ getBacklogSizeByMessageId(asyncResponse: AsyncResponse, tenant: String, namespace: String, encodedTopic: String, authoritative: boolean, messageId: MessageIdImpl)</TD></TR>
<TR><TD ALIGN="LEFT" >+ getCompactionThreshold(asyncResponse: AsyncResponse, tenant: String, namespace: String, encodedTopic: String, applied: boolean, isGlobal: boolean, authoritative: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ getDeduplication(asyncResponse: AsyncResponse, tenant: String, namespace: String, encodedTopic: String, applied: boolean, isGlobal: boolean, authoritative: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ getDeduplicationSnapshotInterval(asyncResponse: AsyncResponse, tenant: String, namespace: String, encodedTopic: String, isGlobal: boolean, authoritative: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ getDelayedDeliveryPolicies(asyncResponse: AsyncResponse, tenant: String, namespace: String, encodedTopic: String, isGlobal: boolean, applied: boolean, authoritative: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ getDispatchRate(asyncResponse: AsyncResponse, tenant: String, namespace: String, encodedTopic: String, applied: boolean, isGlobal: boolean, authoritative: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ getInactiveTopicPolicies(asyncResponse: AsyncResponse, tenant: String, namespace: String, encodedTopic: String, applied: boolean, isGlobal: boolean, authoritative: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ getInternalStats(tenant: String, namespace: String, encodedTopic: String, authoritative: boolean, metadata: boolean): PersistentTopicInternalStats</TD></TR>
<TR><TD ALIGN="LEFT" >+ getLastMessageId(asyncResponse: AsyncResponse, tenant: String, namespace: String, encodedTopic: String, authoritative: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ getList(asyncResponse: AsyncResponse, tenant: String, namespace: String, bundle: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ getManagedLedgerInfo(tenant: String, namespace: String, authoritative: boolean, encodedTopic: String, asyncResponse: AsyncResponse)</TD></TR>
<TR><TD ALIGN="LEFT" >+ getMaxConsumers(asyncResponse: AsyncResponse, tenant: String, namespace: String, encodedTopic: String, isGlobal: boolean, applied: boolean, authoritative: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ getMaxConsumersPerSubscription(asyncResponse: AsyncResponse, tenant: String, namespace: String, encodedTopic: String, isGlobal: boolean, authoritative: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ getMaxMessageSize(asyncResponse: AsyncResponse, tenant: String, namespace: String, encodedTopic: String, isGlobal: boolean, authoritative: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ getMaxProducers(asyncResponse: AsyncResponse, tenant: String, namespace: String, encodedTopic: String, applied: boolean, isGlobal: boolean, authoritative: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ getMaxSubscriptionsPerTopic(asyncResponse: AsyncResponse, tenant: String, namespace: String, encodedTopic: String, isGlobal: boolean, authoritative: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ getMaxUnackedMessagesOnConsumer(asyncResponse: AsyncResponse, tenant: String, namespace: String, encodedTopic: String, applied: boolean, isGlobal: boolean, authoritative: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ getMaxUnackedMessagesOnSubscription(asyncResponse: AsyncResponse, tenant: String, namespace: String, encodedTopic: String, applied: boolean, isGlobal: boolean, authoritative: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ getMessageById(asyncResponse: AsyncResponse, tenant: String, namespace: String, encodedTopic: String, ledgerId: long, entryId: long, authoritative: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ getMessageIdByTimestamp(asyncResponse: AsyncResponse, tenant: String, namespace: String, encodedTopic: String, timestamp: long, authoritative: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ getMessageTTL(asyncResponse: AsyncResponse, tenant: String, namespace: String, encodedTopic: String, applied: boolean, isGlobal: boolean, authoritative: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ getOffloadPolicies(asyncResponse: AsyncResponse, tenant: String, namespace: String, encodedTopic: String, applied: boolean, isGlobal: boolean, authoritative: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ getPartitionedMetadata(tenant: String, namespace: String, encodedTopic: String, authoritative: boolean, checkAllowAutoCreation: boolean): PartitionedTopicMetadata</TD></TR>
<TR><TD ALIGN="LEFT" >+ getPartitionedStats(asyncResponse: AsyncResponse, tenant: String, namespace: String, encodedTopic: String, perPartition: boolean, authoritative: boolean, getPreciseBacklog: boolean, subscriptionBacklogSize: boolean, getEarliestTimeInBacklog: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ getPartitionedStatsInternal(asyncResponse: AsyncResponse, tenant: String, namespace: String, encodedTopic: String, authoritative: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ getPartitionedTopicList(tenant: String, namespace: String): List&lt;String&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getPermissionsOnTopic(tenant: String, namespace: String, encodedTopic: String): Map&lt;String, Set&lt;AuthAction&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getPersistence(asyncResponse: AsyncResponse, tenant: String, namespace: String, encodedTopic: String, applied: boolean, isGlobal: boolean, authoritative: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ getPublishRate(asyncResponse: AsyncResponse, tenant: String, namespace: String, encodedTopic: String, isGlobal: boolean, authoritative: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ getReplicatedSubscriptionStatus(asyncResponse: AsyncResponse, tenant: String, namespace: String, encodedTopic: String, encodedSubName: String, authoritative: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ getReplicationClusters(asyncResponse: AsyncResponse, tenant: String, namespace: String, encodedTopic: String, applied: boolean, authoritative: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ getReplicatorDispatchRate(asyncResponse: AsyncResponse, tenant: String, namespace: String, encodedTopic: String, isGlobal: boolean, applied: boolean, authoritative: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ getRetention(asyncResponse: AsyncResponse, tenant: String, namespace: String, encodedTopic: String, isGlobal: boolean, applied: boolean, authoritative: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ getSchemaCompatibilityStrategy(asyncResponse: AsyncResponse, tenant: String, namespace: String, encodedTopic: String, applied: boolean, authoritative: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ getStats(tenant: String, namespace: String, encodedTopic: String, authoritative: boolean, getPreciseBacklog: boolean, subscriptionBacklogSize: boolean, getEarliestTimeInBacklog: boolean): TopicStats</TD></TR>
<TR><TD ALIGN="LEFT" >+ getSubscribeRate(asyncResponse: AsyncResponse, tenant: String, namespace: String, encodedTopic: String, applied: boolean, isGlobal: boolean, authoritative: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ getSubscriptionDispatchRate(asyncResponse: AsyncResponse, tenant: String, namespace: String, encodedTopic: String, applied: boolean, isGlobal: boolean, authoritative: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ getSubscriptionTypesEnabled(asyncResponse: AsyncResponse, tenant: String, namespace: String, encodedTopic: String, isGlobal: boolean, authoritative: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ getSubscriptions(asyncResponse: AsyncResponse, tenant: String, namespace: String, encodedTopic: String, authoritative: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ grantPermissionsOnTopic(tenant: String, namespace: String, encodedTopic: String, role: String, actions: Set&lt;AuthAction&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ offloadStatus(asyncResponse: AsyncResponse, tenant: String, namespace: String, encodedTopic: String, authoritative: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ peekNthMessage(tenant: String, namespace: String, encodedTopic: String, encodedSubName: String, messagePosition: int, authoritative: boolean): Response</TD></TR>
<TR><TD ALIGN="LEFT" >+ removeBacklogQuota(asyncResponse: AsyncResponse, tenant: String, namespace: String, encodedTopic: String, backlogQuotaType: BacklogQuotaType, authoritative: boolean, isGlobal: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ removeCompactionThreshold(asyncResponse: AsyncResponse, tenant: String, namespace: String, encodedTopic: String, isGlobal: boolean, authoritative: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ removeDeduplication(asyncResponse: AsyncResponse, tenant: String, namespace: String, encodedTopic: String, isGlobal: boolean, authoritative: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ removeDispatchRate(asyncResponse: AsyncResponse, tenant: String, namespace: String, encodedTopic: String, isGlobal: boolean, authoritative: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ removeMaxConsumers(asyncResponse: AsyncResponse, tenant: String, namespace: String, encodedTopic: String, isGlobal: boolean, authoritative: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ removeMaxConsumersPerSubscription(asyncResponse: AsyncResponse, tenant: String, namespace: String, encodedTopic: String, isGlobal: boolean, authoritative: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ removeMaxMessageSize(asyncResponse: AsyncResponse, tenant: String, namespace: String, encodedTopic: String, isGlobal: boolean, authoritative: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ removeMaxProducers(asyncResponse: AsyncResponse, tenant: String, namespace: String, encodedTopic: String, isGlobal: boolean, authoritative: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ removeMaxSubscriptionsPerTopic(asyncResponse: AsyncResponse, tenant: String, namespace: String, encodedTopic: String, isGlobal: boolean, authoritative: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ removeMessageTTL(asyncResponse: AsyncResponse, tenant: String, namespace: String, encodedTopic: String, isGlobal: boolean, authoritative: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ removeOffloadPolicies(asyncResponse: AsyncResponse, tenant: String, namespace: String, encodedTopic: String, isGlobal: boolean, authoritative: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ removePersistence(asyncResponse: AsyncResponse, tenant: String, namespace: String, encodedTopic: String, isGlobal: boolean, authoritative: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ removePublishRate(asyncResponse: AsyncResponse, tenant: String, namespace: String, encodedTopic: String, isGlobal: boolean, authoritative: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ removeReplicationClusters(asyncResponse: AsyncResponse, tenant: String, namespace: String, encodedTopic: String, backlogQuotaType: BacklogQuotaType, authoritative: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ removeReplicatorDispatchRate(asyncResponse: AsyncResponse, tenant: String, namespace: String, encodedTopic: String, isGlobal: boolean, authoritative: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ removeRetention(asyncResponse: AsyncResponse, tenant: String, namespace: String, encodedTopic: String, isGlobal: boolean, authoritative: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ removeSchemaCompatibilityStrategy(asyncResponse: AsyncResponse, tenant: String, namespace: String, encodedTopic: String, authoritative: boolean, strategy: SchemaCompatibilityStrategy)</TD></TR>
<TR><TD ALIGN="LEFT" >+ removeSubscribeRate(asyncResponse: AsyncResponse, tenant: String, namespace: String, encodedTopic: String, isGlobal: boolean, authoritative: boolean, subscribeRate: SubscribeRate)</TD></TR>
<TR><TD ALIGN="LEFT" >+ removeSubscriptionDispatchRate(asyncResponse: AsyncResponse, tenant: String, namespace: String, encodedTopic: String, isGlobal: boolean, authoritative: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ removeSubscriptionTypesEnabled(asyncResponse: AsyncResponse, tenant: String, namespace: String, encodedTopic: String, isGlobal: boolean, authoritative: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ resetCursor(asyncResponse: AsyncResponse, tenant: String, namespace: String, encodedTopic: String, encodedSubName: String, timestamp: long, authoritative: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ resetCursorOnPosition(asyncResponse: AsyncResponse, tenant: String, namespace: String, encodedTopic: String, encodedSubName: String, authoritative: boolean, resetCursorData: ResetCursorData)</TD></TR>
<TR><TD ALIGN="LEFT" >+ revokePermissionsOnTopic(tenant: String, namespace: String, encodedTopic: String, role: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ skipAllMessages(asyncResponse: AsyncResponse, tenant: String, namespace: String, encodedTopic: String, encodedSubName: String, authoritative: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ skipMessages(asyncResponse: AsyncResponse, tenant: String, namespace: String, encodedTopic: String, encodedSubName: String, numMessages: int, authoritative: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ terminate(tenant: String, namespace: String, encodedTopic: String, authoritative: boolean): MessageId</TD></TR>
<TR><TD ALIGN="LEFT" >+ terminatePartitionedTopic(asyncResponse: AsyncResponse, tenant: String, namespace: String, encodedTopic: String, authoritative: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ triggerOffload(asyncResponse: AsyncResponse, tenant: String, namespace: String, encodedTopic: String, authoritative: boolean, messageId: MessageIdImpl)</TD></TR>
<TR><TD ALIGN="LEFT" >+ truncateTopic(asyncResponse: AsyncResponse, tenant: String, namespace: String, encodedTopic: String, authoritative: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ unloadTopic(asyncResponse: AsyncResponse, tenant: String, namespace: String, encodedTopic: String, authoritative: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ updatePartitionedTopic(tenant: String, namespace: String, encodedTopic: String, updateLocalTopicOnly: boolean, authoritative: boolean, force: boolean, numPartitions: int)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

PersistentTopics620988780[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)PersistentTopics</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ compact(asyncResponse: AsyncResponse, property: String, cluster: String, namespace: String, encodedTopic: String, authoritative: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ compactionStatus(property: String, cluster: String, namespace: String, encodedTopic: String, authoritative: boolean): LongRunningProcessStatus</TD></TR>
<TR><TD ALIGN="LEFT" >+ createNonPartitionedTopic(tenant: String, cluster: String, namespace: String, encodedTopic: String, authoritative: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ createPartitionedTopic(asyncResponse: AsyncResponse, property: String, cluster: String, namespace: String, encodedTopic: String, numPartitions: int, createLocalTopicOnly: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ createSubscription(asyncResponse: AsyncResponse, property: String, cluster: String, namespace: String, topic: String, encodedSubName: String, authoritative: boolean, messageId: MessageIdImpl, replicated: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ deletePartitionedTopic(asyncResponse: AsyncResponse, property: String, cluster: String, namespace: String, encodedTopic: String, force: boolean, authoritative: boolean, deleteSchema: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ deleteSubscription(asyncResponse: AsyncResponse, property: String, cluster: String, namespace: String, encodedTopic: String, encodedSubName: String, force: boolean, authoritative: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ deleteTopic(property: String, cluster: String, namespace: String, encodedTopic: String, force: boolean, authoritative: boolean, deleteSchema: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ expireMessagesForAllSubscriptions(asyncResponse: AsyncResponse, property: String, cluster: String, namespace: String, encodedTopic: String, expireTimeInSeconds: int, authoritative: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ expireTopicMessages(asyncResponse: AsyncResponse, property: String, cluster: String, namespace: String, encodedTopic: String, encodedSubName: String, expireTimeInSeconds: int, authoritative: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ expireTopicMessages(asyncResponse: AsyncResponse, property: String, cluster: String, namespace: String, encodedTopic: String, encodedSubName: String, authoritative: boolean, resetCursorData: ResetCursorData)</TD></TR>
<TR><TD ALIGN="LEFT" >+ getBacklog(property: String, cluster: String, namespace: String, encodedTopic: String, authoritative: boolean): PersistentOfflineTopicStats</TD></TR>
<TR><TD ALIGN="LEFT" >+ getInternalStats(property: String, cluster: String, namespace: String, encodedTopic: String, authoritative: boolean, metadata: boolean): PersistentTopicInternalStats</TD></TR>
<TR><TD ALIGN="LEFT" >+ getLastMessageId(asyncResponse: AsyncResponse, tenant: String, cluster: String, namespace: String, encodedTopic: String, authoritative: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ getList(asyncResponse: AsyncResponse, property: String, cluster: String, namespace: String, bundle: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ getManagedLedgerInfo(property: String, cluster: String, namespace: String, encodedTopic: String, asyncResponse: AsyncResponse, authoritative: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ getMessageByID(asyncResponse: AsyncResponse, property: String, cluster: String, namespace: String, encodedTopic: String, ledgerId: Long, entryId: Long, authoritative: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ getPartitionedMetadata(property: String, cluster: String, namespace: String, encodedTopic: String, authoritative: boolean, checkAllowAutoCreation: boolean): PartitionedTopicMetadata</TD></TR>
<TR><TD ALIGN="LEFT" >+ getPartitionedStats(asyncResponse: AsyncResponse, property: String, cluster: String, namespace: String, encodedTopic: String, perPartition: boolean, authoritative: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ getPartitionedStatsInternal(asyncResponse: AsyncResponse, property: String, cluster: String, namespace: String, encodedTopic: String, authoritative: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ getPartitionedTopicList(property: String, cluster: String, namespace: String): List&lt;String&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getPermissionsOnTopic(property: String, cluster: String, namespace: String, encodedTopic: String): Map&lt;String, Set&lt;AuthAction&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getReplicatedSubscriptionStatus(asyncResponse: AsyncResponse, tenant: String, cluster: String, namespace: String, encodedTopic: String, encodedSubName: String, authoritative: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ getStats(property: String, cluster: String, namespace: String, encodedTopic: String, authoritative: boolean, getPreciseBacklog: boolean): TopicStats</TD></TR>
<TR><TD ALIGN="LEFT" >+ getSubscriptions(asyncResponse: AsyncResponse, property: String, cluster: String, namespace: String, encodedTopic: String, authoritative: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ grantPermissionsOnTopic(property: String, cluster: String, namespace: String, encodedTopic: String, role: String, actions: Set&lt;AuthAction&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ offloadStatus(asyncResponse: AsyncResponse, tenant: String, cluster: String, namespace: String, encodedTopic: String, authoritative: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ peekNthMessage(property: String, cluster: String, namespace: String, encodedTopic: String, encodedSubName: String, messagePosition: int, authoritative: boolean): Response</TD></TR>
<TR><TD ALIGN="LEFT" >+ resetCursor(asyncResponse: AsyncResponse, property: String, cluster: String, namespace: String, encodedTopic: String, encodedSubName: String, timestamp: long, authoritative: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ resetCursorOnPosition(asyncResponse: AsyncResponse, property: String, cluster: String, namespace: String, encodedTopic: String, encodedSubName: String, authoritative: boolean, resetCursorData: ResetCursorData)</TD></TR>
<TR><TD ALIGN="LEFT" >+ revokePermissionsOnTopic(property: String, cluster: String, namespace: String, encodedTopic: String, role: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ skipAllMessages(asyncResponse: AsyncResponse, property: String, cluster: String, namespace: String, encodedTopic: String, encodedSubName: String, authoritative: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ skipMessages(asyncResponse: AsyncResponse, property: String, cluster: String, namespace: String, encodedTopic: String, encodedSubName: String, numMessages: int, authoritative: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ terminate(property: String, cluster: String, namespace: String, encodedTopic: String, authoritative: boolean): MessageId</TD></TR>
<TR><TD ALIGN="LEFT" >+ terminatePartitionedTopic(asyncResponse: AsyncResponse, property: String, cluster: String, namespace: String, encodedTopic: String, authoritative: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ triggerOffload(asyncResponse: AsyncResponse, tenant: String, cluster: String, namespace: String, encodedTopic: String, authoritative: boolean, messageId: MessageIdImpl)</TD></TR>
<TR><TD ALIGN="LEFT" >+ unloadTopic(asyncResponse: AsyncResponse, property: String, cluster: String, namespace: String, encodedTopic: String, authoritative: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ updatePartitionedTopic(property: String, cluster: String, namespace: String, encodedTopic: String, updateLocalTopicOnly: boolean, authoritative: boolean, force: boolean, numPartitions: int)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

PersistentTopicsBase229910521[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)PersistentTopicsBase</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- calculatePositionAckSet(isExcluded: boolean, batchSize: int, batchIndex: int, messageId: MessageIdImpl): PositionImpl</TD></TR>
<TR><TD ALIGN="LEFT" >- createSubscriptions(topicName: TopicName, numPartitions: int): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- generateResponseWithEntry(entry: Entry): Response</TD></TR>
<TR><TD ALIGN="LEFT" >- getEntryBatchSize(batchSizeFuture: CompletableFuture&lt;Integer&gt;, topic: PersistentTopic, messageId: MessageIdImpl, batchIndex: int)</TD></TR>
<TR><TD ALIGN="LEFT" >- getOrCreateTopic(topicName: TopicName, properties: Map&lt;String, String&gt;): Topic</TD></TR>
<TR><TD ALIGN="LEFT" >+ getPartitionedTopicMetadata(pulsar: PulsarService, clientAppId: String, originalPrincipal: String, authenticationData: AuthenticationDataSource, topicName: TopicName): CompletableFuture&lt;PartitionedTopicMetadata&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- getReplicatorReference(replName: String, topic: PersistentTopic): PersistentReplicator</TD></TR>
<TR><TD ALIGN="LEFT" >- getRetentionPoliciesAsync(topicName: TopicName, topicPolicies: TopicPolicies): CompletableFuture&lt;RetentionPolicies&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- getSubscriptionReference(subName: String, topic: PersistentTopic): Subscription</TD></TR>
<TR><TD ALIGN="LEFT" >- getTopicReference(topicName: TopicName): Topic</TD></TR>
<TR><TD ALIGN="LEFT" >- getTopicReferenceAsync(topicName: TopicName): CompletableFuture&lt;Topic&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- grantPermissions(topicUri: TopicName, role: String, actions: Set&lt;AuthAction&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" ># handleTopicPolicyException(methodName: String, thr: Throwable, asyncResponse: AsyncResponse)</TD></TR>
<TR><TD ALIGN="LEFT" ># internalCompactionStatus(authoritative: boolean): LongRunningProcessStatus</TD></TR>
<TR><TD ALIGN="LEFT" ># internalCreateMissedPartitions(asyncResponse: AsyncResponse)</TD></TR>
<TR><TD ALIGN="LEFT" ># internalCreateNonPartitionedTopic(authoritative: boolean, properties: Map&lt;String, String&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" ># internalCreateSubscription(asyncResponse: AsyncResponse, subscriptionName: String, messageId: MessageIdImpl, authoritative: boolean, replicated: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >- internalCreateSubscriptionForNonPartitionedTopic(asyncResponse: AsyncResponse, subscriptionName: String, targetMessageId: MessageIdImpl, authoritative: boolean, replicated: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" ># internalDeletePartitionedTopic(asyncResponse: AsyncResponse, authoritative: boolean, force: boolean, deleteSchema: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" ># internalDeleteSubscription(asyncResponse: AsyncResponse, subName: String, authoritative: boolean, force: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" ># internalDeleteSubscription(asyncResponse: AsyncResponse, subName: String, authoritative: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >- internalDeleteSubscriptionForNonPartitionedTopic(asyncResponse: AsyncResponse, subName: String, authoritative: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >- internalDeleteSubscriptionForNonPartitionedTopicForcefully(asyncResponse: AsyncResponse, subName: String, authoritative: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" ># internalDeleteSubscriptionForcefully(asyncResponse: AsyncResponse, subName: String, authoritative: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" ># internalDeleteTopic(authoritative: boolean, force: boolean, deleteSchema: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" ># internalDeleteTopic(authoritative: boolean, deleteSchema: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" ># internalDeleteTopicForcefully(authoritative: boolean, deleteSchema: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" ># internalExamineMessage(initialPosition: String, messagePosition: long, authoritative: boolean): Response</TD></TR>
<TR><TD ALIGN="LEFT" ># internalExpireMessagesByPosition(asyncResponse: AsyncResponse, subName: String, authoritative: boolean, messageId: MessageIdImpl, isExcluded: boolean, batchIndex: int)</TD></TR>
<TR><TD ALIGN="LEFT" ># internalExpireMessagesByTimestamp(asyncResponse: AsyncResponse, subName: String, expireTimeInSeconds: int, authoritative: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >- internalExpireMessagesByTimestampForSinglePartitionAsync(partitionMetadata: PartitionedTopicMetadata, subName: String, expireTimeInSeconds: int, authoritative: boolean): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># internalExpireMessagesForAllSubscriptions(asyncResponse: AsyncResponse, expireTimeInSeconds: int, authoritative: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >- internalExpireMessagesForAllSubscriptionsForNonPartitionedTopic(asyncResponse: AsyncResponse, partitionMetadata: PartitionedTopicMetadata, expireTimeInSeconds: int, authoritative: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >- internalExpireMessagesNonPartitionedTopicByPosition(asyncResponse: AsyncResponse, subName: String, messageId: MessageIdImpl, isExcluded: boolean, batchIndex: int): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># internalGetBacklog(authoritative: boolean): PersistentOfflineTopicStats</TD></TR>
<TR><TD ALIGN="LEFT" ># internalGetBacklogQuota(applied: boolean, isGlobal: boolean): CompletableFuture&lt;Map&lt;BacklogQuotaType, BacklogQuota&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># internalGetBacklogSizeByMessageId(asyncResponse: AsyncResponse, messageId: MessageIdImpl, authoritative: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" ># internalGetCompactionThreshold(applied: boolean, isGlobal: boolean): CompletableFuture&lt;Long&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># internalGetDeduplication(applied: boolean, isGlobal: boolean): CompletableFuture&lt;Boolean&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># internalGetDelayedDeliveryPolicies(applied: boolean, isGlobal: boolean): CompletableFuture&lt;DelayedDeliveryPolicies&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># internalGetDispatchRate(applied: boolean, isGlobal: boolean): CompletableFuture&lt;DispatchRateImpl&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># internalGetInactiveTopicPolicies(applied: boolean, isGlobal: boolean): CompletableFuture&lt;InactiveTopicPolicies&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># internalGetInternalStats(authoritative: boolean, metadata: boolean): PersistentTopicInternalStats</TD></TR>
<TR><TD ALIGN="LEFT" ># internalGetLastMessageId(asyncResponse: AsyncResponse, authoritative: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" ># internalGetList(bundle: Optional&lt;String&gt;): List&lt;String&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># internalGetManagedLedgerInfo(asyncResponse: AsyncResponse, authoritative: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" ># internalGetManagedLedgerInfoForNonPartitionedTopic(asyncResponse: AsyncResponse)</TD></TR>
<TR><TD ALIGN="LEFT" ># internalGetMaxConsumers(applied: boolean, isGlobal: boolean): CompletableFuture&lt;Integer&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># internalGetMaxConsumersPerSubscription(isGlobal: boolean): CompletableFuture&lt;Optional&lt;Integer&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># internalGetMaxMessageSize(isGlobal: boolean): CompletableFuture&lt;Optional&lt;Integer&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># internalGetMaxProducers(applied: boolean, isGlobal: boolean): CompletableFuture&lt;Integer&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># internalGetMaxSubscriptionsPerTopic(isGlobal: boolean): CompletableFuture&lt;Optional&lt;Integer&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># internalGetMaxUnackedMessagesOnConsumer(applied: boolean, isGlobal: boolean): CompletableFuture&lt;Integer&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># internalGetMaxUnackedMessagesOnSubscription(applied: boolean, isGlobal: boolean): CompletableFuture&lt;Integer&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># internalGetMessageById(asyncResponse: AsyncResponse, ledgerId: long, entryId: long, authoritative: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" ># internalGetMessageIdByTimestamp(timestamp: long, authoritative: boolean): CompletableFuture&lt;MessageId&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># internalGetOffloadPolicies(applied: boolean, isGlobal: boolean): CompletableFuture&lt;OffloadPoliciesImpl&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># internalGetPartitionedMetadata(authoritative: boolean, checkAllowAutoCreation: boolean): PartitionedTopicMetadata</TD></TR>
<TR><TD ALIGN="LEFT" ># internalGetPartitionedStats(asyncResponse: AsyncResponse, authoritative: boolean, perPartition: boolean, getPreciseBacklog: boolean, subscriptionBacklogSize: boolean, getEarliestTimeInBacklog: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" ># internalGetPartitionedStatsInternal(asyncResponse: AsyncResponse, authoritative: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" ># internalGetPartitionedTopicList(): List&lt;String&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># internalGetPermissionsOnTopic(): Map&lt;String, Set&lt;AuthAction&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># internalGetPersistence(applied: boolean, isGlobal: boolean): CompletableFuture&lt;PersistencePolicies&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># internalGetPublishRate(isGlobal: boolean): CompletableFuture&lt;Optional&lt;PublishRate&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># internalGetReplicatedSubscriptionStatus(asyncResponse: AsyncResponse, subName: String, authoritative: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >- internalGetReplicatedSubscriptionStatusForNonPartitionedTopic(asyncResponse: AsyncResponse, subName: String, authoritative: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" ># internalGetReplicatorDispatchRate(applied: boolean, isGlobal: boolean): CompletableFuture&lt;DispatchRateImpl&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># internalGetRetention(applied: boolean, isGlobal: boolean): CompletableFuture&lt;RetentionPolicies&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># internalGetSchemaCompatibilityStrategy(applied: boolean): CompletableFuture&lt;SchemaCompatibilityStrategy&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># internalGetStats(authoritative: boolean, getPreciseBacklog: boolean, subscriptionBacklogSize: boolean, getEarliestTimeInBacklog: boolean): TopicStats</TD></TR>
<TR><TD ALIGN="LEFT" ># internalGetSubscribeRate(applied: boolean, isGlobal: boolean): CompletableFuture&lt;SubscribeRate&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># internalGetSubscriptionDispatchRate(applied: boolean, isGlobal: boolean): CompletableFuture&lt;DispatchRate&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># internalGetSubscriptionTypesEnabled(isGlobal: boolean): CompletableFuture&lt;Optional&lt;List&lt;SubType&gt;&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># internalGetSubscriptions(asyncResponse: AsyncResponse, authoritative: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >- internalGetSubscriptionsForNonPartitionedTopic(asyncResponse: AsyncResponse, authoritative: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" ># internalGrantPermissionsOnTopic(role: String, actions: Set&lt;AuthAction&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" ># internalOffloadStatus(asyncResponse: AsyncResponse, authoritative: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" ># internalPeekNthMessage(subName: String, messagePosition: int, authoritative: boolean): Response</TD></TR>
<TR><TD ALIGN="LEFT" ># internalRemoveCompactionThreshold(isGlobal: boolean): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># internalRemoveDispatchRate(isGlobal: boolean): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># internalRemoveMaxConsumers(isGlobal: boolean): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># internalRemoveMaxConsumersPerSubscription(isGlobal: boolean): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># internalRemoveMaxProducers(isGlobal: boolean): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- internalRemovePartitionsAuthenticationPoliciesAsync(numPartitions: int): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- internalRemovePartitionsTopicAsync(numPartitions: int, force: boolean): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># internalRemovePersistence(isGlobal: boolean): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># internalRemovePublishRate(isGlobal: boolean): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># internalRemoveReplicationClusters(): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># internalRemoveRetention(isGlobal: boolean): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># internalRemoveSubscribeRate(isGlobal: boolean): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># internalRemoveSubscriptionDispatchRate(isGlobal: boolean): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># internalRemoveSubscriptionTypesEnabled(isGlobal: boolean): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># internalResetCursor(asyncResponse: AsyncResponse, subName: String, timestamp: long, authoritative: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >- internalResetCursorForNonPartitionedTopic(asyncResponse: AsyncResponse, subName: String, timestamp: long, authoritative: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" ># internalResetCursorOnPosition(asyncResponse: AsyncResponse, subName: String, authoritative: boolean, messageId: MessageIdImpl, isExcluded: boolean, batchIndex: int)</TD></TR>
<TR><TD ALIGN="LEFT" ># internalRevokePermissionsOnTopic(role: String)</TD></TR>
<TR><TD ALIGN="LEFT" ># internalSetBacklogQuota(backlogQuotaType: BacklogQuotaType, backlogQuota: BacklogQuotaImpl, isGlobal: boolean): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># internalSetCompactionThreshold(compactionThreshold: Long, isGlobal: boolean): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># internalSetDeduplication(enabled: Boolean, isGlobal: boolean): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># internalSetDeduplicationSnapshotInterval(interval: Integer, isGlobal: boolean): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># internalSetDelayedDeliveryPolicies(deliveryPolicies: DelayedDeliveryPolicies, isGlobal: boolean): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># internalSetDispatchRate(dispatchRate: DispatchRateImpl, isGlobal: boolean): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># internalSetInactiveTopicPolicies(inactiveTopicPolicies: InactiveTopicPolicies, isGlobal: boolean): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># internalSetMaxConsumers(maxConsumers: Integer, isGlobal: boolean): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># internalSetMaxConsumersPerSubscription(maxConsumersPerSubscription: Integer, isGlobal: boolean): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># internalSetMaxMessageSize(maxMessageSize: Integer, isGlobal: boolean): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># internalSetMaxProducers(maxProducers: Integer, isGlobal: boolean): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># internalSetMaxSubscriptionsPerTopic(maxSubscriptionsPerTopic: Integer, isGlobal: boolean): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># internalSetMaxUnackedMessagesOnConsumer(maxUnackedNum: Integer, isGlobal: boolean): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># internalSetMaxUnackedMessagesOnSubscription(maxUnackedNum: Integer, isGlobal: boolean): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># internalSetMessageTTL(ttlInSecond: Integer, isGlobal: boolean): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># internalSetOffloadPolicies(offloadPolicies: OffloadPoliciesImpl, isGlobal: boolean): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># internalSetPersistence(persistencePolicies: PersistencePolicies, isGlobal: boolean): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># internalSetPublishRate(publishRate: PublishRate, isGlobal: boolean): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># internalSetReplicatedSubscriptionStatus(asyncResponse: AsyncResponse, subName: String, authoritative: boolean, enabled: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >- internalSetReplicatedSubscriptionStatusForNonPartitionedTopic(asyncResponse: AsyncResponse, subName: String, authoritative: boolean, enabled: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" ># internalSetReplicationClusters(clusterIds: List&lt;String&gt;): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># internalSetReplicatorDispatchRate(dispatchRate: DispatchRateImpl, isGlobal: boolean): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># internalSetRetention(retention: RetentionPolicies, isGlobal: boolean): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># internalSetSchemaCompatibilityStrategy(strategy: SchemaCompatibilityStrategy): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># internalSetSubscribeRate(subscribeRate: SubscribeRate, isGlobal: boolean): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># internalSetSubscriptionDispatchRate(dispatchRate: DispatchRateImpl, isGlobal: boolean): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># internalSetSubscriptionTypesEnabled(subscriptionTypesEnabled: Set&lt;SubscriptionType&gt;, isGlobal: boolean): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># internalSkipAllMessages(asyncResponse: AsyncResponse, subName: String, authoritative: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >- internalSkipAllMessagesForNonPartitionedTopicAsync(asyncResponse: AsyncResponse, subName: String, authoritative: boolean): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># internalSkipMessages(asyncResponse: AsyncResponse, subName: String, numMessages: int, authoritative: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" ># internalTerminate(authoritative: boolean): MessageId</TD></TR>
<TR><TD ALIGN="LEFT" ># internalTerminatePartitionedTopic(asyncResponse: AsyncResponse, authoritative: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" ># internalTriggerCompaction(asyncResponse: AsyncResponse, authoritative: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" ># internalTriggerCompactionNonPartitionedTopic(asyncResponse: AsyncResponse, authoritative: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" ># internalTriggerOffload(asyncResponse: AsyncResponse, authoritative: boolean, messageId: MessageIdImpl)</TD></TR>
<TR><TD ALIGN="LEFT" ># internalTruncateNonPartitionedTopic(asyncResponse: AsyncResponse, authoritative: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" ># internalTruncateTopic(asyncResponse: AsyncResponse, authoritative: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >- internalUnloadNonPartitionedTopicAsync(asyncResponse: AsyncResponse, authoritative: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" ># internalUnloadTopic(asyncResponse: AsyncResponse, authoritative: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >- internalUnloadTransactionCoordinatorAsync(asyncResponse: AsyncResponse, authoritative: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >- internalUpdateOffloadPolicies(offloadPolicies: OffloadPoliciesImpl, topicName: TopicName): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># internalUpdatePartitionedTopic(numPartitions: int, updateLocalTopicOnly: boolean, authoritative: boolean, force: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" ># preValidation(authoritative: boolean): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- resumeAsyncResponse(asyncResponse: AsyncResponse, subscriptions: Set&lt;String&gt;, subscriptionFutures: List&lt;CompletableFuture&lt;Object&gt;&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >- revokePermissions(topicUri: String, role: String)</TD></TR>
<TR><TD ALIGN="LEFT" >- topicNotFoundReason(topicName: TopicName): RestException</TD></TR>
<TR><TD ALIGN="LEFT" >- topicNotFoundReasonAsync(topicName: TopicName): CompletableFuture&lt;Topic&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ unsafeGetPartitionedTopicMetadataAsync(pulsar: PulsarService, topicName: TopicName): CompletableFuture&lt;PartitionedTopicMetadata&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- updatePartitionInOtherCluster(numPartitions: int, clusters: Set&lt;String&gt;): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- updatePartitionedTopic(topicName: TopicName, numPartitions: int, force: boolean): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ validateAdminOperationOnTopic(authoritative: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >- validateClientVersion()</TD></TR>
<TR><TD ALIGN="LEFT" ># validateCreateTopic(topicName: TopicName)</TD></TR>
<TR><TD ALIGN="LEFT" >- validateNonPartitionTopicName(topicName: String)</TD></TR>
<TR><TD ALIGN="LEFT" >- validatePartitionTopicUpdate(topicName: String, numberOfPartition: int)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

Policies896442176[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)Policies</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+   auth_policies: AuthPolicies [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   autoSubscriptionCreationOverride: AutoSubscriptionCreationOverride [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   autoTopicCreationOverride: AutoTopicCreationOverride [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   backlog_quota_map: Map&lt;BacklogQuotaType, BacklogQuota&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >+   bundles: BundlesData [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   clusterDispatchRate: Map&lt;String, DispatchRateImpl&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >+   clusterSubscribeRate: Map&lt;String, SubscribeRate&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >+   compaction_threshold: Long [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   deduplicationEnabled: Boolean [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   deduplicationSnapshotIntervalSeconds: Integer [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   delayed_delivery_policies: DelayedDeliveryPolicies [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   deleted: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   encryption_required: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   inactive_topic_policies: InactiveTopicPolicies [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   is_allow_auto_update_schema: Boolean [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   latency_stats_sample_rate: Map&lt;String, Integer&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >+   max_consumers_per_subscription: Integer [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   max_consumers_per_topic: Integer [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   max_producers_per_topic: Integer [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   max_subscriptions_per_topic: Integer [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   max_topics_per_namespace: Integer [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   max_unacked_messages_per_consumer: Integer [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   max_unacked_messages_per_subscription: Integer [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   message_ttl_in_seconds: Integer [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   offload_deletion_lag_ms: Long [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   offload_policies: OffloadPolicies [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   offload_threshold: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   persistence: PersistencePolicies [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   properties: Map&lt;String, String&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >+   publishMaxMessageRate: Map&lt;String, PublishRate&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >+   replication_clusters: Set&lt;String&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >+   replicatorDispatchRate: Map&lt;String, DispatchRateImpl&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >+   resource_group_name: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   retention_policies: RetentionPolicies [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   schema_auto_update_compatibility_strategy: SchemaAutoUpdateCompatibilityStrategy [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   schema_compatibility_strategy: SchemaCompatibilityStrategy [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   schema_validation_enforced: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   subscriptionDispatchRate: Map&lt;String, DispatchRateImpl&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >+   subscription_auth_mode: SubscriptionAuthMode [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   subscription_expiration_time_minutes: Integer [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   subscription_types_enabled: Set&lt;String&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >+   topicDispatchRate: Map&lt;String, DispatchRateImpl&gt; [0..*]</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

PolicyPath896799675[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)PolicyPath</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ joinPath(parts: String...): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ path(parts: String...): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ splitPath(source: String, slice: int): String</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

PositionInfo840873545[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)PositionInfo</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   bitField0_: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   entryId_: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   ledgerId_: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   memoizedIsInitialized: byte [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># internalGetFieldAccessorTable(): FieldAccessorTable</TD></TR>
<TR><TD ALIGN="LEFT" >+ newBuilder(): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ newBuilder(prototype: PositionInfo): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ newBuilderForType(): Builder</TD></TR>
<TR><TD ALIGN="LEFT" ># newBuilderForType(parent: BuilderParent): Builder</TD></TR>
<TR><TD ALIGN="LEFT" ># newInstance(unused: UnusedPrivateParameter): Object</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseDelimitedFrom(input: InputStream): PositionInfo</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseDelimitedFrom(input: InputStream, extensionRegistry: ExtensionRegistryLite): PositionInfo</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(data: ByteBuffer): PositionInfo</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(data: ByteBuffer, extensionRegistry: ExtensionRegistryLite): PositionInfo</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(data: ByteString): PositionInfo</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(data: ByteString, extensionRegistry: ExtensionRegistryLite): PositionInfo</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(data: byte[]): PositionInfo</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(data: byte[], extensionRegistry: ExtensionRegistryLite): PositionInfo</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(input: InputStream): PositionInfo</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(input: InputStream, extensionRegistry: ExtensionRegistryLite): PositionInfo</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(input: CodedInputStream): PositionInfo</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(input: CodedInputStream, extensionRegistry: ExtensionRegistryLite): PositionInfo</TD></TR>
<TR><TD ALIGN="LEFT" >+ parser(): Parser&lt;PositionInfo&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ toBuilder(): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeTo(output: CodedOutputStream)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

PrecisPublishLimiter1718290011[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)PrecisPublishLimiter</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   publishMaxByteRate: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   publishMaxMessageRate: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   rateLimitFunction: RateLimitFunction [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   scheduledExecutorService: ScheduledExecutorService [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   topicPublishRateLimiterOnByte: RateLimiter [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   topicPublishRateLimiterOnMessage: RateLimiter [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ checkPublishRate()</TD></TR>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ incrementPublishCount(numOfMessages: int, msgSizeInBytes: long)</TD></TR>
<TR><TD ALIGN="LEFT" >- replaceLimiters(updater: Runnable)</TD></TR>
<TR><TD ALIGN="LEFT" >+ resetPublishCount(): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ tryAcquire(numbers: int, bytes: long): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >- tryReleaseConnectionThrottle()</TD></TR>
<TR><TD ALIGN="LEFT" >+ update(policies: Policies, clusterName: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ update(maxPublishRate: PublishRate)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

PrimitiveSchemaDataValidator349782408[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)PrimitiveSchemaDataValidator</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ of(): PrimitiveSchemaDataValidator</TD></TR>
<TR><TD ALIGN="LEFT" >+ validate(schemaData: SchemaData)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

Producer1718290011[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)Producer</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   accessMode: ProducerAccessMode [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   appId: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   chunkedMessageRate: Rate [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   clientAddress: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   closeFuture: CompletableFuture&lt;Void&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   cnx: TransportCnx [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   epoch: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   isClosed: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   isDisconnecting: AtomicBoolean [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   isEncrypted: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   isNonPersistentTopic: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   isRemote: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   metadata: Map&lt;String, String&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   msgDrop: Rate [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   msgIn: Rate [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   pendingPublishAcks: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   producerId: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   producerName: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   remoteCluster: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   schemaVersion: SchemaVersion [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   stats: PublisherStatsImpl [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   topic: Topic [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   topicEpoch: Optional&lt;Long&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   userProvidedProducerName: boolean [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ checkAndStartPublish(producerId: long, sequenceId: long, headersAndPayload: ByteBuf, batchSize: long): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ checkEncryption()</TD></TR>
<TR><TD ALIGN="LEFT" >+ checkPermissionsAsync(): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ close(removeFromTopic: boolean): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ closeNow(removeFromTopic: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ disconnect(): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ isSuccessorTo(other: Producer): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >- parseRemoteClusterName(producerName: String, isRemote: boolean, replicatorPrefix: String): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ publishMessage(producerId: long, sequenceId: long, headersAndPayload: ByteBuf, batchSize: long, isChunked: boolean, isMarker: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ publishMessage(producerId: long, lowestSequenceId: long, highestSequenceId: long, headersAndPayload: ByteBuf, batchSize: long, isChunked: boolean, isMarker: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >- publishMessageToTopic(headersAndPayload: ByteBuf, sequenceId: long, batchSize: long, isChunked: boolean, isMarker: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >- publishMessageToTopic(headersAndPayload: ByteBuf, lowestSequenceId: long, highestSequenceId: long, batchSize: long, isChunked: boolean, isMarker: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >- publishOperationCompleted()</TD></TR>
<TR><TD ALIGN="LEFT" >+ publishTxnMessage(txnID: TxnID, producerId: long, sequenceId: long, highSequenceId: long, headersAndPayload: ByteBuf, batchSize: long, isChunked: boolean, isMarker: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ recordMessageDrop(batchSize: int)</TD></TR>
<TR><TD ALIGN="LEFT" >- startPublishOperation(batchSize: int, msgSize: long)</TD></TR>
<TR><TD ALIGN="LEFT" >+ updateRates()</TD></TR>
<TR><TD ALIGN="LEFT" >+ updateRates(numOfMessages: int, msgSizeInBytes: long)</TD></TR>
<TR><TD ALIGN="LEFT" >- verifyChecksum(headersAndPayload: ByteBuf): boolean</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

ProducerBase12001400[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)ProducerBase&lt;T&gt;</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   conf: ProducerConfigurationData [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   interceptors: ProducerInterceptors [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   multiSchemaMode: MultiSchemaMode [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   producerCreatedFuture: CompletableFuture&lt;Producer&lt;T&gt;&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   schema: Schema&lt;T&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   schemaCache: ConcurrentOpenHashMap&lt;SchemaHash, byte[]&gt; [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># beforeSend(message: Message&lt;?&gt;): Message&lt;?&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ closeAsync(): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ flush()</TD></TR>
<TR><TD ALIGN="LEFT" ># internalSendAsync(message: Message&lt;?&gt;): CompletableFuture&lt;MessageId&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># internalSendWithTxnAsync(message: Message&lt;?&gt;, txn: Transaction): CompletableFuture&lt;MessageId&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ newMessage(): TypedMessageBuilder&lt;T&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ newMessage(schema: Schema&lt;V&gt;): TypedMessageBuilder&lt;V&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ newMessage(txn: Transaction): TypedMessageBuilder&lt;T&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># onPartitionsChange(topicName: String, partitions: int)</TD></TR>
<TR><TD ALIGN="LEFT" ># onSendAcknowledgement(message: Message&lt;?&gt;, msgId: MessageId, exception: Throwable)</TD></TR>
<TR><TD ALIGN="LEFT" >+ producerCreatedFuture(): CompletableFuture&lt;Producer&lt;T&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ send(message: T): MessageId</TD></TR>
<TR><TD ALIGN="LEFT" >+ send(message: Message&lt;?&gt;): MessageId</TD></TR>
<TR><TD ALIGN="LEFT" >+ sendAsync(message: T): CompletableFuture&lt;MessageId&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ sendAsync(message: Message&lt;?&gt;): CompletableFuture&lt;MessageId&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># triggerFlush()</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

ProducerBusyException1254029274[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)ProducerBusyException</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

ProducerFencedException1254029274[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)ProducerFencedException</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

ProducerImpl12001400[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)ProducerImpl&lt;T&gt;</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   batchMessageContainer: BatchMessageContainerBase [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   batchTimerTask: ScheduledFuture&lt;?&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   compressor: CompressionCodec [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   connectedSince: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   connectionHandler: ConnectionHandler [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   connectionId: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   errorState: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   isLastSequenceIdPotentialDuplicated: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   keyGeneratorTask: ScheduledFuture&lt;?&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   lastSendFuture: CompletableFuture&lt;MessageId&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   lastSendFutureWrapper: LastSendFutureWrapper [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   lastSequenceIdPublished: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   lastSequenceIdPushed: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   lookupDeadline: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   metadata: Map&lt;String, String&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   msgCrypto: MessageCrypto [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   msgIdGenerator: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   partitionIndex: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   pendingMessages: OpSendMsgQueue [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   previousExceptions: List&lt;Throwable&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   producerDeadline: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   producerId: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   producerName: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   schemaVersion: Optional&lt;byte[]&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   semaphore: Optional&lt;Semaphore&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   sendTimeout: Timeout [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   stats: ProducerStatsRecorder [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   topicEpoch: Optional&lt;Long&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   userProvidedProducerName: boolean [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># ackReceived(cnx: ClientCnx, sequenceId: long, highestSequenceId: long, ledgerId: long, entryId: long)</TD></TR>
<TR><TD ALIGN="LEFT" >- applyCompression(payload: ByteBuf): ByteBuf</TD></TR>
<TR><TD ALIGN="LEFT" >- batchMessageAndSend()</TD></TR>
<TR><TD ALIGN="LEFT" >+ brokerChecksumSupportedVersion(): int</TD></TR>
<TR><TD ALIGN="LEFT" >- canAddToBatch(msg: MessageImpl&lt;?&gt;): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >- canAddToCurrentBatch(msg: MessageImpl&lt;?&gt;): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >- canEnqueueRequest(callback: SendCallback, sequenceId: long, payloadSize: int): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >- closeAndClearPendingMessages()</TD></TR>
<TR><TD ALIGN="LEFT" >+ closeAsync(): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- closeProducerTasks()</TD></TR>
<TR><TD ALIGN="LEFT" ># cnx(): ClientCnx</TD></TR>
<TR><TD ALIGN="LEFT" >- completeCallbackAndReleaseSemaphore(payloadSize: long, callback: SendCallback, exception: Exception)</TD></TR>
<TR><TD ALIGN="LEFT" ># connectionClosed(cnx: ClientCnx)</TD></TR>
<TR><TD ALIGN="LEFT" >+ connectionFailed(exception: PulsarClientException)</TD></TR>
<TR><TD ALIGN="LEFT" >+ connectionOpened(cnx: ClientCnx)</TD></TR>
<TR><TD ALIGN="LEFT" ># createPendingMessagesQueue(): OpSendMsgQueue</TD></TR>
<TR><TD ALIGN="LEFT" >- doBatchSendAndAdd(msg: MessageImpl&lt;?&gt;, callback: SendCallback, payload: ByteBuf)</TD></TR>
<TR><TD ALIGN="LEFT" ># encryptMessage(msgMetadata: MessageMetadata, compressedPayload: ByteBuf): ByteBuf</TD></TR>
<TR><TD ALIGN="LEFT" >- failPendingBatchMessages(ex: PulsarClientException)</TD></TR>
<TR><TD ALIGN="LEFT" >- failPendingMessages(cnx: ClientCnx, ex: PulsarClientException)</TD></TR>
<TR><TD ALIGN="LEFT" >+ flushAsync(): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- getHighestSequenceId(op: OpSendMsg): long</TD></TR>
<TR><TD ALIGN="LEFT" >- getOrCreateSchemaAsync(cnx: ClientCnx, schemaInfo: SchemaInfo): CompletableFuture&lt;byte[]&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># grabCnx()</TD></TR>
<TR><TD ALIGN="LEFT" ># internalSendAsync(message: Message&lt;?&gt;): CompletableFuture&lt;MessageId&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># internalSendWithTxnAsync(message: Message&lt;?&gt;, txn: Transaction): CompletableFuture&lt;MessageId&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- isMultiSchemaEnabled(autoEnable: boolean): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >- isValidProducerState(callback: SendCallback, sequenceId: long): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >- populateMessageSchema(msg: MessageImpl, callback: SendCallback): boolean</TD></TR>
<TR><TD ALIGN="LEFT" ># processOpSendMsg(op: OpSendMsg)</TD></TR>
<TR><TD ALIGN="LEFT" >- rePopulateMessageSchema(msg: MessageImpl): boolean</TD></TR>
<TR><TD ALIGN="LEFT" ># reconnectLater(exception: Throwable)</TD></TR>
<TR><TD ALIGN="LEFT" ># recoverChecksumError(cnx: ClientCnx, sequenceId: long)</TD></TR>
<TR><TD ALIGN="LEFT" ># recoverNotAllowedError(sequenceId: long)</TD></TR>
<TR><TD ALIGN="LEFT" >- recoverProcessOpSendMsgFrom(cnx: ClientCnx, from: MessageImpl, expectedEpoch: long)</TD></TR>
<TR><TD ALIGN="LEFT" >- releaseSemaphoreForSendOp(op: OpSendMsg)</TD></TR>
<TR><TD ALIGN="LEFT" >- resendMessages(cnx: ClientCnx, expectedEpoch: long)</TD></TR>
<TR><TD ALIGN="LEFT" ># resetBackoff()</TD></TR>
<TR><TD ALIGN="LEFT" >+ run(timeout: Timeout)</TD></TR>
<TR><TD ALIGN="LEFT" ># semaphoreRelease(releaseCountRequest: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ sendAsync(message: Message&lt;?&gt;, callback: SendCallback)</TD></TR>
<TR><TD ALIGN="LEFT" ># sendMessage(producerId: long, sequenceId: long, numMessages: int, msgMetadata: MessageMetadata, compressedPayload: ByteBuf): ByteBufPair</TD></TR>
<TR><TD ALIGN="LEFT" ># sendMessage(producerId: long, lowestSequenceId: long, highestSequenceId: long, numMessages: int, msgMetadata: MessageMetadata, compressedPayload: ByteBuf): ByteBufPair</TD></TR>
<TR><TD ALIGN="LEFT" >- serializeAndSendMessage(msg: MessageImpl&lt;?&gt;, payload: ByteBuf, sequenceId: long, uuid: String, chunkId: int, totalChunks: int, readStartIndex: int, chunkMaxSizeInBytes: int, compressedPayload: ByteBuf, compressed: boolean, compressedPayloadSize: int, uncompressedSize: int, callback: SendCallback, chunkedMessageCtx: ChunkedMessageCtx)</TD></TR>
<TR><TD ALIGN="LEFT" >- stripChecksum(op: OpSendMsg)</TD></TR>
<TR><TD ALIGN="LEFT" >+ terminated(cnx: ClientCnx)</TD></TR>
<TR><TD ALIGN="LEFT" ># triggerFlush()</TD></TR>
<TR><TD ALIGN="LEFT" >- tryRegisterSchema(cnx: ClientCnx, msg: MessageImpl, callback: SendCallback, expectedCnxEpoch: long)</TD></TR>
<TR><TD ALIGN="LEFT" ># verifyLocalBufferIsNotCorrupted(op: OpSendMsg): boolean</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

ProducerSendCallback842869190[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)ProducerSendCallback</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   entry: Entry [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   msg: MessageImpl [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   recyclerHandle: Handle&lt;ProducerSendCallback&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   replicator: NonPersistentReplicator [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ addCallback(msg: MessageImpl&lt;?&gt;, scb: SendCallback)</TD></TR>
<TR><TD ALIGN="LEFT" ># create(replicator: NonPersistentReplicator, entry: Entry, msg: MessageImpl): ProducerSendCallback</TD></TR>
<TR><TD ALIGN="LEFT" >- recycle()</TD></TR>
<TR><TD ALIGN="LEFT" >+ sendComplete(exception: Exception)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

ProducerStatsRecorderImpl12001400[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)ProducerStatsRecorderImpl</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   batchSizeDs: DoublesSketch [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   batchSizePctValues: double[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   ds: DoublesSketch [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   latencyPctValues: double[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   msgSizeDs: DoublesSketch [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   msgSizePctValues: double[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   numAcksReceived: LongAdder [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   numBytesSent: LongAdder [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   numMsgsSent: LongAdder [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   numSendFailed: LongAdder [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   oldTime: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   producer: ProducerImpl&lt;?&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   pulsarClient: PulsarClientImpl [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   sendBytesRate: double [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   sendMsgsRate: double [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   stat: TimerTask [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   statTimeout: Timeout [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   statsIntervalSeconds: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   totalAcksReceived: LongAdder [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   totalBytesSent: LongAdder [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   totalMsgsSent: LongAdder [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   totalSendFailed: LongAdder [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ cancelStatsTimeout()</TD></TR>
<TR><TD ALIGN="LEFT" >+ incrementNumAcksReceived(latencyNs: long)</TD></TR>
<TR><TD ALIGN="LEFT" >+ incrementSendFailed()</TD></TR>
<TR><TD ALIGN="LEFT" >+ incrementSendFailed(numMsgs: long)</TD></TR>
<TR><TD ALIGN="LEFT" >- init(conf: ProducerConfigurationData)</TD></TR>
<TR><TD ALIGN="LEFT" ># reset()</TD></TR>
<TR><TD ALIGN="LEFT" ># updateCumulativeStats(stats: ProducerStats)</TD></TR>
<TR><TD ALIGN="LEFT" >+ updateNumMsgsSent(numMsgs: long, totalMsgsSize: long)</TD></TR>
<TR><TD ALIGN="LEFT" ># updateStats()</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

ProducerV1Impl1051373919[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)ProducerV1Impl</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   producer: ProducerImpl&lt;byte[]&gt; [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ closeAsync(): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ flush()</TD></TR>
<TR><TD ALIGN="LEFT" >+ flushAsync(): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ send(value: byte[]): MessageId</TD></TR>
<TR><TD ALIGN="LEFT" >+ send(value: Message&lt;byte[]&gt;): MessageId</TD></TR>
<TR><TD ALIGN="LEFT" >+ sendAsync(arg0: byte[]): CompletableFuture&lt;MessageId&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ sendAsync(arg0: Message&lt;byte[]&gt;): CompletableFuture&lt;MessageId&gt;</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

Properties620988780[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)Properties</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

ProtobufNativeSchemaCompatibilityCheck445450388[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)ProtobufNativeSchemaCompatibilityCheck</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ checkCompatible(from: SchemaData, to: SchemaData, strategy: SchemaCompatibilityStrategy)</TD></TR>
<TR><TD ALIGN="LEFT" >+ checkCompatible(from: Iterable&lt;SchemaData&gt;, to: SchemaData, strategy: SchemaCompatibilityStrategy)</TD></TR>
<TR><TD ALIGN="LEFT" >- checkRootMessageChange(fromDescriptor: Descriptor, toDescriptor: Descriptor, strategy: SchemaCompatibilityStrategy)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

ProtobufNativeSchemaData1472480913[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)ProtobufNativeSchemaData</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   fileDescriptorSet: byte[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   rootFileDescriptorName: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   rootMessageTypeName: String [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ builder(): ProtobufNativeSchemaDataBuilder</TD></TR>
<TR><TD ALIGN="LEFT" ># canEqual(other: Object): boolean</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

ProtobufNativeSchemaDataValidator349782408[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)ProtobufNativeSchemaDataValidator</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ of(): ProtobufNativeSchemaDataValidator</TD></TR>
<TR><TD ALIGN="LEFT" >+ validate(schemaData: SchemaData)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

ProtobufNativeSchemaUtils1622012615[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)ProtobufNativeSchemaUtils</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ deserialize(schemaDataBytes: byte[]): Descriptor</TD></TR>
<TR><TD ALIGN="LEFT" >- deserializeFileDescriptor(fileDescriptorProto: FileDescriptorProto, fileDescriptorCache: Map&lt;String, FileDescriptor&gt;, fileDescriptorProtoCache: Map&lt;String, FileDescriptorProto&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ serialize(descriptor: Descriptor): byte[]</TD></TR>
<TR><TD ALIGN="LEFT" >- serializeFileDescriptor(fileDescriptor: FileDescriptor, fileDescriptorCache: Map&lt;String, FileDescriptorProto&gt;)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

ProtobufReader657740342[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)ProtobufReader&lt;T extends com.google.protobuf.GeneratedMessageV3&gt;</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   tParser: Parser&lt;T&gt; [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ read(bytes: byte[], offset: int, length: int): T</TD></TR>
<TR><TD ALIGN="LEFT" >+ read(inputStream: InputStream): T</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

ProtobufSchemaCompatibilityCheck445450388[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)ProtobufSchemaCompatibilityCheck</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

ProtobufWriter502335110[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)ProtobufWriter&lt;T extends com.google.protobuf.GeneratedMessageV3&gt;</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ write(message: T): byte[]</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

ProxyBackendHandler828483243[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)ProxyBackendHandler</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   config: ProxyConfiguration [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   ctx: ChannelHandlerContext [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   protocolVersion: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   remoteHostName: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   state: BackendState [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ channelActive(ctx: ChannelHandlerContext)</TD></TR>
<TR><TD ALIGN="LEFT" >+ channelInactive(ctx: ChannelHandlerContext)</TD></TR>
<TR><TD ALIGN="LEFT" >+ channelRead(ctx: ChannelHandlerContext, msg: Object)</TD></TR>
<TR><TD ALIGN="LEFT" >+ channelWritabilityChanged(ctx: ChannelHandlerContext)</TD></TR>
<TR><TD ALIGN="LEFT" >+ exceptionCaught(ctx: ChannelHandlerContext, cause: Throwable)</TD></TR>
<TR><TD ALIGN="LEFT" ># handleAuthChallenge(authChallenge: CommandAuthChallenge)</TD></TR>
<TR><TD ALIGN="LEFT" ># handleConnected(connected: CommandConnected)</TD></TR>
<TR><TD ALIGN="LEFT" ># messageReceived()</TD></TR>
<TR><TD ALIGN="LEFT" >- startDirectProxying(connected: CommandConnected)</TD></TR>
<TR><TD ALIGN="LEFT" >- verifyTlsHostName(hostname: String, ctx: ChannelHandlerContext): boolean</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

ProxyClientCnx79518146[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)ProxyClientCnx</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   clientAuthData: AuthData [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   clientAuthMethod: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   clientAuthRole: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   protocolVersion: int [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># newConnectCommand(): ByteBuf</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

ProxyConnection79518146[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)ProxyConnection</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   authMethod: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   authState: AuthenticationState [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   authenticationData: AuthenticationDataSource [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   authenticationProvider: AuthenticationProvider [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   brokerProxyValidator: BrokerProxyValidator [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   clientAuthData: AuthData [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   clientAuthMethod: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   clientAuthRole: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   clientConf: ClientConfigurationData [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   connectionPool: ConnectionPool [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   directProxyHandler: DirectProxyHandler [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   haProxyMessage: HAProxyMessage [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   hasProxyToBrokerUrl: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   lookupProxyHandler: LookupProxyHandler [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   protocolVersionToAdvertise: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   proxyToBrokerUrl: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   requestIdGenerator: AtomicLong [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   service: ProxyService [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   sslHandlerSupplier: Supplier&lt;SslHandler&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   state: State [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ channelActive(ctx: ChannelHandlerContext)</TD></TR>
<TR><TD ALIGN="LEFT" >+ channelInactive(ctx: ChannelHandlerContext)</TD></TR>
<TR><TD ALIGN="LEFT" >+ channelRead(ctx: ChannelHandlerContext, msg: Object)</TD></TR>
<TR><TD ALIGN="LEFT" >+ channelRegistered(ctx: ChannelHandlerContext)</TD></TR>
<TR><TD ALIGN="LEFT" >+ channelUnregistered(ctx: ChannelHandlerContext)</TD></TR>
<TR><TD ALIGN="LEFT" >+ channelWritabilityChanged(ctx: ChannelHandlerContext)</TD></TR>
<TR><TD ALIGN="LEFT" ># clientAddress(): SocketAddress</TD></TR>
<TR><TD ALIGN="LEFT" >- completeConnect(clientData: AuthData)</TD></TR>
<TR><TD ALIGN="LEFT" ># createClientConfiguration(): ClientConfigurationData</TD></TR>
<TR><TD ALIGN="LEFT" ># ctx(): ChannelHandlerContext</TD></TR>
<TR><TD ALIGN="LEFT" >- doAuthentication(clientData: AuthData)</TD></TR>
<TR><TD ALIGN="LEFT" >+ exceptionCaught(ctx: ChannelHandlerContext, cause: Throwable)</TD></TR>
<TR><TD ALIGN="LEFT" >- getProtocolVersionToAdvertise(connect: CommandConnect): int</TD></TR>
<TR><TD ALIGN="LEFT" ># handleAuthResponse(authResponse: CommandAuthResponse)</TD></TR>
<TR><TD ALIGN="LEFT" ># handleConnect(connect: CommandConnect)</TD></TR>
<TR><TD ALIGN="LEFT" ># handleGetSchema(commandGetSchema: CommandGetSchema)</TD></TR>
<TR><TD ALIGN="LEFT" ># handleGetTopicsOfNamespace(commandGetTopicsOfNamespace: CommandGetTopicsOfNamespace)</TD></TR>
<TR><TD ALIGN="LEFT" ># handleLookup(lookup: CommandLookupTopic)</TD></TR>
<TR><TD ALIGN="LEFT" ># handlePartitionMetadataRequest(partitionMetadata: CommandPartitionedTopicMetadata)</TD></TR>
<TR><TD ALIGN="LEFT" >- isBrokerActive(targetBrokerHostPort: String): boolean</TD></TR>
<TR><TD ALIGN="LEFT" ># matchesHostAndPort(expectedPrefix: String, pulsarServiceUrl: String, brokerHostPort: String): boolean</TD></TR>
<TR><TD ALIGN="LEFT" ># newRequestId(): long</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

ProxyConnectionPool79518146[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)ProxyConnectionPool</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

ProxyService79518146[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)ProxyService</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   acceptorGroup: EventLoopGroup [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   acceptorThreadFactory: DefaultThreadFactory [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   authenticationService: AuthenticationService [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   authorizationService: AuthorizationService [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   brokerProxyValidator: BrokerProxyValidator [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   clientCnxs: Set&lt;ProxyConnection&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   configMetadataStore: MetadataStoreExtended [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   discoveryProvider: BrokerDiscoveryProvider [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   dnsNameResolver: DnsNameResolver [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   extensionsWorkerGroups: List&lt;EventLoopGroup&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   listenChannel: Channel [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   listenChannelTls: Channel [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   localMetadataStore: MetadataStoreExtended [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   lookupRequestSemaphore: AtomicReference&lt;Semaphore&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   proxyAdditionalServlets: AdditionalServlets [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   proxyClientAuthentication: Authentication [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   proxyConfig: ProxyConfiguration [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   proxyExtensions: ProxyExtensions [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   proxyLogLevel: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   pulsarResources: PulsarResources [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   serviceUrl: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   serviceUrlTls: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   statsExecutor: ScheduledExecutorService [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   topicStats: Map&lt;String, TopicStats&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   workerGroup: EventLoopGroup [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   workersThreadFactory: DefaultThreadFactory [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ createConfigurationMetadataStore(): MetadataStoreExtended</TD></TR>
<TR><TD ALIGN="LEFT" >+ createLocalMetadataStore(): MetadataStoreExtended</TD></TR>
<TR><TD ALIGN="LEFT" >+ start()</TD></TR>
<TR><TD ALIGN="LEFT" >- startProxyExtension(extensionName: String, address: SocketAddress, initializer: ChannelInitializer&lt;SocketChannel&gt;, serverBootstrap: ServerBootstrap)</TD></TR>
<TR><TD ALIGN="LEFT" >+ startProxyExtensions(protocolHandlers: Map&lt;String, Map&lt;InetSocketAddress, ChannelInitializer&lt;SocketChannel&gt;&gt;&gt;, serverBootstrap: ServerBootstrap)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

ProxyServiceStarter79518146[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)ProxyServiceStarter</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   config: ProxyConfiguration [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   configFile: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   configurationMetadataStoreUrl: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   configurationStoreServers: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   generateDocs: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   globalZookeeperServers: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   help: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   metadataStoreUrl: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   proxyService: ProxyService [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   server: WebServer [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   zookeeperServers: String [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ addWebServerHandlers(server: WebServer, config: ProxyConfiguration, service: ProxyService, discoveryProvider: BrokerDiscoveryProvider)</TD></TR>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >- createClusterData(config: ProxyConfiguration): ClusterData</TD></TR>
<TR><TD ALIGN="LEFT" >+ main(args: String[])</TD></TR>
<TR><TD ALIGN="LEFT" >+ start()</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

ProxyStats1244791364[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)ProxyStats</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   service: ProxyService [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   servletContext: ServletContext [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ getProxyLogLevel(logLevel: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ metrics(): List&lt;ConnectionStats&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># proxyService(): ProxyService</TD></TR>
<TR><TD ALIGN="LEFT" >+ topics(): Map&lt;String, TopicStats&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ updateProxyLogLevel(logLevel: int)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

PublishRateLimiterDisable1718290011[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)PublishRateLimiterDisable</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ checkPublishRate()</TD></TR>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ incrementPublishCount(numOfMessages: int, msgSizeInBytes: long)</TD></TR>
<TR><TD ALIGN="LEFT" >+ resetPublishCount(): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ tryAcquire(numbers: int, bytes: long): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ update(policies: Policies, clusterName: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ update(maxPublishRate: PublishRate)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

PublishRateLimiterImpl1718290011[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)PublishRateLimiterImpl</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   currentPublishByteCount: LongAdder [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   currentPublishMsgCount: LongAdder [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   publishMaxByteRate: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   publishMaxMessageRate: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   publishRateExceeded: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   publishThrottlingEnabled: boolean [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ checkPublishRate()</TD></TR>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ incrementPublishCount(numOfMessages: int, msgSizeInBytes: long)</TD></TR>
<TR><TD ALIGN="LEFT" >+ resetPublishCount(): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ tryAcquire(numbers: int, bytes: long): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ update(policies: Policies, clusterName: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ update(maxPublishRate: PublishRate)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

PublisherStatsImpl2018762865[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)PublisherStatsImpl</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+   accessMode: ProducerAccessMode [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   addressLength: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   addressOffset: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   averageMsgSize: double [1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   chunkedMessageRate: double [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   clientVersionLength: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   clientVersionOffset: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   connectedSinceLength: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   connectedSinceOffset: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   count: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   metadata: Map&lt;String, String&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >+   msgRateIn: double [1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   msgThroughputIn: double [1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   producerId: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   producerNameLength: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   producerNameOffset: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   stringBuffer: StringBuilder [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   supportsPartialProducer: boolean [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ add(stats: PublisherStatsImpl): PublisherStatsImpl</TD></TR>
<TR><TD ALIGN="LEFT" ># canEqual(other: Object): boolean</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

PulsarAdminBuilderImpl1292556772[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)PulsarAdminBuilderImpl</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   autoCertRefreshTime: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   autoCertRefreshTimeUnit: TimeUnit [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   clientBuilderClassLoader: ClassLoader [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   conf: ClientConfigurationData [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   connectTimeout: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   connectTimeoutUnit: TimeUnit [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   readTimeout: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   readTimeoutUnit: TimeUnit [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   requestTimeout: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   requestTimeoutUnit: TimeUnit [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ allowTlsInsecureConnection(allowTlsInsecureConnection: boolean): PulsarAdminBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ authentication(authentication: Authentication): PulsarAdminBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ authentication(authPluginClassName: String, authParams: Map&lt;String, String&gt;): PulsarAdminBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ authentication(authPluginClassName: String, authParamsString: String): PulsarAdminBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ autoCertRefreshTime(autoCertRefreshTime: int, autoCertRefreshTimeUnit: TimeUnit): PulsarAdminBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ build(): PulsarAdmin</TD></TR>
<TR><TD ALIGN="LEFT" >+ clone(): PulsarAdminBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ connectionTimeout(connectionTimeout: int, connectionTimeoutUnit: TimeUnit): PulsarAdminBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ enableTlsHostnameVerification(enableTlsHostnameVerification: boolean): PulsarAdminBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ readTimeout(readTimeout: int, readTimeoutUnit: TimeUnit): PulsarAdminBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ requestTimeout(requestTimeout: int, requestTimeoutUnit: TimeUnit): PulsarAdminBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ serviceHttpUrl(serviceHttpUrl: String): PulsarAdminBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ setContextClassLoader(clientBuilderClassLoader: ClassLoader): PulsarAdminBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ sslProvider(sslProvider: String): PulsarAdminBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ tlsCiphers(tlsCiphers: Set&lt;String&gt;): PulsarAdminBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ tlsProtocols(tlsProtocols: Set&lt;String&gt;): PulsarAdminBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ tlsTrustCertsFilePath(tlsTrustCertsFilePath: String): PulsarAdminBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ tlsTrustStorePassword(tlsTrustStorePassword: String): PulsarAdminBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ tlsTrustStorePath(tlsTrustStorePath: String): PulsarAdminBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ tlsTrustStoreType(tlsTrustStoreType: String): PulsarAdminBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ useKeyStoreTls(useKeyStoreTls: boolean): PulsarAdminBuilder</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

PulsarAdminImpl1292556772[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)PulsarAdminImpl</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   asyncHttpConnector: AsyncHttpConnector [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   auth: Authentication [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   bookies: Bookies [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   brokerStats: BrokerStats [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   brokers: Brokers [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   client: Client [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   clientConfigData: ClientConfigurationData [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   clusters: Clusters [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   connectTimeout: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   connectTimeoutUnit: TimeUnit [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   functions: Functions [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   globalTopicPolicies: TopicPolicies [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   localTopicPolicies: TopicPolicies [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   lookups: Lookup [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   namespaces: Namespaces [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   nonPersistentTopics: NonPersistentTopics [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   packages: Packages [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   properties: Properties [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   proxyStats: ProxyStats [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   readTimeout: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   readTimeoutUnit: TimeUnit [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   requestTimeout: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   requestTimeoutUnit: TimeUnit [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   resourceQuotas: ResourceQuotas [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   resourcegroups: ResourceGroups [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   root: WebTarget [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   schemas: Schemas [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   serviceUrl: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   sinks: Sinks [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   sources: Sources [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   tenants: Tenants [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   topics: TopicsImpl [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   transactions: Transactions [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   worker: Worker [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ bookies(): Bookies</TD></TR>
<TR><TD ALIGN="LEFT" >+ brokerStats(): BrokerStats</TD></TR>
<TR><TD ALIGN="LEFT" >+ brokers(): Brokers</TD></TR>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ clusters(): Clusters</TD></TR>
<TR><TD ALIGN="LEFT" >+ functions(): Functions</TD></TR>
<TR><TD ALIGN="LEFT" >- getConfigData(auth: Authentication): ClientConfigurationData</TD></TR>
<TR><TD ALIGN="LEFT" >+ lookups(): Lookup</TD></TR>
<TR><TD ALIGN="LEFT" >+ namespaces(): Namespaces</TD></TR>
<TR><TD ALIGN="LEFT" >+ nonPersistentTopics(): NonPersistentTopics</TD></TR>
<TR><TD ALIGN="LEFT" >+ packages(): Packages</TD></TR>
<TR><TD ALIGN="LEFT" >+ properties(): Properties</TD></TR>
<TR><TD ALIGN="LEFT" >+ proxyStats(): ProxyStats</TD></TR>
<TR><TD ALIGN="LEFT" >+ resourceQuotas(): ResourceQuotas</TD></TR>
<TR><TD ALIGN="LEFT" >+ resourcegroups(): ResourceGroups</TD></TR>
<TR><TD ALIGN="LEFT" >+ schemas(): Schemas</TD></TR>
<TR><TD ALIGN="LEFT" >+ sink(): Sink</TD></TR>
<TR><TD ALIGN="LEFT" >+ sinks(): Sinks</TD></TR>
<TR><TD ALIGN="LEFT" >+ source(): Source</TD></TR>
<TR><TD ALIGN="LEFT" >+ sources(): Sources</TD></TR>
<TR><TD ALIGN="LEFT" >+ tenants(): Tenants</TD></TR>
<TR><TD ALIGN="LEFT" >+ topicPolicies(): TopicPolicies</TD></TR>
<TR><TD ALIGN="LEFT" >+ topicPolicies(isGlobal: boolean): TopicPolicies</TD></TR>
<TR><TD ALIGN="LEFT" >+ topics(): Topics</TD></TR>
<TR><TD ALIGN="LEFT" >+ transactions(): Transactions</TD></TR>
<TR><TD ALIGN="LEFT" >+ worker(): Worker</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

PulsarAuthorizationProvider1708110945[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)PulsarAuthorizationProvider</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+   conf: ServiceConfiguration [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   pulsarResources: PulsarResources [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ allowFunctionOpsAsync(namespaceName: NamespaceName, role: String, authenticationData: AuthenticationDataSource): CompletableFuture&lt;Boolean&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ allowNamespaceOperationAsync(namespaceName: NamespaceName, role: String, operation: NamespaceOperation, authData: AuthenticationDataSource): CompletableFuture&lt;Boolean&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ allowNamespacePolicyOperationAsync(namespaceName: NamespaceName, policy: PolicyName, operation: PolicyOperation, role: String, authData: AuthenticationDataSource): CompletableFuture&lt;Boolean&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ allowSinkOpsAsync(namespaceName: NamespaceName, role: String, authenticationData: AuthenticationDataSource): CompletableFuture&lt;Boolean&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ allowSourceOpsAsync(namespaceName: NamespaceName, role: String, authenticationData: AuthenticationDataSource): CompletableFuture&lt;Boolean&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ allowTenantOperationAsync(tenantName: String, role: String, operation: TenantOperation, authData: AuthenticationDataSource): CompletableFuture&lt;Boolean&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- allowTheSpecifiedActionOpsAsync(namespaceName: NamespaceName, role: String, authenticationData: AuthenticationDataSource, authAction: AuthAction): CompletableFuture&lt;Boolean&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ allowTopicOperationAsync(topicName: TopicName, role: String, operation: TopicOperation, authData: AuthenticationDataSource): CompletableFuture&lt;Boolean&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ allowTopicPolicyOperationAsync(topicName: TopicName, role: String, policyName: PolicyName, policyOperation: PolicyOperation, authData: AuthenticationDataSource): CompletableFuture&lt;Boolean&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ canConsumeAsync(topicName: TopicName, role: String, authenticationData: AuthenticationDataSource, subscription: String): CompletableFuture&lt;Boolean&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ canLookupAsync(topicName: TopicName, role: String, authenticationData: AuthenticationDataSource): CompletableFuture&lt;Boolean&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ canProduceAsync(topicName: TopicName, role: String, authenticationData: AuthenticationDataSource): CompletableFuture&lt;Boolean&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- checkAuthorization(topicName: TopicName, role: String, action: AuthAction): CompletableFuture&lt;Boolean&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- checkCluster(topicName: TopicName): CompletableFuture&lt;Boolean&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ checkPermission(topicName: TopicName, role: String, action: AuthAction): CompletableFuture&lt;Boolean&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- checkWildcardPermission(checkedRole: String, checkedAction: AuthAction, permissionMap: Map&lt;String, Set&lt;AuthAction&gt;&gt;): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ grantPermissionAsync(topicName: TopicName, actions: Set&lt;AuthAction&gt;, role: String, authDataJson: String): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ grantPermissionAsync(namespaceName: NamespaceName, actions: Set&lt;AuthAction&gt;, role: String, authDataJson: String): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ grantSubscriptionPermissionAsync(namespace: NamespaceName, subscriptionName: String, roles: Set&lt;String&gt;, authDataJson: String): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ initialize(conf: ServiceConfiguration, pulsarResources: PulsarResources)</TD></TR>
<TR><TD ALIGN="LEFT" >- path(parts: String...): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ revokeSubscriptionPermissionAsync(namespace: NamespaceName, subscriptionName: String, role: String, authDataJson: String): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- updateSubscriptionPermissionAsync(namespace: NamespaceName, subscriptionName: String, roles: Set&lt;String&gt;, remove: boolean): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- validatePoliciesReadOnlyAccess()</TD></TR>
<TR><TD ALIGN="LEFT" >+ validateTenantAdminAccess(tenantName: String, role: String, authData: AuthenticationDataSource): CompletableFuture&lt;Boolean&gt;</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

PulsarChannelInitializer12001400[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)PulsarChannelInitializer</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   clientCnxSupplier: Supplier&lt;ClientCnx&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   nettySSLContextAutoRefreshBuilder: NettySSLContextAutoRefreshBuilder [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   socks5ProxyAddress: InetSocketAddress [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   socks5ProxyPassword: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   socks5ProxyUsername: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   sslContextSupplier: Supplier&lt;SslContext&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   tlsEnabled: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   tlsEnabledWithKeyStore: boolean [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ initChannel(ch: SocketChannel)</TD></TR>
<TR><TD ALIGN="LEFT" ># initSocks5IfConfig(ch: Channel): CompletableFuture&lt;Channel&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># initTls(ch: Channel, sniHost: InetSocketAddress): CompletableFuture&lt;Channel&gt;</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

PulsarChannelInitializer1718290011[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)PulsarChannelInitializer</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   brokerConf: ServiceConfiguration [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   connections: Cache&lt;SocketAddress, ServerCnx&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   enableTls: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   listenerName: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   nettySSLContextAutoRefreshBuilder: NettySSLContextAutoRefreshBuilder [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   pulsar: PulsarService [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   sslCtxRefresher: SslContextAutoRefreshBuilder&lt;SslContext&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   tlsEnabledWithKeyStore: boolean [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># initChannel(ch: SocketChannel)</TD></TR>
<TR><TD ALIGN="LEFT" ># newServerCnx(pulsar: PulsarService, listenerName: String): ServerCnx</TD></TR>
<TR><TD ALIGN="LEFT" >- refreshAuthenticationCredentials()</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

PulsarChannelOptions1676996751[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)PulsarChannelOptions</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   enableTLS: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   listenerName: String [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ builder(): PulsarChannelOptionsBuilder</TD></TR>
<TR><TD ALIGN="LEFT" ># canEqual(other: Object): boolean</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

PulsarClientImpl12001400[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)PulsarClientImpl</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   clientClock: Clock [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   cnxPool: ConnectionPool [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   conf: ClientConfigurationData [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   consumerIdGenerator: AtomicLong [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   consumers: Set&lt;ConsumerBase&lt;?&gt;&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   createdCnxPool: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   createdEventLoopGroup: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   createdExecutorProviders: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   eventLoopGroup: EventLoopGroup [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   externalExecutorProvider: ExecutorProvider [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   internalExecutorProvider: ExecutorProvider [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   lookup: LookupService [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   memoryLimitController: MemoryLimitController [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   needStopTimer: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   producerIdGenerator: AtomicLong [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   producers: Set&lt;ProducerBase&lt;?&gt;&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   requestIdGenerator: AtomicLong [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   schemaProviderLoadingCache: LoadingCache&lt;String, SchemaInfoProvider&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   state: AtomicReference&lt;State&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   tcClient: TransactionCoordinatorClientImpl [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   timer: Timer [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ builder(): PulsarClientImplBuilder</TD></TR>
<TR><TD ALIGN="LEFT" ># cleanupConsumer(consumer: ConsumerBase&lt;?&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" ># cleanupProducer(producer: ProducerBase&lt;?&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ closeAsync(): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- closeCnxPool(cnxPool: ConnectionPool)</TD></TR>
<TR><TD ALIGN="LEFT" ># consumersCount(): int</TD></TR>
<TR><TD ALIGN="LEFT" >- convertRegexSubscriptionMode(regexSubscriptionMode: RegexSubscriptionMode): Mode</TD></TR>
<TR><TD ALIGN="LEFT" ># createMultiTopicReaderAsync(conf: ReaderConfigurationData&lt;T&gt;, schema: Schema&lt;T&gt;): CompletableFuture&lt;Reader&lt;T&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ createProducerAsync(conf: ProducerConfigurationData): CompletableFuture&lt;Producer&lt;byte[]&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ createProducerAsync(conf: ProducerConfigurationData, schema: Schema&lt;T&gt;): CompletableFuture&lt;Producer&lt;T&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ createProducerAsync(conf: ProducerConfigurationData, schema: Schema&lt;T&gt;, interceptors: ProducerInterceptors): CompletableFuture&lt;Producer&lt;T&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- createProducerAsync(topic: String, conf: ProducerConfigurationData, schema: Schema&lt;T&gt;, interceptors: ProducerInterceptors): CompletableFuture&lt;Producer&lt;T&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ createReaderAsync(conf: ReaderConfigurationData&lt;byte[]&gt;): CompletableFuture&lt;Reader&lt;byte[]&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ createReaderAsync(conf: ReaderConfigurationData&lt;T&gt;, schema: Schema&lt;T&gt;): CompletableFuture&lt;Reader&lt;T&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># createSingleTopicReaderAsync(conf: ReaderConfigurationData&lt;T&gt;, schema: Schema&lt;T&gt;): CompletableFuture&lt;Reader&lt;T&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- doSingleTopicSubscribeAsync(conf: ConsumerConfigurationData&lt;T&gt;, schema: Schema&lt;T&gt;, interceptors: ConsumerInterceptors&lt;T&gt;): CompletableFuture&lt;Consumer&lt;T&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ eventLoopGroup(): EventLoopGroup</TD></TR>
<TR><TD ALIGN="LEFT" >+ externalExecutorProvider(): ExecutorProvider</TD></TR>
<TR><TD ALIGN="LEFT" >+ getConnection(topic: String): CompletableFuture&lt;ClientCnx&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- getEventLoopGroup(conf: ClientConfigurationData): EventLoopGroup</TD></TR>
<TR><TD ALIGN="LEFT" >+ getNumberOfPartitions(topic: String): CompletableFuture&lt;Integer&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getPartitionedTopicMetadata(topic: String): CompletableFuture&lt;PartitionedTopicMetadata&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- getPartitionedTopicMetadata(topicName: TopicName, backoff: Backoff, remainingTime: AtomicLong, future: CompletableFuture&lt;PartitionedTopicMetadata&gt;, previousExceptions: List&lt;Throwable&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ getPartitionsForTopic(topic: String): CompletableFuture&lt;List&lt;String&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getSchema(topic: String): CompletableFuture&lt;Optional&lt;SchemaInfo&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- getThreadFactory(poolName: String): ThreadFactory</TD></TR>
<TR><TD ALIGN="LEFT" >- multiTopicSubscribeAsync(conf: ConsumerConfigurationData&lt;T&gt;, schema: Schema&lt;T&gt;, interceptors: ConsumerInterceptors&lt;T&gt;): CompletableFuture&lt;Consumer&lt;T&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ newConsumer(): ConsumerBuilder&lt;byte[]&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ newConsumer(schema: Schema&lt;T&gt;): ConsumerBuilder&lt;T&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># newConsumerId(): long</TD></TR>
<TR><TD ALIGN="LEFT" ># newPartitionedProducerImpl(topic: String, conf: ProducerConfigurationData, schema: Schema&lt;T&gt;, interceptors: ProducerInterceptors, producerCreatedFuture: CompletableFuture&lt;Producer&lt;T&gt;&gt;, metadata: PartitionedTopicMetadata): PartitionedProducerImpl&lt;T&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ newProducer(): ProducerBuilder&lt;byte[]&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ newProducer(schema: Schema&lt;T&gt;): ProducerBuilder&lt;T&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># newProducerId(): long</TD></TR>
<TR><TD ALIGN="LEFT" ># newProducerImpl(topic: String, partitionIndex: int, conf: ProducerConfigurationData, schema: Schema&lt;T&gt;, interceptors: ProducerInterceptors, producerCreatedFuture: CompletableFuture&lt;Producer&lt;T&gt;&gt;, overrideProducerName: Optional&lt;String&gt;): ProducerImpl&lt;T&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ newReader(): ReaderBuilder&lt;byte[]&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ newReader(schema: Schema&lt;T&gt;): ReaderBuilder&lt;T&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ newRequestId(): long</TD></TR>
<TR><TD ALIGN="LEFT" >- newSchemaProvider(topicName: String): SchemaInfoProvider</TD></TR>
<TR><TD ALIGN="LEFT" >+ newTableViewBuilder(schema: Schema&lt;T&gt;): TableViewBuilder&lt;T&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ newTransaction(): TransactionBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ patternTopicSubscribeAsync(conf: ConsumerConfigurationData&lt;byte[]&gt;): CompletableFuture&lt;Consumer&lt;byte[]&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- patternTopicSubscribeAsync(conf: ConsumerConfigurationData&lt;T&gt;, schema: Schema&lt;T&gt;, interceptors: ConsumerInterceptors&lt;T&gt;): CompletableFuture&lt;Consumer&lt;T&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># preProcessSchemaBeforeSubscribe(pulsarClientImpl: PulsarClientImpl, schema: Schema&lt;T&gt;, topicName: String): CompletableFuture&lt;Schema&lt;T&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># producersCount(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ reloadLookUp()</TD></TR>
<TR><TD ALIGN="LEFT" >+ shutdown()</TD></TR>
<TR><TD ALIGN="LEFT" >- shutdownEventLoopGroup(eventLoopGroup: EventLoopGroup)</TD></TR>
<TR><TD ALIGN="LEFT" >- shutdownExecutors()</TD></TR>
<TR><TD ALIGN="LEFT" >- singleTopicSubscribeAsync(conf: ConsumerConfigurationData&lt;T&gt;, schema: Schema&lt;T&gt;, interceptors: ConsumerInterceptors&lt;T&gt;): CompletableFuture&lt;Consumer&lt;T&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ subscribeAsync(conf: ConsumerConfigurationData&lt;byte[]&gt;): CompletableFuture&lt;Consumer&lt;byte[]&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ subscribeAsync(conf: ConsumerConfigurationData&lt;T&gt;, schema: Schema&lt;T&gt;, interceptors: ConsumerInterceptors&lt;T&gt;): CompletableFuture&lt;Consumer&lt;T&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ timer(): Timer</TD></TR>
<TR><TD ALIGN="LEFT" >+ topicsPatternFilter(original: List&lt;String&gt;, topicsPattern: Pattern): List&lt;String&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ updateAuthentication(authentication: Authentication)</TD></TR>
<TR><TD ALIGN="LEFT" >+ updateServiceUrl(serviceUrl: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ updateTlsTrustCertsFilePath(tlsTrustCertsFilePath: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ updateTlsTrustStorePathAndPassword(tlsTrustStorePath: String, tlsTrustStorePassword: String)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

PulsarClientImplementationBindingImpl12001400[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)PulsarClientImplementationBindingImpl</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ convertKeyValueDataStringToSchemaInfoSchema(keyValueSchemaInfoDataJsonBytes: byte[]): byte[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ convertKeyValueSchemaInfoDataToString(kvSchemaInfo: KeyValue&lt;SchemaInfo, SchemaInfo&gt;): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ createAuthentication(authPluginClassName: String, authParamsString: String): Authentication</TD></TR>
<TR><TD ALIGN="LEFT" >+ createAuthentication(authPluginClassName: String, authParams: Map&lt;String, String&gt;): Authentication</TD></TR>
<TR><TD ALIGN="LEFT" >+ decodeKeyValueEncodingType(schemaInfo: SchemaInfo): KeyValueEncodingType</TD></TR>
<TR><TD ALIGN="LEFT" >+ decodeKeyValueSchemaInfo(schemaInfo: SchemaInfo): KeyValue&lt;SchemaInfo, SchemaInfo&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ encodeKeyValueSchemaInfo(keySchema: Schema&lt;K&gt;, valueSchema: Schema&lt;V&gt;, keyValueEncodingType: KeyValueEncodingType): SchemaInfo</TD></TR>
<TR><TD ALIGN="LEFT" >+ encodeKeyValueSchemaInfo(schemaName: String, keySchema: Schema&lt;K&gt;, valueSchema: Schema&lt;V&gt;, keyValueEncodingType: KeyValueEncodingType): SchemaInfo</TD></TR>
<TR><TD ALIGN="LEFT" >+ getGenericSchema(schemaInfo: SchemaInfo): GenericSchema&lt;GenericRecord&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getSchema(schemaInfo: SchemaInfo): Schema&lt;?&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ jsonifyKeyValueSchemaInfo(kvSchemaInfo: KeyValue&lt;SchemaInfo, SchemaInfo&gt;): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ jsonifySchemaInfo(schemaInfo: SchemaInfo): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ jsonifySchemaInfoWithVersion(schemaInfoWithVersion: SchemaInfoWithVersion): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ newAuthenticationTLS(certFilePath: String, keyFilePath: String): Authentication</TD></TR>
<TR><TD ALIGN="LEFT" >+ newAuthenticationToken(token: String): Authentication</TD></TR>
<TR><TD ALIGN="LEFT" >+ newAuthenticationToken(supplier: Supplier&lt;String&gt;): Authentication</TD></TR>
<TR><TD ALIGN="LEFT" >+ newAutoConsumeSchema(): Schema&lt;GenericRecord&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ newAutoProduceSchema(): Schema&lt;byte[]&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ newAutoProduceSchema(schema: Schema&lt;?&gt;): Schema&lt;byte[]&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ newAutoProduceValidatedAvroSchema(schema: Object): Schema&lt;byte[]&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ newAvroSchema(schemaDefinition: SchemaDefinition): Schema&lt;T&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ newBooleanSchema(): Schema&lt;Boolean&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ newByteBufferSchema(): Schema&lt;ByteBuffer&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ newByteSchema(): Schema&lt;Byte&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ newBytesSchema(): Schema&lt;byte[]&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ newClientBuilder(): ClientBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ newDateSchema(): Schema&lt;Date&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ newDefaultBatcherBuilder(): BatcherBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ newDefaultMessagePayloadFactory(): MessagePayloadFactory</TD></TR>
<TR><TD ALIGN="LEFT" >+ newDoubleSchema(): Schema&lt;Double&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ newFloatSchema(): Schema&lt;Float&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ newInstantSchema(): Schema&lt;Instant&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ newIntSchema(): Schema&lt;Integer&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ newJSONSchema(schemaDefinition: SchemaDefinition): Schema&lt;T&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ newKeyBasedBatcherBuilder(): BatcherBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ newKeyValueBytesSchema(): Schema&lt;KeyValue&lt;byte[], byte[]&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ newKeyValueSchema(keySchema: Schema&lt;K&gt;, valueSchema: Schema&lt;V&gt;): Schema&lt;KeyValue&lt;K, V&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ newKeyValueSchema(keySchema: Schema&lt;K&gt;, valueSchema: Schema&lt;V&gt;, keyValueEncodingType: KeyValueEncodingType): Schema&lt;KeyValue&lt;K, V&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ newKeyValueSchema(key: Class&lt;K&gt;, value: Class&lt;V&gt;, type: SchemaType): Schema&lt;KeyValue&lt;K, V&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ newLocalDateSchema(): Schema&lt;LocalDate&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ newLocalDateTimeSchema(): Schema&lt;LocalDateTime&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ newLocalTimeSchema(): Schema&lt;LocalTime&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ newLongSchema(): Schema&lt;Long&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ newMessageId(ledgerId: long, entryId: long, partitionIndex: int): MessageId</TD></TR>
<TR><TD ALIGN="LEFT" >+ newMessageIdFromByteArray(data: byte[]): MessageId</TD></TR>
<TR><TD ALIGN="LEFT" >+ newMessageIdFromByteArrayWithTopic(data: byte[], topicName: String): MessageId</TD></TR>
<TR><TD ALIGN="LEFT" >+ newProtobufNativeSchema(schemaDefinition: SchemaDefinition): Schema&lt;T&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ newProtobufSchema(schemaDefinition: SchemaDefinition): Schema&lt;T&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ newRecordSchemaBuilder(name: String): RecordSchemaBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ newSchemaDefinitionBuilder(): SchemaDefinitionBuilder&lt;T&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ newSchemaInfoImpl(name: String, schema: byte[], type: SchemaType, propertiesValue: Map&lt;String, String&gt;): SchemaInfo</TD></TR>
<TR><TD ALIGN="LEFT" >+ newShortSchema(): Schema&lt;Short&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ newStringSchema(): Schema&lt;String&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ newStringSchema(charset: Charset): Schema&lt;String&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ newTimeSchema(): Schema&lt;Time&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ newTimestampSchema(): Schema&lt;Timestamp&gt;</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

PulsarClientV1Impl1051373919[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)PulsarClientV1Impl</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   client: PulsarClientImpl [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ closeAsync(): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ createProducer(topic: String, conf: ProducerConfiguration): Producer</TD></TR>
<TR><TD ALIGN="LEFT" >+ createProducer(topic: String): Producer</TD></TR>
<TR><TD ALIGN="LEFT" >+ createProducerAsync(topic: String, conf: ProducerConfiguration): CompletableFuture&lt;Producer&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ createProducerAsync(topic: String): CompletableFuture&lt;Producer&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ createReader(topic: String, startMessageId: MessageId, conf: ReaderConfiguration): Reader</TD></TR>
<TR><TD ALIGN="LEFT" >+ createReaderAsync(topic: String, startMessageId: MessageId, conf: ReaderConfiguration): CompletableFuture&lt;Reader&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ shutdown()</TD></TR>
<TR><TD ALIGN="LEFT" >+ subscribe(topic: String, subscriptionName: String): Consumer</TD></TR>
<TR><TD ALIGN="LEFT" >+ subscribe(topic: String, subscription: String, conf: ConsumerConfiguration): Consumer</TD></TR>
<TR><TD ALIGN="LEFT" >+ subscribeAsync(topic: String, subscription: String, conf: ConsumerConfiguration): CompletableFuture&lt;Consumer&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ subscribeAsync(topic: String, subscriptionName: String): CompletableFuture&lt;Consumer&gt;</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

PulsarCommandSenderImpl1718290011[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)PulsarCommandSenderImpl</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   cnx: ServerCnx [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   interceptor: BrokerInterceptor [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- safeIntercept(command: BaseCommand, cnx: ServerCnx)</TD></TR>
<TR><TD ALIGN="LEFT" >+ sendActiveConsumerChange(consumerId: long, isActive: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ sendConnectedResponse(clientProtocolVersion: int, maxMessageSize: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ sendError(requestId: long, error: ServerError, message: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ sendErrorResponse(requestId: long, error: ServerError, message: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ sendGetOrCreateSchemaErrorResponse(requestId: long, error: ServerError, errorMessage: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ sendGetOrCreateSchemaResponse(requestId: long, schemaVersion: SchemaVersion)</TD></TR>
<TR><TD ALIGN="LEFT" >+ sendGetSchemaErrorResponse(requestId: long, error: ServerError, errorMessage: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ sendGetSchemaResponse(requestId: long, schema: SchemaInfo, version: SchemaVersion)</TD></TR>
<TR><TD ALIGN="LEFT" >+ sendGetTopicsOfNamespaceResponse(topics: List&lt;String&gt;, requestId: long)</TD></TR>
<TR><TD ALIGN="LEFT" >+ sendLookupResponse(brokerServiceUrl: String, brokerServiceUrlTls: String, authoritative: boolean, response: LookupType, requestId: long, proxyThroughServiceUrl: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ sendLookupResponse(error: ServerError, errorMsg: String, requestId: long)</TD></TR>
<TR><TD ALIGN="LEFT" >+ sendMessagesToConsumer(consumerId: long, topicName: String, subscription: Subscription, partitionIdx: int, entries: List&lt;Entry&gt;, batchSizes: EntryBatchSizes, batchIndexesAcks: EntryBatchIndexesAcks, redeliveryTracker: RedeliveryTracker, epoch: long): ChannelPromise</TD></TR>
<TR><TD ALIGN="LEFT" >+ sendPartitionMetadataResponse(error: ServerError, errorMsg: String, requestId: long)</TD></TR>
<TR><TD ALIGN="LEFT" >+ sendPartitionMetadataResponse(partitions: int, requestId: long)</TD></TR>
<TR><TD ALIGN="LEFT" >+ sendProducerSuccessResponse(requestId: long, producerName: String, schemaVersion: SchemaVersion)</TD></TR>
<TR><TD ALIGN="LEFT" >+ sendProducerSuccessResponse(requestId: long, producerName: String, lastSequenceId: long, schemaVersion: SchemaVersion, topicEpoch: Optional&lt;Long&gt;, isProducerReady: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ sendReachedEndOfTopic(consumerId: long)</TD></TR>
<TR><TD ALIGN="LEFT" >+ sendSendError(producerId: long, sequenceId: long, error: ServerError, errorMsg: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ sendSendReceiptResponse(producerId: long, sequenceId: long, highestId: long, ledgerId: long, entryId: long)</TD></TR>
<TR><TD ALIGN="LEFT" >+ sendSuccess(requestId: long)</TD></TR>
<TR><TD ALIGN="LEFT" >+ sendSuccessResponse(requestId: long)</TD></TR>
<TR><TD ALIGN="LEFT" >+ sendTcClientConnectResponse(requestId: long, error: ServerError, message: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ sendTcClientConnectResponse(requestId: long)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

PulsarDecoder1070348832[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)PulsarDecoder</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   cmd: BaseCommand [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   proxyMessage: HAProxyMessage [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ channelRead(ctx: ChannelHandlerContext, msg: Object)</TD></TR>
<TR><TD ALIGN="LEFT" >- getServerError(errorCode: int): ServerError</TD></TR>
<TR><TD ALIGN="LEFT" ># handleAck(ack: CommandAck)</TD></TR>
<TR><TD ALIGN="LEFT" ># handleAckResponse(ackResponse: CommandAckResponse)</TD></TR>
<TR><TD ALIGN="LEFT" ># handleActiveConsumerChange(change: CommandActiveConsumerChange)</TD></TR>
<TR><TD ALIGN="LEFT" ># handleAddPartitionToTxn(commandAddPartitionToTxn: CommandAddPartitionToTxn)</TD></TR>
<TR><TD ALIGN="LEFT" ># handleAddPartitionToTxnResponse(commandAddPartitionToTxnResponse: CommandAddPartitionToTxnResponse)</TD></TR>
<TR><TD ALIGN="LEFT" ># handleAddSubscriptionToTxn(commandAddSubscriptionToTxn: CommandAddSubscriptionToTxn)</TD></TR>
<TR><TD ALIGN="LEFT" ># handleAddSubscriptionToTxnResponse(commandAddSubscriptionToTxnResponse: CommandAddSubscriptionToTxnResponse)</TD></TR>
<TR><TD ALIGN="LEFT" ># handleAuthChallenge(commandAuthChallenge: CommandAuthChallenge)</TD></TR>
<TR><TD ALIGN="LEFT" ># handleAuthResponse(commandAuthResponse: CommandAuthResponse)</TD></TR>
<TR><TD ALIGN="LEFT" ># handleCloseConsumer(closeConsumer: CommandCloseConsumer)</TD></TR>
<TR><TD ALIGN="LEFT" ># handleCloseProducer(closeProducer: CommandCloseProducer)</TD></TR>
<TR><TD ALIGN="LEFT" ># handleConnect(connect: CommandConnect)</TD></TR>
<TR><TD ALIGN="LEFT" ># handleConnected(connected: CommandConnected)</TD></TR>
<TR><TD ALIGN="LEFT" ># handleConsumerStats(commandConsumerStats: CommandConsumerStats)</TD></TR>
<TR><TD ALIGN="LEFT" ># handleConsumerStatsResponse(commandConsumerStatsResponse: CommandConsumerStatsResponse)</TD></TR>
<TR><TD ALIGN="LEFT" ># handleEndTxn(commandEndTxn: CommandEndTxn)</TD></TR>
<TR><TD ALIGN="LEFT" ># handleEndTxnOnPartition(commandEndTxnOnPartition: CommandEndTxnOnPartition)</TD></TR>
<TR><TD ALIGN="LEFT" ># handleEndTxnOnPartitionResponse(commandEndTxnOnPartitionResponse: CommandEndTxnOnPartitionResponse)</TD></TR>
<TR><TD ALIGN="LEFT" ># handleEndTxnOnSubscription(commandEndTxnOnSubscription: CommandEndTxnOnSubscription)</TD></TR>
<TR><TD ALIGN="LEFT" ># handleEndTxnOnSubscriptionResponse(commandEndTxnOnSubscriptionResponse: CommandEndTxnOnSubscriptionResponse)</TD></TR>
<TR><TD ALIGN="LEFT" ># handleEndTxnResponse(commandEndTxnResponse: CommandEndTxnResponse)</TD></TR>
<TR><TD ALIGN="LEFT" ># handleError(error: CommandError)</TD></TR>
<TR><TD ALIGN="LEFT" ># handleFlow(flow: CommandFlow)</TD></TR>
<TR><TD ALIGN="LEFT" ># handleGetLastMessageId(getLastMessageId: CommandGetLastMessageId)</TD></TR>
<TR><TD ALIGN="LEFT" ># handleGetLastMessageIdSuccess(success: CommandGetLastMessageIdResponse)</TD></TR>
<TR><TD ALIGN="LEFT" ># handleGetOrCreateSchema(commandGetOrCreateSchema: CommandGetOrCreateSchema)</TD></TR>
<TR><TD ALIGN="LEFT" ># handleGetOrCreateSchemaResponse(commandGetOrCreateSchemaResponse: CommandGetOrCreateSchemaResponse)</TD></TR>
<TR><TD ALIGN="LEFT" ># handleGetSchema(commandGetSchema: CommandGetSchema)</TD></TR>
<TR><TD ALIGN="LEFT" ># handleGetSchemaResponse(commandGetSchemaResponse: CommandGetSchemaResponse)</TD></TR>
<TR><TD ALIGN="LEFT" ># handleGetTopicsOfNamespace(commandGetTopicsOfNamespace: CommandGetTopicsOfNamespace)</TD></TR>
<TR><TD ALIGN="LEFT" ># handleGetTopicsOfNamespaceSuccess(response: CommandGetTopicsOfNamespaceResponse)</TD></TR>
<TR><TD ALIGN="LEFT" ># handleLookup(lookup: CommandLookupTopic)</TD></TR>
<TR><TD ALIGN="LEFT" ># handleLookupResponse(connection: CommandLookupTopicResponse)</TD></TR>
<TR><TD ALIGN="LEFT" ># handleMessage(cmdMessage: CommandMessage, headersAndPayload: ByteBuf)</TD></TR>
<TR><TD ALIGN="LEFT" ># handleNewTxn(commandNewTxn: CommandNewTxn)</TD></TR>
<TR><TD ALIGN="LEFT" ># handleNewTxnResponse(commandNewTxnResponse: CommandNewTxnResponse)</TD></TR>
<TR><TD ALIGN="LEFT" ># handlePartitionMetadataRequest(response: CommandPartitionedTopicMetadata)</TD></TR>
<TR><TD ALIGN="LEFT" ># handlePartitionResponse(response: CommandPartitionedTopicMetadataResponse)</TD></TR>
<TR><TD ALIGN="LEFT" ># handlePing(ping: CommandPing)</TD></TR>
<TR><TD ALIGN="LEFT" ># handlePong(pong: CommandPong)</TD></TR>
<TR><TD ALIGN="LEFT" ># handleProducer(producer: CommandProducer)</TD></TR>
<TR><TD ALIGN="LEFT" ># handleProducerSuccess(success: CommandProducerSuccess)</TD></TR>
<TR><TD ALIGN="LEFT" ># handleReachedEndOfTopic(commandReachedEndOfTopic: CommandReachedEndOfTopic)</TD></TR>
<TR><TD ALIGN="LEFT" ># handleRedeliverUnacknowledged(redeliver: CommandRedeliverUnacknowledgedMessages)</TD></TR>
<TR><TD ALIGN="LEFT" ># handleSeek(seek: CommandSeek)</TD></TR>
<TR><TD ALIGN="LEFT" ># handleSend(send: CommandSend, headersAndPayload: ByteBuf)</TD></TR>
<TR><TD ALIGN="LEFT" ># handleSendError(sendError: CommandSendError)</TD></TR>
<TR><TD ALIGN="LEFT" ># handleSendReceipt(sendReceipt: CommandSendReceipt)</TD></TR>
<TR><TD ALIGN="LEFT" ># handleSubscribe(subscribe: CommandSubscribe)</TD></TR>
<TR><TD ALIGN="LEFT" ># handleSuccess(success: CommandSuccess)</TD></TR>
<TR><TD ALIGN="LEFT" ># handleTcClientConnectRequest(tcClientConnectRequest: CommandTcClientConnectRequest)</TD></TR>
<TR><TD ALIGN="LEFT" ># handleTcClientConnectResponse(tcClientConnectResponse: CommandTcClientConnectResponse)</TD></TR>
<TR><TD ALIGN="LEFT" ># handleUnsubscribe(unsubscribe: CommandUnsubscribe)</TD></TR>
<TR><TD ALIGN="LEFT" ># interceptCommand(command: BaseCommand)</TD></TR>
<TR><TD ALIGN="LEFT" ># messageReceived()</TD></TR>
<TR><TD ALIGN="LEFT" >- safeInterceptCommand(command: BaseCommand)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

PulsarEvent2082884193[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)PulsarEvent</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   actionType: ActionType [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   eventType: EventType [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   replicateTo: HashSet&lt;String&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   topicPoliciesEvent: TopicPoliciesEvent [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ builder(): PulsarEventBuilder</TD></TR>
<TR><TD ALIGN="LEFT" ># canEqual(other: Object): boolean</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

PulsarHandler1070348832[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)PulsarHandler</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   ctx: ChannelHandlerContext [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   keepAliveIntervalSeconds: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   keepAliveTask: ScheduledFuture&lt;?&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   remoteAddress: SocketAddress [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   remoteEndpointProtocolVersion: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   waitingForPingResponse: boolean [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ cancelKeepAliveTask()</TD></TR>
<TR><TD ALIGN="LEFT" >+ channelActive(ctx: ChannelHandlerContext)</TD></TR>
<TR><TD ALIGN="LEFT" >+ channelInactive(ctx: ChannelHandlerContext)</TD></TR>
<TR><TD ALIGN="LEFT" >- handleKeepAliveTimeout()</TD></TR>
<TR><TD ALIGN="LEFT" ># handlePing(ping: CommandPing)</TD></TR>
<TR><TD ALIGN="LEFT" ># handlePong(pong: CommandPong)</TD></TR>
<TR><TD ALIGN="LEFT" ># messageReceived()</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

PulsarOffsetBackingStore1955210581[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)PulsarOffsetBackingStore</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   client: PulsarClient [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   data: Map&lt;ByteBuffer, ByteBuffer&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   outstandingReadToEnd: CompletableFuture&lt;Void&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   producer: Producer&lt;byte[]&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   reader: Reader&lt;byte[]&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   topic: String [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- checkAndReadNext(endFuture: CompletableFuture&lt;Void&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ configure(workerConfig: WorkerConfig)</TD></TR>
<TR><TD ALIGN="LEFT" >+ get(keys: Collection&lt;ByteBuffer&gt;): Future&lt;Map&lt;ByteBuffer, ByteBuffer&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># processMessage(message: Message&lt;byte[]&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >- readNext(endFuture: CompletableFuture&lt;Void&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" ># readToEnd(future: CompletableFuture&lt;Void&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ set(values: Map&lt;ByteBuffer, ByteBuffer&gt;, callback: Callback&lt;Void&gt;): Future&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ start()</TD></TR>
<TR><TD ALIGN="LEFT" >+ stop()</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

PulsarRecord1430540343[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)PulsarRecord&lt;T&gt;</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   ackFunction: Runnable [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   failFunction: Runnable [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   message: Message&lt;T&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   partition: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   schema: Schema&lt;T&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   topicName: String [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ ack()</TD></TR>
<TR><TD ALIGN="LEFT" >+ builder(): PulsarRecordBuilder&lt;T&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># canEqual(other: Object): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ fail()</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

PulsarResourceDescription109292786[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)PulsarResourceDescription</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   resourceUsageByName: Map&lt;String, ResourceUsage&gt; [0..*]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ addUsage(rd: ResourceDescription)</TD></TR>
<TR><TD ALIGN="LEFT" >+ calculateRank(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ compareTo(o: ResourceDescription): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ put(resourceType: String, resourceUsage: ResourceUsage)</TD></TR>
<TR><TD ALIGN="LEFT" >+ removeUsage(rd: ResourceDescription)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

PulsarSaslServer978396142[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)PulsarSaslServer</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   allowedIdsPattern: Pattern [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   saslServer: SaslServer [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   serverSubject: Subject [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- createSaslServer(subject: Subject): SaslServer</TD></TR>
<TR><TD ALIGN="LEFT" >+ response(token: AuthData): AuthData</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

PulsarService724302956[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)PulsarService</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   adminClient: PulsarAdmin [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   advertisedAddress: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   advertisedListeners: Map&lt;String, AdvertisedListener&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   bindAddress: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   bkClientFactory: BookKeeperClientFactory [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   brokerAdditionalServlets: AdditionalServlets [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   brokerClientSharedExternalExecutorProvider: ExecutorProvider [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   brokerClientSharedInternalExecutorProvider: ExecutorProvider [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   brokerClientSharedTimer: Timer [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   brokerInterceptor: BrokerInterceptor [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   brokerService: BrokerService [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   brokerServiceUrl: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   brokerServiceUrlTls: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   brokerVersion: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   cacheExecutor: ScheduledExecutorService [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   client: PulsarClient [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   closeFuture: CompletableFuture&lt;Void&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   compactor: Compactor [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   compactorExecutor: ScheduledExecutorService [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   config: ServiceConfiguration [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   configurationMetadataStore: MetadataStore [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   coordinationService: CoordinationService [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   defaultOffloader: LedgerOffloader [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   executor: ScheduledExecutorService [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   functionWorkerService: Optional&lt;WorkerService&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   heartbeatNamespaceV2: NamespaceName [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   ioEventLoopGroup: EventLoopGroup [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   isClosedCondition: Condition [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   leaderElectionService: LeaderElectionService [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   ledgerOffloaderMap: Map&lt;NamespaceName, LedgerOffloader&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   loadManager: AtomicReference&lt;LoadManager&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   loadManagerExecutor: ScheduledExecutorService [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   loadReportTask: ScheduledFuture&lt;?&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   loadResourceQuotaTask: ScheduledFuture&lt;?&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   loadSheddingTask: ScheduledFuture&lt;?&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   localMetadataStore: MetadataStoreExtended [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   managedLedgerClientFactory: ManagedLedgerStorage [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   metricsGenerator: MetricsGenerator [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   metricsServlet: PrometheusMetricsServlet [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   mutex: ReentrantLock [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   nsService: NamespaceService [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   offloaderScheduler: OrderedScheduler [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   offloadersCache: OffloadersCache [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   orderedExecutor: OrderedExecutor [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   packagesManagement: Optional&lt;PackagesManagement&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   pendingMetricsProviders: List&lt;PrometheusRawMetricsProvider&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   processTerminator: Consumer&lt;Integer&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   protocolHandlers: ProtocolHandlers [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   pulsarResources: PulsarResources [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   resourceGroupServiceManager: ResourceGroupService [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   resourceUsageTransportManager: ResourceUsageTransportManager [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   schemaRegistryService: SchemaRegistryService [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   schemaStorage: SchemaStorage [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   shouldShutdownConfigurationMetadataStore: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   state: State [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   topicPoliciesService: TopicPoliciesService [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   transactionBufferClient: TransactionBufferClient [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   transactionBufferProvider: TransactionBufferProvider [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   transactionBufferSnapshotService: TransactionBufferSnapshotService [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   transactionExecutorProvider: ExecutorProvider [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   transactionMetadataStoreService: TransactionMetadataStoreService [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   transactionPendingAckStoreProvider: TransactionPendingAckStoreProvider [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   transactionTimer: HashedWheelTimer [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   webService: WebService [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   webServiceAddress: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   webServiceAddressTls: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   webSocketService: WebSocketService [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   workerConfig: WorkerConfig [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># acquireSLANamespace()</TD></TR>
<TR><TD ALIGN="LEFT" >- addBrokerAdditionalServlets(webService: WebService, attributeMap: Map&lt;String, Object&gt;, config: ServiceConfiguration)</TD></TR>
<TR><TD ALIGN="LEFT" >+ addPrometheusRawMetricsProvider(metricsProvider: PrometheusRawMetricsProvider)</TD></TR>
<TR><TD ALIGN="LEFT" >- addTimeoutHandling(future: CompletableFuture&lt;Void&gt;): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- addWebServerHandlers(webService: WebService, metricsServlet: PrometheusMetricsServlet, config: ServiceConfiguration)</TD></TR>
<TR><TD ALIGN="LEFT" >- addWebSocketServiceHandler(webService: WebService, attributeMap: Map&lt;String, Object&gt;, config: ServiceConfiguration)</TD></TR>
<TR><TD ALIGN="LEFT" ># brokerUrl(config: ServiceConfiguration): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ brokerUrl(host: String, port: int): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ brokerUrlTls(config: ServiceConfiguration): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ brokerUrlTls(host: String, port: int): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ closeAsync(): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># closeLocalMetadataStore()</TD></TR>
<TR><TD ALIGN="LEFT" >+ closeMetadataServiceSession()</TD></TR>
<TR><TD ALIGN="LEFT" >- createAndStartSchemaStorage(): SchemaStorage</TD></TR>
<TR><TD ALIGN="LEFT" >+ createClientImpl(clientConf: ClientConfigurationData): PulsarClientImpl</TD></TR>
<TR><TD ALIGN="LEFT" >+ createConfigurationMetadataStore(): MetadataStore</TD></TR>
<TR><TD ALIGN="LEFT" >+ createLocalMetadataStore(): MetadataStoreExtended</TD></TR>
<TR><TD ALIGN="LEFT" >+ createManagedLedgerOffloader(offloadPolicies: OffloadPoliciesImpl): LedgerOffloader</TD></TR>
<TR><TD ALIGN="LEFT" >+ getCompactor(shouldInitialize: boolean): Compactor</TD></TR>
<TR><TD ALIGN="LEFT" >+ getManagedLedgerOffloader(namespaceName: NamespaceName, offloadPolicies: OffloadPoliciesImpl): LedgerOffloader</TD></TR>
<TR><TD ALIGN="LEFT" ># getOffloaderScheduler(offloadPolicies: OffloadPoliciesImpl): OrderedScheduler</TD></TR>
<TR><TD ALIGN="LEFT" >- handleDeleteCluster(notification: Notification)</TD></TR>
<TR><TD ALIGN="LEFT" >- handleMetadataSessionEvent(e: SessionEvent)</TD></TR>
<TR><TD ALIGN="LEFT" >+ initializeWorkerConfigFromBrokerConfig(brokerConfig: ServiceConfiguration, workerConfigFile: String): WorkerConfig</TD></TR>
<TR><TD ALIGN="LEFT" >+ isTransactionInternalName(topicName: TopicName): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ isTransactionSystemTopic(topicName: TopicName): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ loadNamespaceTopics(bundle: NamespaceBundle)</TD></TR>
<TR><TD ALIGN="LEFT" >+ newBookKeeperClientFactory(): BookKeeperClientFactory</TD></TR>
<TR><TD ALIGN="LEFT" ># newBrokerService(pulsar: PulsarService): BrokerService</TD></TR>
<TR><TD ALIGN="LEFT" >+ newCompactor(): Compactor</TD></TR>
<TR><TD ALIGN="LEFT" >+ shutdownNow()</TD></TR>
<TR><TD ALIGN="LEFT" >+ start()</TD></TR>
<TR><TD ALIGN="LEFT" ># startLeaderElectionService()</TD></TR>
<TR><TD ALIGN="LEFT" ># startLoadManagementService()</TD></TR>
<TR><TD ALIGN="LEFT" ># startNamespaceService()</TD></TR>
<TR><TD ALIGN="LEFT" >- startPackagesManagementService()</TD></TR>
<TR><TD ALIGN="LEFT" >- startWorkerService(authenticationService: AuthenticationService, authorizationService: AuthorizationService)</TD></TR>
<TR><TD ALIGN="LEFT" >+ waitUntilClosed()</TD></TR>
<TR><TD ALIGN="LEFT" >+ webAddress(config: ServiceConfiguration): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ webAddress(host: String, port: int): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ webAddressTls(config: ServiceConfiguration): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ webAddressTls(host: String, port: int): String</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

PulsarServiceNameResolver12001400[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)PulsarServiceNameResolver</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   addressList: List&lt;InetSocketAddress&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   currentIndex: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   serviceUri: ServiceURI [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   serviceUrl: String [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- randomIndex(numAddresses: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ resolveHost(): InetSocketAddress</TD></TR>
<TR><TD ALIGN="LEFT" >+ resolveHostUri(): URI</TD></TR>
<TR><TD ALIGN="LEFT" >+ updateServiceUrl(serviceUrl: String)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

PulsarSqlSchemaInfoProvider1649508102[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)PulsarSqlSchemaInfoProvider</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   cache: LoadingCache&lt;BytesSchemaVersion, SchemaInfo&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   pulsarAdmin: PulsarAdmin [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   topicName: TopicName [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ defaultSchema(): SchemaInfo</TD></TR>
<TR><TD ALIGN="LEFT" >+ getSchemaByVersion(schemaVersion: byte[]): CompletableFuture&lt;SchemaInfo&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- loadSchema(bytesSchemaVersion: BytesSchemaVersion): SchemaInfo</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

PulsarStats1718290011[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)PulsarStats</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   brokerOperabilityMetrics: BrokerOperabilityMetrics [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   bufferLock: ReentrantReadWriteLock [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   bundleStats: Map&lt;String, NamespaceBundleStats&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   clusterReplicationMetrics: ClusterReplicationMetrics [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   exposePublisherStats: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   metricsCollection: List&lt;Metrics&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   nsStats: NamespaceStats [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   pulsarService: PulsarService [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   tempMetricsCollection: List&lt;Metrics&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   tempNonPersistentTopics: List&lt;NonPersistentTopic&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   tempTopicStatsBuf: ByteBuf [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   topicStatsBuf: ByteBuf [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ getDimensionMetrics(consumer: Consumer&lt;ByteBuf&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ invalidBundleStats(bundleName: String): NamespaceBundleStats</TD></TR>
<TR><TD ALIGN="LEFT" >+ recordConnectionClose()</TD></TR>
<TR><TD ALIGN="LEFT" >+ recordConnectionCreate()</TD></TR>
<TR><TD ALIGN="LEFT" >+ recordConnectionCreateFail()</TD></TR>
<TR><TD ALIGN="LEFT" >+ recordConnectionCreateSuccess()</TD></TR>
<TR><TD ALIGN="LEFT" >+ recordTopicLoadTimeValue(topic: String, topicLoadLatencyMs: long)</TD></TR>
<TR><TD ALIGN="LEFT" >+ updateStats(topicsMap: ConcurrentOpenHashMap&lt;String, ConcurrentOpenHashMap&lt;String, ConcurrentOpenHashMap&lt;String, Topic&gt;&gt;&gt;)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

PulsarWebResource2102840826[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)PulsarWebResource</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   httpRequest: HttpServletRequest [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   pulsar: PulsarService [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   servletContext: ServletContext [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   uri: UriInfo [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># bookieResources(): BookieResources</TD></TR>
<TR><TD ALIGN="LEFT" ># canUpdateCluster(tenant: String, oldClusters: Set&lt;String&gt;, newClusters: Set&lt;String&gt;): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># checkAuthorization(pulsarService: PulsarService, topicName: TopicName, role: String, authenticationData: AuthenticationDataSource)</TD></TR>
<TR><TD ALIGN="LEFT" >+ checkLocalOrGetPeerReplicationCluster(pulsarService: PulsarService, namespace: NamespaceName): CompletableFuture&lt;ClusterDataImpl&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ clientAppId(): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ clientAuthData(): AuthenticationDataHttps</TD></TR>
<TR><TD ALIGN="LEFT" ># clusterResources(): ClusterResources</TD></TR>
<TR><TD ALIGN="LEFT" ># config(): ServiceConfiguration</TD></TR>
<TR><TD ALIGN="LEFT" ># dynamicConfigurationResources(): DynamicConfigurationResources</TD></TR>
<TR><TD ALIGN="LEFT" ># getClusterDataIfDifferentCluster(pulsar: PulsarService, cluster: String, clientAppId: String): CompletableFuture&lt;ClusterData&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- getOwnerFromPeerClusterList(pulsar: PulsarService, replicationClusters: Set&lt;String&gt;): ClusterDataImpl</TD></TR>
<TR><TD ALIGN="LEFT" >- getRedirectionUrl(differentClusterData: ClusterData): URI</TD></TR>
<TR><TD ALIGN="LEFT" ># handleCommonRestAsyncException(asyncResponse: AsyncResponse, ex: Throwable): Void</TD></TR>
<TR><TD ALIGN="LEFT" ># hasActiveNamespace(tenant: String): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># isBundleOwnedByAnyBroker(fqnn: NamespaceName, bundles: BundlesData, bundleRange: String): CompletableFuture&lt;Boolean&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ isClientAuthenticated(appId: String): boolean</TD></TR>
<TR><TD ALIGN="LEFT" ># isLeaderBroker(pulsar: PulsarService): boolean</TD></TR>
<TR><TD ALIGN="LEFT" ># isValidCluster(pulsarService: PulsarService, cluster: String): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ jsonMapper(): ObjectMapper</TD></TR>
<TR><TD ALIGN="LEFT" ># namespaceIsolationPolicies(): IsolationPolicyResources</TD></TR>
<TR><TD ALIGN="LEFT" ># namespaceResources(): NamespaceResources</TD></TR>
<TR><TD ALIGN="LEFT" >+ originalPrincipal(): String</TD></TR>
<TR><TD ALIGN="LEFT" ># pulsar(): PulsarService</TD></TR>
<TR><TD ALIGN="LEFT" ># resourceGroupResources(): ResourceGroupResources</TD></TR>
<TR><TD ALIGN="LEFT" >+ splitPath(source: String, slice: int): String</TD></TR>
<TR><TD ALIGN="LEFT" ># tenantResources(): TenantResources</TD></TR>
<TR><TD ALIGN="LEFT" ># topicResources(): TopicResources</TD></TR>
<TR><TD ALIGN="LEFT" ># validateAdminAccessForTenant(tenant: String)</TD></TR>
<TR><TD ALIGN="LEFT" ># validateAdminAccessForTenant(pulsar: PulsarService, clientAppId: String, originalPrincipal: String, tenant: String, authenticationData: AuthenticationDataSource)</TD></TR>
<TR><TD ALIGN="LEFT" ># validateBrokerName(broker: String)</TD></TR>
<TR><TD ALIGN="LEFT" ># validateBundleOwnership(tenant: String, cluster: String, namespace: String, authoritative: boolean, readOnly: boolean, bundle: NamespaceBundle)</TD></TR>
<TR><TD ALIGN="LEFT" >+ validateBundleOwnership(bundle: NamespaceBundle, authoritative: boolean, readOnly: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" ># validateClusterExists(cluster: String)</TD></TR>
<TR><TD ALIGN="LEFT" ># validateClusterForTenant(tenant: String, cluster: String)</TD></TR>
<TR><TD ALIGN="LEFT" ># validateClusterOwnership(cluster: String)</TD></TR>
<TR><TD ALIGN="LEFT" ># validateClusterOwnershipAsync(cluster: String): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># validateGlobalNamespaceOwnership(namespace: NamespaceName)</TD></TR>
<TR><TD ALIGN="LEFT" ># validateGlobalNamespaceOwnershipAsync(namespace: NamespaceName): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># validateNamespaceBundleOwnership(fqnn: NamespaceName, bundles: BundlesData, bundleRange: String, authoritative: boolean, readOnly: boolean): NamespaceBundle</TD></TR>
<TR><TD ALIGN="LEFT" ># validateNamespaceBundleRange(fqnn: NamespaceName, bundles: BundlesData, bundleRange: String): NamespaceBundle</TD></TR>
<TR><TD ALIGN="LEFT" >+ validateNamespaceOperation(namespaceName: NamespaceName, operation: NamespaceOperation)</TD></TR>
<TR><TD ALIGN="LEFT" >+ validateNamespaceOperationAsync(namespaceName: NamespaceName, operation: NamespaceOperation): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ validateNamespacePolicyOperation(namespaceName: NamespaceName, policy: PolicyName, operation: PolicyOperation)</TD></TR>
<TR><TD ALIGN="LEFT" >+ validateNamespacePolicyOperationAsync(namespaceName: NamespaceName, policy: PolicyName, operation: PolicyOperation): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- validateOriginalPrincipal(proxyRoles: Set&lt;String&gt;, authenticatedPrincipal: String, originalPrincipal: String)</TD></TR>
<TR><TD ALIGN="LEFT" ># validatePeerClusterConflict(clusterName: String, replicationClusters: Set&lt;String&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ validatePoliciesReadOnlyAccess()</TD></TR>
<TR><TD ALIGN="LEFT" >+ validateSuperUserAccess()</TD></TR>
<TR><TD ALIGN="LEFT" >+ validateSuperUserAccessAsync(): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ validateTenantOperation(tenant: String, operation: TenantOperation)</TD></TR>
<TR><TD ALIGN="LEFT" >+ validateTenantOperationAsync(tenant: String, operation: TenantOperation): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ validateTopicOperation(topicName: TopicName, operation: TopicOperation)</TD></TR>
<TR><TD ALIGN="LEFT" >+ validateTopicOperation(topicName: TopicName, operation: TopicOperation, subscription: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ validateTopicOperationAsync(topicName: TopicName, operation: TopicOperation): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ validateTopicOperationAsync(topicName: TopicName, operation: TopicOperation, subscription: String): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># validateTopicOwnership(topicName: TopicName, authoritative: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" ># validateTopicOwnershipAsync(topicName: TopicName, authoritative: boolean): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ validateTopicPolicyOperation(topicName: TopicName, policy: PolicyName, operation: PolicyOperation)</TD></TR>
<TR><TD ALIGN="LEFT" >+ validateTopicPolicyOperationAsync(topicName: TopicName, policy: PolicyName, operation: PolicyOperation): CompletableFuture&lt;Void&gt;</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

PulsarWorkerService1316119764[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)PulsarWorkerService</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   authenticationService: AuthenticationService [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   authorizationService: AuthorizationService [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   brokerAdmin: PulsarAdmin [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   client: PulsarClient [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   clientCreator: PulsarClientCreator [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   clusterServiceCoordinator: ClusterServiceCoordinator [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   connectorsManager: ConnectorsManager [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   dlogNamespace: Namespace [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   dlogUri: URI [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   functionAdmin: PulsarAdmin [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   functionAssignmentTailer: FunctionAssignmentTailer [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   functionMetaDataManager: FunctionMetaDataManager [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   functionRuntimeManager: FunctionRuntimeManager [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   functions: Functions&lt;PulsarWorkerService&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   functionsManager: FunctionsManager [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   functionsV2: FunctionsV2&lt;PulsarWorkerService&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   isInitialized: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   leaderService: LeaderService [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   membershipManager: MembershipManager [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   metricsGenerator: MetricsGenerator [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   schedulerManager: SchedulerManager [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   sinks: Sinks&lt;PulsarWorkerService&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   sources: Sources&lt;PulsarWorkerService&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   stateStoreAdminClient: StorageAdminClient [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   statsUpdater: ScheduledExecutorService [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   workerConfig: WorkerConfig [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   workerStatsManager: WorkerStatsManager [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   workers: Workers&lt;PulsarWorkerService&gt; [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- createFunctionsNamespacePolicies(pulsarFunctionsCluster: String): Policies</TD></TR>
<TR><TD ALIGN="LEFT" >+ generateFunctionsStats(out: SimpleTextOutputStream)</TD></TR>
<TR><TD ALIGN="LEFT" >+ init(workerConfig: WorkerConfig, dlogUri: URI, runAsStandalone: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ initAsStandalone(workerConfig: WorkerConfig)</TD></TR>
<TR><TD ALIGN="LEFT" >+ initInBroker(brokerConfig: ServiceConfiguration, workerConfig: WorkerConfig, pulsarResources: PulsarResources, internalConf: InternalConfigurationData)</TD></TR>
<TR><TD ALIGN="LEFT" >- initializeStandaloneWorkerService(clientCreator: PulsarClientCreator, workerConfig: WorkerConfig): URI</TD></TR>
<TR><TD ALIGN="LEFT" >+ start(authenticationService: AuthenticationService, authorizationService: AuthorizationService, errorNotifier: ErrorNotifier)</TD></TR>
<TR><TD ALIGN="LEFT" >+ stop()</TD></TR>
<TR><TD ALIGN="LEFT" >- tryCreateNonPartitionedTopic(topic: String)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

Rate1188434519[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)Rate</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   averageValue: double [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   count: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   countAdder: LongAdder [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   lastCalculatedTime: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   rate: double [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   totalCountAdder: LongAdder [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   valueAdder: LongAdder [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   valueRate: double [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ calculateRate()</TD></TR>
<TR><TD ALIGN="LEFT" >+ calculateRate(period: double)</TD></TR>
<TR><TD ALIGN="LEFT" >+ recordEvent()</TD></TR>
<TR><TD ALIGN="LEFT" >+ recordEvent(value: long)</TD></TR>
<TR><TD ALIGN="LEFT" >+ recordMultipleEvents(events: long, totalValue: long)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

RateLimiter1762718902[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)RateLimiter</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   acquiredPermits: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   executorService: ScheduledExecutorService [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   externalExecutor: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   isClosed: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   isDispatchOrPrecisePublishRateLimiter: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   permitUpdater: Supplier&lt;Long&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   permits: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   rateLimitFunction: RateLimitFunction [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   rateTime: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   renewTask: ScheduledFuture&lt;?&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   timeUnit: TimeUnit [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ acquire()</TD></TR>
<TR><TD ALIGN="LEFT" >+ acquire(acquirePermit: long)</TD></TR>
<TR><TD ALIGN="LEFT" >+ builder(): RateLimiterBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" ># createTask(): ScheduledFuture&lt;?&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># renew()</TD></TR>
<TR><TD ALIGN="LEFT" >+ tryAcquire(): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ tryAcquire(acquirePermit: long): boolean</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

RateLimiterBuilder1999122404[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)RateLimiterBuilder</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   isDispatchOrPrecisePublishRateLimiter: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   permitUpdater: Supplier&lt;Long&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   permits: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   rateLimitFunction: RateLimitFunction [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   rateTime: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   scheduledExecutorService: ScheduledExecutorService [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   timeUnit: TimeUnit [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ build(): RateLimiter</TD></TR>
<TR><TD ALIGN="LEFT" >+ isDispatchOrPrecisePublishRateLimiter(isDispatchOrPrecisePublishRateLimiter: boolean): RateLimiterBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ permitUpdater(permitUpdater: Supplier&lt;Long&gt;): RateLimiterBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ permits(permits: long): RateLimiterBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ rateLimitFunction(rateLimitFunction: RateLimitFunction): RateLimiterBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ rateTime(rateTime: long): RateLimiterBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ scheduledExecutorService(scheduledExecutorService: ScheduledExecutorService): RateLimiterBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ timeUnit(timeUnit: TimeUnit): RateLimiterBuilder</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

RawConsumerImpl325194693[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)RawConsumerImpl</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   incomingRawMessages: BlockingQueue&lt;RawMessageAndCnx&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >#   pendingRawReceives: Queue&lt;CompletableFuture&lt;RawMessage&gt;&gt; [0..*]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ closeAsync(): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># messageReceived(commandMessage: CommandMessage, headersAndPayload: ByteBuf, cnx: ClientCnx)</TD></TR>
<TR><TD ALIGN="LEFT" ># receiveRawAsync(): CompletableFuture&lt;RawMessage&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- reset()</TD></TR>
<TR><TD ALIGN="LEFT" >+ seekAsync(timestamp: long): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ seekAsync(messageId: MessageId): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># tryCompletePending()</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

RawMessageAndCnx325194693[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)RawMessageAndCnx</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   cnx: ClientCnx [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   msg: RawMessage [0..1]</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

RawReaderImpl12001400[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)RawReaderImpl</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   consumer: RawConsumerImpl [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   consumerConfiguration: ConsumerConfigurationData&lt;byte[]&gt; [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ acknowledgeCumulativeAsync(messageId: MessageId, properties: Map&lt;String, Long&gt;): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ closeAsync(): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ readNextAsync(): CompletableFuture&lt;RawMessage&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ seekAsync(messageId: MessageId): CompletableFuture&lt;Void&gt;</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

ReadEntries672467156[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)ReadEntries</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   isDone: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   outstandingReadsRequests: AtomicLong [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ readEntriesComplete(entries: List&lt;Entry&gt;, ctx: Object)</TD></TR>
<TR><TD ALIGN="LEFT" >+ readEntriesFailed(exception: ManagedLedgerException, ctx: Object)</TD></TR>
<TR><TD ALIGN="LEFT" >+ run()</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

ReaderHandler1308078636[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)ReaderHandler</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   maxPendingMessages: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   msgDeliveredCounter: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   numBytesDelivered: LongAdder [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   numMsgsDelivered: LongAdder [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   pendingMessages: AtomicInteger [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   reader: Reader&lt;byte[]&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   subscription: String [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >- handleEndOfTopic()</TD></TR>
<TR><TD ALIGN="LEFT" ># isAuthorized(authRole: String, authenticationData: AuthenticationDataSource): Boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ onWebSocketConnect(session: Session)</TD></TR>
<TR><TD ALIGN="LEFT" >+ onWebSocketText(message: String)</TD></TR>
<TR><TD ALIGN="LEFT" >- receiveMessage()</TD></TR>
<TR><TD ALIGN="LEFT" ># updateDeliverMsgStat(msgSize: long)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

ReaderImpl12001400[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)ReaderImpl&lt;T&gt;</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   consumer: ConsumerImpl&lt;T&gt; [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ closeAsync(): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ readNext(): Message&lt;T&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ readNext(timeout: int, unit: TimeUnit): Message&lt;T&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ readNextAsync(): CompletableFuture&lt;Message&lt;T&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ seek(messageId: MessageId)</TD></TR>
<TR><TD ALIGN="LEFT" >+ seek(timestamp: long)</TD></TR>
<TR><TD ALIGN="LEFT" >+ seek(function: Function&lt;String, Object&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ seekAsync(function: Function&lt;String, Object&gt;): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ seekAsync(messageId: MessageId): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ seekAsync(timestamp: long): CompletableFuture&lt;Void&gt;</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

ReaderV1Impl1051373919[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)ReaderV1Impl</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   reader: Reader&lt;byte[]&gt; [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ closeAsync(): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ readNext(): Message&lt;byte[]&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ readNext(arg0: int, arg1: TimeUnit): Message&lt;byte[]&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ readNextAsync(): CompletableFuture&lt;Message&lt;byte[]&gt;&gt;</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

RedeliveryTrackerDisabled1718290011[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)RedeliveryTrackerDisabled</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ addIfAbsent(position: Position)</TD></TR>
<TR><TD ALIGN="LEFT" >+ clear()</TD></TR>
<TR><TD ALIGN="LEFT" >+ contains(position: Position): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ getRedeliveryCount(position: Position): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ incrementAndGetRedeliveryCount(position: Position): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ remove(position: Position)</TD></TR>
<TR><TD ALIGN="LEFT" >+ removeBatch(positions: List&lt;Position&gt;)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

ReflectionUtils212457750[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)ReflectionUtils</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># catchExceptions(s: SupplierWithException&lt;T&gt;): T</TD></TR>
<TR><TD ALIGN="LEFT" ># getConstructor(className: String, argTypes: Class&lt;?&gt;...): Constructor&lt;T&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># getStaticMethod(className: String, method: String, argTypes: Class&lt;?&gt;...): Method</TD></TR>
<TR><TD ALIGN="LEFT" >+ newBuilder(className: String): T</TD></TR>
<TR><TD ALIGN="LEFT" ># newClassInstance(className: String): Class&lt;T&gt;</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

ReplicatedSubscriptionSnapshotCache1101090806[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)ReplicatedSubscriptionSnapshotCache</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   maxSnapshotToCache: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   snapshots: NavigableMap&lt;PositionImpl, ReplicatedSubscriptionsSnapshot&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   subscription: String [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ addNewSnapshot(snapshot: ReplicatedSubscriptionsSnapshot)</TD></TR>
<TR><TD ALIGN="LEFT" >+ advancedMarkDeletePosition(pos: PositionImpl): ReplicatedSubscriptionsSnapshot</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

ReplicatedSubscriptionsController1101090806[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)ReplicatedSubscriptionsController</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   lastCompletedSnapshotId: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   lastCompletedSnapshotStartTime: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   localCluster: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   pendingSnapshots: ConcurrentMap&lt;String, ReplicatedSubscriptionsSnapshotBuilder&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   positionOfLastLocalMarker: Position [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   timer: ScheduledFuture&lt;?&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   topic: PersistentTopic [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- cleanupTimedOutSnapshots()</TD></TR>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ completed(e: Exception, ledgerId: long, entryId: long)</TD></TR>
<TR><TD ALIGN="LEFT" ># localCluster(): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ localSubscriptionUpdated(subscriptionName: String, snapshot: ReplicatedSubscriptionsSnapshot)</TD></TR>
<TR><TD ALIGN="LEFT" >- receiveSubscriptionUpdated(update: ReplicatedSubscriptionsUpdate)</TD></TR>
<TR><TD ALIGN="LEFT" >+ receivedReplicatedSubscriptionMarker(position: Position, markerType: int, payload: ByteBuf)</TD></TR>
<TR><TD ALIGN="LEFT" >- receivedSnapshotRequest(request: ReplicatedSubscriptionsSnapshotRequest)</TD></TR>
<TR><TD ALIGN="LEFT" >- receivedSnapshotResponse(position: Position, response: ReplicatedSubscriptionsSnapshotResponse)</TD></TR>
<TR><TD ALIGN="LEFT" ># snapshotCompleted(snapshotId: String)</TD></TR>
<TR><TD ALIGN="LEFT" >- startNewSnapshot()</TD></TR>
<TR><TD ALIGN="LEFT" ># topic(): PersistentTopic</TD></TR>
<TR><TD ALIGN="LEFT" ># writeMarker(marker: ByteBuf)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

ReplicatedSubscriptionsSnapshot297559756[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)ReplicatedSubscriptionsSnapshot</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   _bitField0: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _cachedSize: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _clustersCount: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _parsedBuffer: ByteBuf [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _snapshotIdBufferIdx: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _snapshotIdBufferLen: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   clusters: List&lt;ClusterMessageId&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   localMessageId: MarkersMessageIdData [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   snapshotId: String [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ addAllClusters(clusters: Iterable&lt;ClusterMessageId&gt;): ReplicatedSubscriptionsSnapshot</TD></TR>
<TR><TD ALIGN="LEFT" >+ addCluster(): ClusterMessageId</TD></TR>
<TR><TD ALIGN="LEFT" >- checkRequiredFields()</TD></TR>
<TR><TD ALIGN="LEFT" >+ clear(): ReplicatedSubscriptionsSnapshot</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearClusters(): ReplicatedSubscriptionsSnapshot</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearLocalMessageId(): ReplicatedSubscriptionsSnapshot</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearSnapshotId(): ReplicatedSubscriptionsSnapshot</TD></TR>
<TR><TD ALIGN="LEFT" >+ copyFrom(_other: ReplicatedSubscriptionsSnapshot): ReplicatedSubscriptionsSnapshot</TD></TR>
<TR><TD ALIGN="LEFT" >+ getClusterAt(idx: int): ClusterMessageId</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(_buffer: ByteBuf, _size: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(a: byte[])</TD></TR>
<TR><TD ALIGN="LEFT" >+ setLocalMessageId(): MarkersMessageIdData</TD></TR>
<TR><TD ALIGN="LEFT" >+ setSnapshotId(snapshotId: String): ReplicatedSubscriptionsSnapshot</TD></TR>
<TR><TD ALIGN="LEFT" >+ toByteArray(): byte[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeTo(_b: ByteBuf): int</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

ReplicatedSubscriptionsSnapshotBuilder1101090806[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)ReplicatedSubscriptionsSnapshotBuilder</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   clock: Clock [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   controller: ReplicatedSubscriptionsController [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   firstRoundComplete: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   missingClusters: Set&lt;String&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   needTwoRounds: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   remoteClusters: List&lt;String&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   responses: Map&lt;String, MarkersMessageIdData&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   snapshotId: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   startTimeMillis: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   timeoutMillis: long [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># receivedSnapshotResponse(position: Position, response: ReplicatedSubscriptionsSnapshotResponse)</TD></TR>
<TR><TD ALIGN="LEFT" ># start()</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

ReplicationMetrics2102807099[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)ReplicationMetrics</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+   connected: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   maxMsgReplDelayInSeconds: double [1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   msgRateOut: double [1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   msgReplBacklog: double [1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   msgThroughputOut: double [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   recyclerHandle: Handle&lt;ReplicationMetrics&gt; [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ add(namespace: String, local: String, remote: String): Metrics</TD></TR>
<TR><TD ALIGN="LEFT" >+ recycle()</TD></TR>
<TR><TD ALIGN="LEFT" >+ reset()</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

ReplicatorStatsImpl2018762865[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)ReplicatorStatsImpl</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+   connected: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   inboundConnectedSince: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   inboundConnection: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   msgRateExpired: double [1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   msgRateIn: double [1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   msgRateOut: double [1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   msgThroughputIn: double [1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   msgThroughputOut: double [1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   outboundConnectedSince: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   outboundConnection: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   replicationBacklog: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   replicationDelayInSeconds: long [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ add(stats: ReplicatorStatsImpl): ReplicatorStatsImpl</TD></TR>
<TR><TD ALIGN="LEFT" ># canEqual(other: Object): boolean</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

ResourceGroupPublishLimiter664401495[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)ResourceGroupPublishLimiter</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   publishMaxByteRate: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   publishMaxMessageRate: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   publishRateLimiterOnByte: RateLimiter [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   publishRateLimiterOnMessage: RateLimiter [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   publishThrottlingEnabled: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   rateLimitFunctionMap: ConcurrentHashMap&lt;String, RateLimitFunction&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   scheduledExecutorService: ScheduledExecutorService [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ apply()</TD></TR>
<TR><TD ALIGN="LEFT" >+ checkPublishRate()</TD></TR>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ incrementPublishCount(numOfMessages: int, msgSizeInBytes: long)</TD></TR>
<TR><TD ALIGN="LEFT" >+ registerRateLimitFunction(name: String, func: RateLimitFunction)</TD></TR>
<TR><TD ALIGN="LEFT" >- replaceLimiters(updater: Runnable)</TD></TR>
<TR><TD ALIGN="LEFT" >+ resetPublishCount(): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ tryAcquire(numbers: int, bytes: long): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ unregisterRateLimitFunction(name: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ update(policies: Policies, clusterName: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ update(maxPublishRate: PublishRate)</TD></TR>
<TR><TD ALIGN="LEFT" >+ update(maxPublishRate: BytesAndMessagesCount)</TD></TR>
<TR><TD ALIGN="LEFT" >+ update(resourceGroup: ResourceGroup)</TD></TR>
<TR><TD ALIGN="LEFT" >+ update(publishRateInMsgs: long, publishRateInBytes: long)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

ResourceGroupsBase229910521[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)ResourceGroupsBase</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># internalCheckRgInUse(rgName: String): boolean</TD></TR>
<TR><TD ALIGN="LEFT" ># internalCreateOrUpdateResourceGroup(rgName: String, rgConfig: ResourceGroup)</TD></TR>
<TR><TD ALIGN="LEFT" ># internalCreateResourceGroup(rgName: String, rgConfig: ResourceGroup)</TD></TR>
<TR><TD ALIGN="LEFT" ># internalDeleteResourceGroup(rgName: String)</TD></TR>
<TR><TD ALIGN="LEFT" ># internalGetResourceGroup(rgName: String): ResourceGroup</TD></TR>
<TR><TD ALIGN="LEFT" ># internalGetResourceGroups(): List&lt;String&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># internalUpdateResourceGroup(rgName: String, rgConfig: ResourceGroup)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

ResourceLockImpl1394915087[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)ResourceLockImpl&lt;T&gt;</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   expiredFuture: CompletableFuture&lt;Void&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   path: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   revalidateAfterReconnection: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   revalidateFuture: CompletableFuture&lt;Void&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   serde: MetadataSerde&lt;T&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   state: State [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   store: MetadataStoreExtended [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   value: T [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   version: long [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># acquire(newValue: T): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- acquireWithNoRevalidation(newValue: T): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- doRevalidate(newValue: T): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># lockWasInvalidated()</TD></TR>
<TR><TD ALIGN="LEFT" >+ release(): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># revalidate(newValue: T): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># revalidateIfNeededAfterReconnection(): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ updateValue(newValue: T): CompletableFuture&lt;Void&gt;</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

ResourceQuota896442176[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)ResourceQuota</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   bandwidthIn: double [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   bandwidthOut: double [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   dynamic: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   memory: double [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   msgRateIn: double [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   msgRateOut: double [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ add(quota: ResourceQuota)</TD></TR>
<TR><TD ALIGN="LEFT" ># canEqual(other: Object): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ substract(quota: ResourceQuota)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

ResourceUnitRanking842356003[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)ResourceUnitRanking</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   allocatedLoadPercentageBandwidthIn: double [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   allocatedLoadPercentageBandwidthOut: double [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   allocatedLoadPercentageCPU: double [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   allocatedLoadPercentageMemory: double [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   allocatedQuota: ResourceQuota [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   estimatedLoadPercentage: double [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   estimatedLoadPercentageBandwidthIn: double [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   estimatedLoadPercentageBandwidthOut: double [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   estimatedLoadPercentageCPU: double [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   estimatedLoadPercentageDirectMemory: double [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   estimatedLoadPercentageMemory: double [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   estimatedMessageRate: double [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   loadedBundles: Set&lt;String&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   preAllocatedBundles: Set&lt;String&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   preAllocatedQuota: ResourceQuota [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   systemResourceUsage: SystemResourceUsage [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ addPreAllocatedServiceUnit(suName: String, quota: ResourceQuota)</TD></TR>
<TR><TD ALIGN="LEFT" >- calculateBrokerCapacity(defaultQuota: ResourceQuota, usableCPU: double, usableMem: double, usableBandwidthOut: double, usableBandwidthIn: double): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ calculateBrokerMaxCapacity(systemResourceUsage: SystemResourceUsage, defaultQuota: ResourceQuota): long</TD></TR>
<TR><TD ALIGN="LEFT" ># canEqual(other: Object): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ compareMessageRateTo(other: ResourceUnitRanking): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ compareTo(other: ResourceUnitRanking): int</TD></TR>
<TR><TD ALIGN="LEFT" >- estimateLoadPercentage()</TD></TR>
<TR><TD ALIGN="LEFT" >+ estimateMaxCapacity(defaultQuota: ResourceQuota): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ isServiceUnitLoaded(suName: String): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ isServiceUnitPreAllocated(suName: String): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ removeLoadedServiceUnit(suName: String, quota: ResourceQuota)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

ResourceUsage842356003[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)ResourceUsage</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+   limit: double [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   percentUsage: float [1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   usage: double [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># canEqual(other: Object): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ compareTo(o: ResourceUsage): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ percentUsage(): float</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

ResourceUsageReader498281929[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)ResourceUsageReader</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   consumer: Reader&lt;byte[]&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   recdUsageInfo: ResourceUsageInfo [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ received(reader: Reader&lt;byte[]&gt;, msg: Message&lt;byte[]&gt;)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

RestMessagePublishContext763407854[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)RestMessagePublishContext</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   positionFuture: CompletableFuture&lt;PositionImpl&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   recyclerHandle: Handle&lt;RestMessagePublishContext&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   startTimeNs: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   topic: Topic [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ completed(exception: Exception, ledgerId: long, entryId: long)</TD></TR>
<TR><TD ALIGN="LEFT" >+ get(positionFuture: CompletableFuture&lt;PositionImpl&gt;, topic: Topic, startTimeNs: long): RestMessagePublishContext</TD></TR>
<TR><TD ALIGN="LEFT" >+ recycle()</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

RetryUtil11637398[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)RetryUtil</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- executeWithRetry(supplier: Supplier&lt;CompletableFuture&lt;T&gt;&gt;, backoff: Backoff, scheduledExecutorService: ScheduledExecutorService, callback: CompletableFuture&lt;T&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ retryAsynchronously(supplier: Supplier&lt;CompletableFuture&lt;T&gt;&gt;, backoff: Backoff, scheduledExecutorService: ScheduledExecutorService, callback: CompletableFuture&lt;T&gt;)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

Runnables1762718902[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)Runnables</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ catchingAndLoggingThrowables(runnable: Runnable): Runnable</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

SaslAuthenticationDataProvider1053578162[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)SaslAuthenticationDataProvider</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   pulsarSaslClient: PulsarSaslClient [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ authenticate(commandData: AuthData): AuthData</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

SaslAuthenticationDataSource978396142[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)SaslAuthenticationDataSource</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   pulsarSaslServer: PulsarSaslServer [0..1]</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

SaslAuthenticationState978396142[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)SaslAuthenticationState</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   authenticationDataSource: SaslAuthenticationDataSource [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   pulsarSaslServer: PulsarSaslServer [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   stateId: long [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ authenticate(authData: AuthData): AuthData</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

SchedulerManager1316119764[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)SchedulerManager</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   admin: PulsarAdmin [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   assignmentsMovedInLastDrain: List&lt;Assignment&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   currentDrainFuture: Future&lt;?&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   currentRebalanceFuture: Future&lt;?&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   drainInProgressFlag: AtomicBoolean [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   drainOpStatusMap: ConcurrentHashMap&lt;String, DrainOpStatus&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   errorNotifier: ErrorNotifier [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   exclusiveProducer: Producer&lt;byte[]&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   executorService: ThreadPoolExecutor [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   functionMetaDataManager: FunctionMetaDataManager [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   functionRuntimeManager: FunctionRuntimeManager [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   isCompactionNeeded: AtomicBoolean [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   isRunning: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   lastMessageProduced: MessageId [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   leaderService: LeaderService [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   membershipManager: MembershipManager [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   metadataTopicLastMessage: MessageId [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   pulsarClient: PulsarClient [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   rebalanceInProgress: AtomicBoolean [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   scheduledExecutorService: ScheduledExecutorService [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   scheduler: IScheduler [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   schedulerLock: Lock [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   workerConfig: WorkerConfig [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   workerStatsManager: WorkerStatsManager [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ acquireExclusiveWrite(isLeader: Supplier&lt;Boolean&gt;): Producer&lt;byte[]&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># checkHeartBeatFunction(funInstance: Instance): String</TD></TR>
<TR><TD ALIGN="LEFT" ># clearAssignmentsMovedInLastDrain()</TD></TR>
<TR><TD ALIGN="LEFT" ># clearDrainOpsStatus()</TD></TR>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >- compactAssignmentTopic()</TD></TR>
<TR><TD ALIGN="LEFT" >- compactFunctionMetadataTopic()</TD></TR>
<TR><TD ALIGN="LEFT" >- computeAllInstances(allFunctions: List&lt;FunctionMetaData&gt;, externallyManagedRuntime: boolean): Map&lt;String, Instance&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># computeInstances(functionMetaData: FunctionMetaData, externallyManagedRuntime: boolean): List&lt;Instance&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- drain(workerId: String): Future&lt;?&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ drainIfNotInProgress(workerId: String): Future&lt;?&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getDrainStatus(workerId: String): LongRunningProcessStatus</TD></TR>
<TR><TD ALIGN="LEFT" >- getUnassignedFunctionInstances(currentAssignments: Map&lt;String, Map&lt;String, Assignment&gt;&gt;, functionInstances: Map&lt;String, Instance&gt;): Pair&lt;List&lt;Instance&gt;, List&lt;Assignment&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ initialize(exclusiveProducer: Producer&lt;byte[]&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" ># invokeDrain(workerId: String): List&lt;Assignment&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- invokeRebalance()</TD></TR>
<TR><TD ALIGN="LEFT" ># invokeScheduler()</TD></TR>
<TR><TD ALIGN="LEFT" >- publishNewAssignment(assignment: Assignment, deleted: boolean): MessageId</TD></TR>
<TR><TD ALIGN="LEFT" >- rebalance(): Future&lt;?&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ rebalanceIfNotInprogress(): Future&lt;?&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ schedule(): Future&lt;?&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- scheduleCompaction(executor: ScheduledExecutorService, scheduleFrequencySec: long)</TD></TR>
<TR><TD ALIGN="LEFT" >- scheduleInternal(runnable: Runnable, errMsg: String): Future&lt;?&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># updateWorkerDrainMap(): int</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

Schema297559756[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)Schema</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   _bitField0: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _cachedSize: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _nameBufferIdx: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _nameBufferLen: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _parsedBuffer: ByteBuf [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _propertiesCount: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _schemaDataIdx: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _schemaDataLen: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   name: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   properties: List&lt;KeyValue&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   schemaData: ByteBuf [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   type: Type [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ addAllProperties(properties: Iterable&lt;KeyValue&gt;): Schema</TD></TR>
<TR><TD ALIGN="LEFT" >+ addProperty(): KeyValue</TD></TR>
<TR><TD ALIGN="LEFT" >- checkRequiredFields()</TD></TR>
<TR><TD ALIGN="LEFT" >+ clear(): Schema</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearName(): Schema</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearProperties(): Schema</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearSchemaData(): Schema</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearType(): Schema</TD></TR>
<TR><TD ALIGN="LEFT" >+ copyFrom(_other: Schema): Schema</TD></TR>
<TR><TD ALIGN="LEFT" >+ getPropertyAt(idx: int): KeyValue</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(_buffer: ByteBuf, _size: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(a: byte[])</TD></TR>
<TR><TD ALIGN="LEFT" >+ setName(name: String): Schema</TD></TR>
<TR><TD ALIGN="LEFT" >+ setSchemaData(schemaData: byte[]): Schema</TD></TR>
<TR><TD ALIGN="LEFT" >+ setSchemaData(schemaData: ByteBuf): Schema</TD></TR>
<TR><TD ALIGN="LEFT" >+ setType(type: Type): Schema</TD></TR>
<TR><TD ALIGN="LEFT" >+ toByteArray(): byte[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeTo(_b: ByteBuf): int</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

SchemaData1472480913[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)SchemaData</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   data: byte[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   isDeleted: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   props: Map&lt;String, String&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   timestamp: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   type: SchemaType [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   user: String [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- $default$props(): Map&lt;String, String&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ builder(): SchemaDataBuilder</TD></TR>
<TR><TD ALIGN="LEFT" ># canEqual(other: Object): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ fromSchemaInfo(schemaInfo: SchemaInfo): SchemaData</TD></TR>
<TR><TD ALIGN="LEFT" >+ toSchemaInfo(): SchemaInfo</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

SchemaDefinitionBuilderImpl1622012615[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)SchemaDefinitionBuilderImpl&lt;T&gt;</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   alwaysAllowNull: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   clazz: Class&lt;T&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   jsonDef: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   jsr310ConversionEnabled: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   properties: Map&lt;String, String&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   reader: SchemaReader&lt;T&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   supportSchemaVersioning: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   writer: SchemaWriter&lt;T&gt; [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ addProperty(key: String, value: String): SchemaDefinitionBuilder&lt;T&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ build(): SchemaDefinition&lt;T&gt;</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

SchemaDefinitionImpl1622012615[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)SchemaDefinitionImpl&lt;T&gt;</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   alwaysAllowNull: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   jsonDef: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   jsr310ConversionEnabled: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   pojo: Class&lt;T&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   properties: Map&lt;String, String&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   reader: SchemaReader&lt;T&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   supportSchemaVersioning: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   writer: SchemaWriter&lt;T&gt; [0..1]</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

SchemaEntry840873545[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)SchemaEntry</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   bitField0_: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   index_: List&lt;IndexEntry&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   memoizedIsInitialized: byte [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   schemaData_: ByteString [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ getIndex(index: int): IndexEntry</TD></TR>
<TR><TD ALIGN="LEFT" >+ getIndexOrBuilder(index: int): IndexEntryOrBuilder</TD></TR>
<TR><TD ALIGN="LEFT" ># internalGetFieldAccessorTable(): FieldAccessorTable</TD></TR>
<TR><TD ALIGN="LEFT" >+ newBuilder(): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ newBuilder(prototype: SchemaEntry): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ newBuilderForType(): Builder</TD></TR>
<TR><TD ALIGN="LEFT" ># newBuilderForType(parent: BuilderParent): Builder</TD></TR>
<TR><TD ALIGN="LEFT" ># newInstance(unused: UnusedPrivateParameter): Object</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseDelimitedFrom(input: InputStream): SchemaEntry</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseDelimitedFrom(input: InputStream, extensionRegistry: ExtensionRegistryLite): SchemaEntry</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(data: ByteBuffer): SchemaEntry</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(data: ByteBuffer, extensionRegistry: ExtensionRegistryLite): SchemaEntry</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(data: ByteString): SchemaEntry</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(data: ByteString, extensionRegistry: ExtensionRegistryLite): SchemaEntry</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(data: byte[]): SchemaEntry</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(data: byte[], extensionRegistry: ExtensionRegistryLite): SchemaEntry</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(input: InputStream): SchemaEntry</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(input: InputStream, extensionRegistry: ExtensionRegistryLite): SchemaEntry</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(input: CodedInputStream): SchemaEntry</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(input: CodedInputStream, extensionRegistry: ExtensionRegistryLite): SchemaEntry</TD></TR>
<TR><TD ALIGN="LEFT" >+ parser(): Parser&lt;SchemaEntry&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ toBuilder(): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeTo(output: CodedOutputStream)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

SchemaException770960286[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)SchemaException</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   recoverable: boolean [1]</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

SchemaHash1472480913[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)SchemaHash</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   hash: HashCode [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   schemaType: SchemaType [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ asBytes(): byte[]</TD></TR>
<TR><TD ALIGN="LEFT" ># canEqual(other: Object): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ of(schema: Schema): SchemaHash</TD></TR>
<TR><TD ALIGN="LEFT" >+ of(schemaData: SchemaData): SchemaHash</TD></TR>
<TR><TD ALIGN="LEFT" >- of(schemaBytes: byte[], schemaType: SchemaType): SchemaHash</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

SchemaInfo1678783339[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)SchemaInfo</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   bitField0_: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   deleted_: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   memoizedIsInitialized: byte [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   props_: List&lt;KeyValuePair&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   schemaId_: Object [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   schema_: ByteString [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   timestamp_: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   type_: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   user_: Object [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ getProps(index: int): KeyValuePair</TD></TR>
<TR><TD ALIGN="LEFT" >+ getPropsOrBuilder(index: int): KeyValuePairOrBuilder</TD></TR>
<TR><TD ALIGN="LEFT" ># internalGetFieldAccessorTable(): FieldAccessorTable</TD></TR>
<TR><TD ALIGN="LEFT" >+ newBuilder(): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ newBuilder(prototype: SchemaInfo): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ newBuilderForType(): Builder</TD></TR>
<TR><TD ALIGN="LEFT" ># newBuilderForType(parent: BuilderParent): Builder</TD></TR>
<TR><TD ALIGN="LEFT" ># newInstance(unused: UnusedPrivateParameter): Object</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseDelimitedFrom(input: InputStream): SchemaInfo</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseDelimitedFrom(input: InputStream, extensionRegistry: ExtensionRegistryLite): SchemaInfo</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(data: ByteBuffer): SchemaInfo</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(data: ByteBuffer, extensionRegistry: ExtensionRegistryLite): SchemaInfo</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(data: ByteString): SchemaInfo</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(data: ByteString, extensionRegistry: ExtensionRegistryLite): SchemaInfo</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(data: byte[]): SchemaInfo</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(data: byte[], extensionRegistry: ExtensionRegistryLite): SchemaInfo</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(input: InputStream): SchemaInfo</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(input: InputStream, extensionRegistry: ExtensionRegistryLite): SchemaInfo</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(input: CodedInputStream): SchemaInfo</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(input: CodedInputStream, extensionRegistry: ExtensionRegistryLite): SchemaInfo</TD></TR>
<TR><TD ALIGN="LEFT" >+ parser(): Parser&lt;SchemaInfo&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ toBuilder(): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeTo(output: CodedOutputStream)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

SchemaInfoBuilder1450609100[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)SchemaInfoBuilder</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   name: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   properties: Map&lt;String, String&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   propertiesSet: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   schema: byte[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   type: SchemaType [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ build(): SchemaInfo</TD></TR>
<TR><TD ALIGN="LEFT" >+ name(name: String): SchemaInfoBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ properties(properties: Map&lt;String, String&gt;): SchemaInfoBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ schema(schema: byte[]): SchemaInfoBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ type(type: SchemaType): SchemaInfoBuilder</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

SchemaInfoImpl1622012615[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)SchemaInfoImpl</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   name: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   properties: Map&lt;String, String&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   schema: byte[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   type: SchemaType [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- $default$properties(): Map&lt;String, String&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ builder(): SchemaInfoImplBuilder</TD></TR>
<TR><TD ALIGN="LEFT" ># canEqual(other: Object): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ setName(name: String): SchemaInfoImpl</TD></TR>
<TR><TD ALIGN="LEFT" >+ setProperties(properties: Map&lt;String, String&gt;): SchemaInfoImpl</TD></TR>
<TR><TD ALIGN="LEFT" >+ setSchema(schema: byte[]): SchemaInfoImpl</TD></TR>
<TR><TD ALIGN="LEFT" >+ setType(type: SchemaType): SchemaInfoImpl</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

SchemaInfoUtil1622012615[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)SchemaInfoUtil</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ newSchemaInfo(name: String, data: SchemaData): SchemaInfo</TD></TR>
<TR><TD ALIGN="LEFT" >+ newSchemaInfo(schema: Schema): SchemaInfo</TD></TR>
<TR><TD ALIGN="LEFT" >+ newSchemaInfo(name: String, schema: GetSchemaResponse): SchemaInfo</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

SchemaLocator840873545[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)SchemaLocator</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   bitField0_: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   index_: List&lt;IndexEntry&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   info_: IndexEntry [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   memoizedIsInitialized: byte [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ getIndex(index: int): IndexEntry</TD></TR>
<TR><TD ALIGN="LEFT" >+ getIndexOrBuilder(index: int): IndexEntryOrBuilder</TD></TR>
<TR><TD ALIGN="LEFT" ># internalGetFieldAccessorTable(): FieldAccessorTable</TD></TR>
<TR><TD ALIGN="LEFT" >+ newBuilder(): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ newBuilder(prototype: SchemaLocator): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ newBuilderForType(): Builder</TD></TR>
<TR><TD ALIGN="LEFT" ># newBuilderForType(parent: BuilderParent): Builder</TD></TR>
<TR><TD ALIGN="LEFT" ># newInstance(unused: UnusedPrivateParameter): Object</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseDelimitedFrom(input: InputStream): SchemaLocator</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseDelimitedFrom(input: InputStream, extensionRegistry: ExtensionRegistryLite): SchemaLocator</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(data: ByteBuffer): SchemaLocator</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(data: ByteBuffer, extensionRegistry: ExtensionRegistryLite): SchemaLocator</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(data: ByteString): SchemaLocator</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(data: ByteString, extensionRegistry: ExtensionRegistryLite): SchemaLocator</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(data: byte[]): SchemaLocator</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(data: byte[], extensionRegistry: ExtensionRegistryLite): SchemaLocator</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(input: InputStream): SchemaLocator</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(input: InputStream, extensionRegistry: ExtensionRegistryLite): SchemaLocator</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(input: CodedInputStream): SchemaLocator</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(input: CodedInputStream, extensionRegistry: ExtensionRegistryLite): SchemaLocator</TD></TR>
<TR><TD ALIGN="LEFT" >+ parser(): Parser&lt;SchemaLocator&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ toBuilder(): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeTo(output: CodedOutputStream)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

SchemaRegistryServiceImpl445450388[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)SchemaRegistryServiceImpl</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   clock: Clock [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   compatibilityChecks: Map&lt;SchemaType, SchemaCompatibilityCheck&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   schemaStorage: SchemaStorage [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- checkCompatibilityWithAll(schemaId: String, schema: SchemaData, strategy: SchemaCompatibilityStrategy): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- checkCompatibilityWithAll(schema: SchemaData, strategy: SchemaCompatibilityStrategy, schemaAndMetadataList: List&lt;SchemaAndMetadata&gt;): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- checkCompatibilityWithLatest(schemaId: String, schema: SchemaData, strategy: SchemaCompatibilityStrategy): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ checkCompatible(schemaId: String, schema: SchemaData, strategy: SchemaCompatibilityStrategy): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- checkCompatible(existingSchema: SchemaAndMetadata, newSchema: SchemaData, strategy: SchemaCompatibilityStrategy)</TD></TR>
<TR><TD ALIGN="LEFT" >+ checkConsumerCompatibility(schemaId: String, schemaData: SchemaData, strategy: SchemaCompatibilityStrategy): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ deleteSchema(schemaId: String, user: String): CompletableFuture&lt;SchemaVersion&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ deleteSchemaStorage(schemaId: String): CompletableFuture&lt;SchemaVersion&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ deleteSchemaStorage(schemaId: String, forcefully: boolean): CompletableFuture&lt;SchemaVersion&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- deleted(schemaId: String, user: String): SchemaInfo</TD></TR>
<TR><TD ALIGN="LEFT" >+ findSchemaVersion(schemaId: String, schemaData: SchemaData): CompletableFuture&lt;Long&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getAllSchemas(schemaId: String): CompletableFuture&lt;List&lt;CompletableFuture&lt;SchemaAndMetadata&gt;&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getSchema(schemaId: String): CompletableFuture&lt;SchemaAndMetadata&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getSchema(schemaId: String, version: SchemaVersion): CompletableFuture&lt;SchemaAndMetadata&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getSchemaVersionBySchemaData(schemaAndMetadataList: List&lt;SchemaAndMetadata&gt;, schemaData: SchemaData): CompletableFuture&lt;SchemaVersion&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ isCompatible(schemaId: String, schema: SchemaData, strategy: SchemaCompatibilityStrategy): CompletableFuture&lt;Boolean&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- isTransitiveStrategy(strategy: SchemaCompatibilityStrategy): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ isUsingAvroSchemaParser(type: SchemaType): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ putSchemaIfAbsent(schemaId: String, schema: SchemaData, strategy: SchemaCompatibilityStrategy): CompletableFuture&lt;SchemaVersion&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ trimDeletedSchemaAndGetList(schemaId: String): CompletableFuture&lt;List&lt;SchemaAndMetadata&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- trimDeletedSchemaAndGetList(list: List&lt;SchemaAndMetadata&gt;): List&lt;SchemaAndMetadata&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ versionFromBytes(version: byte[]): SchemaVersion</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

SchemaRegistryServiceWithSchemaDataValidator349782408[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)SchemaRegistryServiceWithSchemaDataValidator</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   service: SchemaRegistryService [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ checkCompatible(schemaId: String, schema: SchemaData, strategy: SchemaCompatibilityStrategy): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ checkConsumerCompatibility(schemaId: String, schemaData: SchemaData, strategy: SchemaCompatibilityStrategy): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ deleteSchema(schemaId: String, user: String): CompletableFuture&lt;SchemaVersion&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ deleteSchemaStorage(schemaId: String): CompletableFuture&lt;SchemaVersion&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ deleteSchemaStorage(schemaId: String, forcefully: boolean): CompletableFuture&lt;SchemaVersion&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ findSchemaVersion(schemaId: String, schemaData: SchemaData): CompletableFuture&lt;Long&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getAllSchemas(schemaId: String): CompletableFuture&lt;List&lt;CompletableFuture&lt;SchemaAndMetadata&gt;&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getSchema(schemaId: String): CompletableFuture&lt;SchemaAndMetadata&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getSchema(schemaId: String, version: SchemaVersion): CompletableFuture&lt;SchemaAndMetadata&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getSchemaVersionBySchemaData(schemaAndMetadataList: List&lt;SchemaAndMetadata&gt;, schemaData: SchemaData): CompletableFuture&lt;SchemaVersion&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ isCompatible(schemaId: String, schema: SchemaData, strategy: SchemaCompatibilityStrategy): CompletableFuture&lt;Boolean&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ of(service: SchemaRegistryService): SchemaRegistryServiceWithSchemaDataValidator</TD></TR>
<TR><TD ALIGN="LEFT" >+ putSchemaIfAbsent(schemaId: String, schema: SchemaData, strategy: SchemaCompatibilityStrategy): CompletableFuture&lt;SchemaVersion&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ trimDeletedSchemaAndGetList(schemaId: String): CompletableFuture&lt;List&lt;SchemaAndMetadata&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ versionFromBytes(version: byte[]): SchemaVersion</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

SchemaUtil1317853897[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)SchemaUtil</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ createAvroSchema(schemaDefinition: SchemaDefinition): Schema</TD></TR>
<TR><TD ALIGN="LEFT" >+ extractAvroSchema(schemaDefinition: SchemaDefinition, pojo: Class): Schema</TD></TR>
<TR><TD ALIGN="LEFT" >+ getJsr310ConversionEnabledFromSchemaInfo(schemaInfo: SchemaInfo): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseAvroSchema(schemaJson: String): Schema</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseSchemaInfo(schemaDefinition: SchemaDefinition&lt;T&gt;, schemaType: SchemaType): SchemaInfo</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

SchemaUtils1622012615[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)SchemaUtils</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ convertKeyValueDataStringToSchemaInfoSchema(keyValueSchemaInfoDataJsonBytes: byte[]): byte[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ convertKeyValueSchemaInfoDataToString(kvSchemaInfo: KeyValue&lt;SchemaInfo, SchemaInfo&gt;): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ deserializeSchemaProperties(serializedProperties: String): Map&lt;String, String&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- getKeyOrValueSchemaBytes(jsonElement: JsonElement): byte[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ getStringSchemaVersion(schemaVersionBytes: byte[]): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ jsonifyKeyValueSchemaInfo(kvSchemaInfo: KeyValue&lt;SchemaInfo, SchemaInfo&gt;): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ jsonifySchemaInfo(schemaInfo: SchemaInfo): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ jsonifySchemaInfoWithVersion(schemaInfoWithVersion: SchemaInfoWithVersion): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ serializeSchemaProperties(properties: Map&lt;String, String&gt;): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ toAvroObject(value: Object): Object</TD></TR>
<TR><TD ALIGN="LEFT" >+ toJsonElement(str: String): JsonElement</TD></TR>
<TR><TD ALIGN="LEFT" >+ validateFieldSchema(name: String, type: SchemaType, val: Object)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

SchemasResourceBase229910521[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)SchemasResourceBase</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   clock: Clock [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- convertSchemaAndMetadataToGetSchemaResponse(schemaAndMetadata: SchemaAndMetadata): GetSchemaResponse</TD></TR>
<TR><TD ALIGN="LEFT" >+ deleteSchema(authoritative: boolean, response: AsyncResponse)</TD></TR>
<TR><TD ALIGN="LEFT" ># domain(): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ getAllSchemas(authoritative: boolean, response: AsyncResponse)</TD></TR>
<TR><TD ALIGN="LEFT" >- getLongSchemaVersion(schemaVersion: SchemaVersion): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ getSchema(authoritative: boolean, response: AsyncResponse)</TD></TR>
<TR><TD ALIGN="LEFT" >+ getSchema(authoritative: boolean, version: String, response: AsyncResponse)</TD></TR>
<TR><TD ALIGN="LEFT" >+ getVersionBySchema(payload: PostSchemaPayload, authoritative: boolean, response: AsyncResponse)</TD></TR>
<TR><TD ALIGN="LEFT" >- handleGetAllSchemasResponse(response: AsyncResponse, schemas: List&lt;SchemaAndMetadata&gt;, error: Throwable)</TD></TR>
<TR><TD ALIGN="LEFT" >- handleGetSchemaResponse(response: AsyncResponse, schema: SchemaAndMetadata, error: Throwable)</TD></TR>
<TR><TD ALIGN="LEFT" >+ postSchema(payload: PostSchemaPayload, authoritative: boolean, response: AsyncResponse)</TD></TR>
<TR><TD ALIGN="LEFT" >+ testCompatibility(payload: PostSchemaPayload, authoritative: boolean, response: AsyncResponse)</TD></TR>
<TR><TD ALIGN="LEFT" >- validateDestinationAndAdminOperation(authoritative: boolean)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

Section330549314[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)Section&lt;V&gt;</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   capacity: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   keys: long[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   resizeThreshold: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   size: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   usedBuckets: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   values: V[] [0..*]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># clear()</TD></TR>
<TR><TD ALIGN="LEFT" >+ forEach(processor: EntryProcessor&lt;V&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" ># get(key: long, keyHash: int): V</TD></TR>
<TR><TD ALIGN="LEFT" >- insertKeyValueNoLock(keys: long[], values: V[], key: long, value: V)</TD></TR>
<TR><TD ALIGN="LEFT" ># put(key: long, value: V, keyHash: int, onlyIfAbsent: boolean, valueProvider: LongFunction&lt;V&gt;): V</TD></TR>
<TR><TD ALIGN="LEFT" >- rehash()</TD></TR>
<TR><TD ALIGN="LEFT" >- remove(key: long, value: Object, keyHash: int): V</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

SerDeSchema1430540343[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)SerDeSchema&lt;T&gt;</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   serDe: SerDe&lt;T&gt; [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># canEqual(other: Object): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ clone(): Schema&lt;T&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ decode(bytes: byte[]): T</TD></TR>
<TR><TD ALIGN="LEFT" >+ encode(value: T): byte[]</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

ServerCnx1718290011[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)ServerCnx</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   authMethod: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   authRole: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   authState: AuthenticationState [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   authenticateOriginalAuthData: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   authenticationData: AuthenticationDataSource [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   authenticationProvider: AuthenticationProvider [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   autoReadDisabledPublishBufferLimiting: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   autoReadDisabledRateLimiting: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   clientVersion: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   commandSender: PulsarCommandSender [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   connectionController: ConnectionController [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   consumers: ConcurrentLongHashMap&lt;CompletableFuture&lt;Consumer&gt;&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   encryptionRequireOnProducer: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   features: FeatureFlags [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   isActive: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   listenerName: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   maxMessageSize: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   maxNonPersistentPendingMessages: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   maxPendingBytesPerThread: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   maxPendingSendRequests: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   nonPersistentPendingMessages: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   originalAuthData: AuthenticationDataSource [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   originalAuthState: AuthenticationState [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   originalPrincipal: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   pendingAuthChallengeResponse: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   pendingSendRequest: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   preciseDispatcherFlowControl: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   preciseTopicPublishRateLimitingEnable: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   producers: ConcurrentLongHashMap&lt;CompletableFuture&lt;Producer&gt;&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   proxyRoles: Set&lt;String&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   replicatorPrefix: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   resumeReadsThreshold: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   resumeThresholdPendingBytesPerThread: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   schemaService: SchemaRegistryService [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   schemaValidationEnforced: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   service: BrokerService [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   state: State [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- buildProducerAndAddTopic(topic: Topic, producerId: long, producerName: String, requestId: long, isEncrypted: boolean, metadata: Map&lt;String, String&gt;, schemaVersion: SchemaVersion, epoch: long, userProvidedProducerName: boolean, topicName: TopicName, producerAccessMode: ProducerAccessMode, topicEpoch: Optional&lt;Long&gt;, supportsPartialProducer: boolean, producerFuture: CompletableFuture&lt;Producer&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ cancelPublishBufferLimiting()</TD></TR>
<TR><TD ALIGN="LEFT" >+ cancelPublishRateLimiting()</TD></TR>
<TR><TD ALIGN="LEFT" >+ channelActive(ctx: ChannelHandlerContext)</TD></TR>
<TR><TD ALIGN="LEFT" >+ channelInactive(ctx: ChannelHandlerContext)</TD></TR>
<TR><TD ALIGN="LEFT" >+ channelWritabilityChanged(ctx: ChannelHandlerContext)</TD></TR>
<TR><TD ALIGN="LEFT" >- checkTransactionEnableAndSendError(requestId: long): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ clientAddress(): SocketAddress</TD></TR>
<TR><TD ALIGN="LEFT" >+ clientSourceAddress(): String</TD></TR>
<TR><TD ALIGN="LEFT" ># close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ closeConsumer(consumer: Consumer)</TD></TR>
<TR><TD ALIGN="LEFT" >+ closeProducer(producer: Producer)</TD></TR>
<TR><TD ALIGN="LEFT" >- completeConnect(clientProtoVersion: int, clientVersion: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ completedSendOperation(isNonPersistentTopic: boolean, msgSize: int)</TD></TR>
<TR><TD ALIGN="LEFT" ># createConsumerStatsResponse(consumer: Consumer, requestId: long): ByteBuf</TD></TR>
<TR><TD ALIGN="LEFT" >+ ctx(): ChannelHandlerContext</TD></TR>
<TR><TD ALIGN="LEFT" >+ disableCnxAutoRead()</TD></TR>
<TR><TD ALIGN="LEFT" >- disableTcpNoDelayIfNeeded(topic: String, producerName: String)</TD></TR>
<TR><TD ALIGN="LEFT" >- doAuthentication(clientData: AuthData, clientProtocolVersion: int, clientVersion: String): State</TD></TR>
<TR><TD ALIGN="LEFT" >+ enableCnxAutoRead()</TD></TR>
<TR><TD ALIGN="LEFT" >+ exceptionCaught(ctx: ChannelHandlerContext, cause: Throwable)</TD></TR>
<TR><TD ALIGN="LEFT" >+ execute(runnable: Runnable)</TD></TR>
<TR><TD ALIGN="LEFT" >- getErrorCode(future: CompletableFuture&lt;T&gt;): ServerError</TD></TR>
<TR><TD ALIGN="LEFT" >- getLargestBatchIndexWhenPossible(topic: Topic, lastPosition: PositionImpl, markDeletePosition: PositionImpl, partitionIndex: int, requestId: long, subscriptionName: String)</TD></TR>
<TR><TD ALIGN="LEFT" >- getSchema(protocolSchema: Schema): SchemaData</TD></TR>
<TR><TD ALIGN="LEFT" ># handleAck(ack: CommandAck)</TD></TR>
<TR><TD ALIGN="LEFT" ># handleAddPartitionToTxn(command: CommandAddPartitionToTxn)</TD></TR>
<TR><TD ALIGN="LEFT" ># handleAddSubscriptionToTxn(command: CommandAddSubscriptionToTxn)</TD></TR>
<TR><TD ALIGN="LEFT" ># handleAuthResponse(authResponse: CommandAuthResponse)</TD></TR>
<TR><TD ALIGN="LEFT" ># handleCloseConsumer(closeConsumer: CommandCloseConsumer)</TD></TR>
<TR><TD ALIGN="LEFT" ># handleCloseProducer(closeProducer: CommandCloseProducer)</TD></TR>
<TR><TD ALIGN="LEFT" ># handleConnect(connect: CommandConnect)</TD></TR>
<TR><TD ALIGN="LEFT" ># handleConsumerStats(commandConsumerStats: CommandConsumerStats)</TD></TR>
<TR><TD ALIGN="LEFT" ># handleEndTxn(command: CommandEndTxn)</TD></TR>
<TR><TD ALIGN="LEFT" ># handleEndTxnOnPartition(command: CommandEndTxnOnPartition)</TD></TR>
<TR><TD ALIGN="LEFT" ># handleEndTxnOnSubscription(command: CommandEndTxnOnSubscription)</TD></TR>
<TR><TD ALIGN="LEFT" ># handleFlow(flow: CommandFlow)</TD></TR>
<TR><TD ALIGN="LEFT" ># handleGetLastMessageId(getLastMessageId: CommandGetLastMessageId)</TD></TR>
<TR><TD ALIGN="LEFT" ># handleGetOrCreateSchema(commandGetOrCreateSchema: CommandGetOrCreateSchema)</TD></TR>
<TR><TD ALIGN="LEFT" ># handleGetSchema(commandGetSchema: CommandGetSchema)</TD></TR>
<TR><TD ALIGN="LEFT" ># handleGetTopicsOfNamespace(commandGetTopicsOfNamespace: CommandGetTopicsOfNamespace)</TD></TR>
<TR><TD ALIGN="LEFT" >- handleLastMessageIdFromCompactedLedger(persistentTopic: PersistentTopic, requestId: long, partitionIndex: int, markDeletePosition: PositionImpl)</TD></TR>
<TR><TD ALIGN="LEFT" ># handleLookup(lookup: CommandLookupTopic)</TD></TR>
<TR><TD ALIGN="LEFT" ># handleNewTxn(command: CommandNewTxn)</TD></TR>
<TR><TD ALIGN="LEFT" ># handlePartitionMetadataRequest(partitionMetadata: CommandPartitionedTopicMetadata)</TD></TR>
<TR><TD ALIGN="LEFT" ># handleProducer(cmdProducer: CommandProducer)</TD></TR>
<TR><TD ALIGN="LEFT" ># handleRedeliverUnacknowledged(redeliver: CommandRedeliverUnacknowledgedMessages)</TD></TR>
<TR><TD ALIGN="LEFT" ># handleSeek(seek: CommandSeek)</TD></TR>
<TR><TD ALIGN="LEFT" ># handleSend(send: CommandSend, headersAndPayload: ByteBuf)</TD></TR>
<TR><TD ALIGN="LEFT" ># handleSubscribe(subscribe: CommandSubscribe)</TD></TR>
<TR><TD ALIGN="LEFT" ># handleTcClientConnectRequest(command: CommandTcClientConnectRequest)</TD></TR>
<TR><TD ALIGN="LEFT" >- handleTxnException(ex: Throwable, op: String, requestId: long): Throwable</TD></TR>
<TR><TD ALIGN="LEFT" ># handleUnsubscribe(unsubscribe: CommandUnsubscribe)</TD></TR>
<TR><TD ALIGN="LEFT" ># hasConsumer(consumerId: long): boolean</TD></TR>
<TR><TD ALIGN="LEFT" ># interceptCommand(command: BaseCommand)</TD></TR>
<TR><TD ALIGN="LEFT" >- invalidOriginalPrincipal(originalPrincipal: String): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >- isNamespaceOperationAllowed(namespaceName: NamespaceName, operation: NamespaceOperation): CompletableFuture&lt;Boolean&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- isTopicOperationAllowed(topicName: TopicName, operation: TopicOperation): CompletableFuture&lt;Boolean&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- isTopicOperationAllowed(topicName: TopicName, subscriptionName: String, operation: TopicOperation): CompletableFuture&lt;Boolean&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- logAuthException(remoteAddress: SocketAddress, operation: String, principal: String, topic: Optional&lt;TopicName&gt;, ex: Throwable)</TD></TR>
<TR><TD ALIGN="LEFT" >- logNamespaceNameAuthException(remoteAddress: SocketAddress, operation: String, principal: String, namespaceName: Optional&lt;NamespaceName&gt;, ex: Throwable)</TD></TR>
<TR><TD ALIGN="LEFT" >+ newMessageAndIntercept(consumerId: long, ledgerId: long, entryId: long, partition: int, redeliveryCount: int, metadataAndPayload: ByteBuf, ackSet: long[], topic: String, epoch: long): ByteBufPair</TD></TR>
<TR><TD ALIGN="LEFT" >+ newPromise(): Promise&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- printSendCommandDebug(send: CommandSend, headersAndPayload: ByteBuf)</TD></TR>
<TR><TD ALIGN="LEFT" >- recordRateLimitMetrics(producers: ConcurrentLongHashMap&lt;CompletableFuture&lt;Producer&gt;&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ refreshAuthenticationCredentials()</TD></TR>
<TR><TD ALIGN="LEFT" >+ removedConsumer(consumer: Consumer)</TD></TR>
<TR><TD ALIGN="LEFT" >+ removedProducer(producer: Producer)</TD></TR>
<TR><TD ALIGN="LEFT" >- safelyRemoveConsumer(consumer: Consumer)</TD></TR>
<TR><TD ALIGN="LEFT" >- safelyRemoveProducer(producer: Producer)</TD></TR>
<TR><TD ALIGN="LEFT" >+ startSendOperation(producer: Producer, msgSize: int, numMessages: int)</TD></TR>
<TR><TD ALIGN="LEFT" ># supportBrokerMetadata(): boolean</TD></TR>
<TR><TD ALIGN="LEFT" ># supportsAuthenticationRefresh(): boolean</TD></TR>
<TR><TD ALIGN="LEFT" ># supportsPartialProducer(): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >- tryAddSchema(topic: Topic, schema: SchemaData): CompletableFuture&lt;SchemaVersion&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- validateTopicName(topic: String, requestId: long, requestCommand: Object): TopicName</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

ServerMetadataException1254029274[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)ServerMetadataException</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

ServiceChannelInitializer79518146[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)ServiceChannelInitializer</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   brokerProxyReadTimeoutMs: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   clientSSLContextAutoRefreshBuilder: NettySSLContextAutoRefreshBuilder [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   clientSslCtxRefresher: SslContextAutoRefreshBuilder&lt;SslContext&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   enableTls: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   proxyService: ProxyService [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   serverSSLContextAutoRefreshBuilder: NettySSLContextAutoRefreshBuilder [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   serverSslCtxRefresher: SslContextAutoRefreshBuilder&lt;SslContext&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   tlsEnabledWithKeyStore: boolean [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># initChannel(ch: SocketChannel)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

ServiceConfiguration724302956[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)ServiceConfiguration</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   acknowledgmentAtBatchIndexLevelEnabled: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   activeConsumerFailoverDelayTimeMillis: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   additionalServletDirectory: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   additionalServlets: Set&lt;String&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   advertisedAddress: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   advertisedListeners: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   aggregatePublisherStatsByProducerName: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   allowAutoSubscriptionCreation: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   allowAutoTopicCreation: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   allowAutoTopicCreationType: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   anonymousUserRole: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   authenticateOriginalAuthData: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   authenticationEnabled: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   authenticationProviders: Set&lt;String&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   authenticationRefreshCheckSeconds: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   authorizationAllowWildcardsMatching: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   authorizationEnabled: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   authorizationProvider: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   autoSkipNonRecoverableData: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   backlogQuotaCheckEnabled: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   backlogQuotaCheckIntervalInSeconds: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   backlogQuotaDefaultLimitBytes: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   backlogQuotaDefaultLimitGB: double [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   backlogQuotaDefaultLimitSecond: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   backlogQuotaDefaultRetentionPolicy: RetentionPolicy [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   bindAddress: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   bindAddresses: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   bookkeeperClientAuthenticationParameters: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   bookkeeperClientAuthenticationParametersName: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   bookkeeperClientAuthenticationPlugin: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   bookkeeperClientEnforceMinNumRacksPerWriteQuorum: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   bookkeeperClientExposeStatsToPrometheus: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   bookkeeperClientGetBookieInfoIntervalSeconds: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   bookkeeperClientGetBookieInfoRetryIntervalSeconds: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   bookkeeperClientHealthCheckEnabled: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   bookkeeperClientHealthCheckErrorThresholdPerInterval: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   bookkeeperClientHealthCheckIntervalSeconds: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   bookkeeperClientHealthCheckQuarantineTimeInSeconds: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   bookkeeperClientIsolationGroups: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   bookkeeperClientMinNumRacksPerWriteQuorum: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   bookkeeperClientNumWorkerThreads: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   bookkeeperClientQuarantineRatio: double [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   bookkeeperClientRackawarePolicyEnabled: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   bookkeeperClientRegionawarePolicyEnabled: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   bookkeeperClientReorderReadSequenceEnabled: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   bookkeeperClientSecondaryIsolationGroups: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   bookkeeperClientSpeculativeReadTimeoutInMillis: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   bookkeeperClientThrottleValue: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   bookkeeperClientTimeoutInSeconds: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   bookkeeperDiskWeightBasedPlacementEnabled: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   bookkeeperEnableStickyReads: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   bookkeeperExplicitLacIntervalInMills: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   bookkeeperMetadataServiceUri: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   bookkeeperNumberOfChannelsPerBookie: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   bookkeeperTLSCertificateFilePath: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   bookkeeperTLSClientAuthentication: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   bookkeeperTLSKeyFilePath: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   bookkeeperTLSKeyFileType: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   bookkeeperTLSKeyStorePasswordPath: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   bookkeeperTLSProviderFactoryClass: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   bookkeeperTLSTrustCertTypes: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   bookkeeperTLSTrustCertsFilePath: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   bookkeeperTLSTrustStorePasswordPath: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   bookkeeperTlsCertFilesRefreshDurationSeconds: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   bookkeeperUseV2WireProtocol: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   bootstrapNamespaces: List&lt;String&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   brokerClientAuthenticationParameters: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   brokerClientAuthenticationPlugin: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   brokerClientSslProvider: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   brokerClientTlsCiphers: Set&lt;String&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   brokerClientTlsEnabled: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   brokerClientTlsEnabledWithKeyStore: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   brokerClientTlsProtocols: Set&lt;String&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   brokerClientTlsTrustStore: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   brokerClientTlsTrustStorePassword: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   brokerClientTlsTrustStoreType: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   brokerClientTrustCertsFilePath: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   brokerDeduplicationEnabled: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   brokerDeduplicationEntriesInterval: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   brokerDeduplicationMaxNumberOfProducers: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   brokerDeduplicationProducerInactivityTimeoutMinutes: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   brokerDeduplicationSnapshotFrequencyInSeconds: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   brokerDeduplicationSnapshotIntervalSeconds: Integer [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   brokerDeleteInactivePartitionedTopicMetadataEnabled: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   brokerDeleteInactiveTopicsEnabled: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   brokerDeleteInactiveTopicsFrequencySeconds: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   brokerDeleteInactiveTopicsMaxInactiveDurationSeconds: Integer [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   brokerDeleteInactiveTopicsMode: InactiveTopicDeleteMode [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   brokerEntryMetadataInterceptors: Set&lt;String&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   brokerEntryPayloadProcessors: Set&lt;String&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   brokerInterceptors: Set&lt;String&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   brokerInterceptorsDirectory: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   brokerMaxConnections: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   brokerMaxConnectionsPerIp: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   brokerPublisherThrottlingMaxByteRate: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   brokerPublisherThrottlingMaxMessageRate: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   brokerPublisherThrottlingTickTimeMillis: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   brokerServiceCompactionMonitorIntervalInSeconds: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   brokerServiceCompactionPhaseOneLoopTimeInSeconds: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   brokerServiceCompactionThresholdInBytes: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   brokerServicePort: Optional&lt;Integer&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   brokerServicePortTls: Optional&lt;Integer&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   brokerServicePurgeInactiveFrequencyInSeconds: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   brokerShutdownTimeoutMs: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   clientLibraryVersionCheckEnabled: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   clusterName: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   configurationMetadataStoreUrl: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   configurationStoreServers: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   defaultNamespaceBundleSplitAlgorithm: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   defaultNumPartitions: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   defaultNumberOfNamespaceBundles: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   defaultRetentionSizeInMB: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   defaultRetentionTimeInMinutes: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   delayedDeliveryEnabled: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   delayedDeliveryTickTimeMillis: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   delayedDeliveryTrackerFactoryClassName: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   disableBrokerInterceptors: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   disableHttpDebugMethods: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   dispatchThrottlingOnBatchMessageEnabled: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   dispatchThrottlingOnNonBacklogConsumerEnabled: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   dispatchThrottlingRateInByte: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   dispatchThrottlingRateInMsg: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   dispatchThrottlingRatePerReplicatorInByte: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   dispatchThrottlingRatePerReplicatorInMsg: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   dispatchThrottlingRatePerSubscriptionInByte: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   dispatchThrottlingRatePerSubscriptionInMsg: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   dispatchThrottlingRatePerTopicInByte: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   dispatchThrottlingRatePerTopicInMsg: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   dispatchThrottlingRateRelativeToPublishRate: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   dispatcherMaxReadBatchSize: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   dispatcherMaxReadSizeBytes: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   dispatcherMaxRoundRobinBatchSize: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   dispatcherMinReadBatchSize: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   dispatcherReadFailureBackoffInitialTimeInMs: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   dispatcherReadFailureBackoffMandatoryStopTimeInMs: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   dispatcherReadFailureBackoffMaxTimeInMs: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   enableBusyWait: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   enableNamespaceIsolationUpdateOnTime: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   enableNonPersistentTopics: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   enablePackagesManagement: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   enablePersistentTopics: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   enableReplicatedSubscriptions: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   enableRunBookieAutoRecoveryTogether: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   enableRunBookieTogether: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   encryptionRequireOnProducer: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   entryFilterNames: List&lt;String&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   entryFiltersDirectory: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   exposeBundlesMetricsInPrometheus: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   exposeConsumerLevelMetricsInPrometheus: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   exposeManagedCursorMetricsInPrometheus: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   exposeManagedLedgerMetricsInPrometheus: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   exposePreciseBacklogInPrometheus: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   exposeProducerLevelMetricsInPrometheus: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   exposePublisherStats: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   exposeSubscriptionBacklogSizeInPrometheus: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   exposeTopicLevelMetricsInPrometheus: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   exposingBrokerEntryMetadataToClientEnabled: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   failureDomainsEnabled: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   forceDeleteNamespaceAllowed: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   forceDeleteTenantAllowed: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   functionsWorkerEnabled: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   functionsWorkerServiceNarPackage: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   globalZookeeperServers: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   haProxyProtocolEnabled: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   httpMaxRequestSize: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   httpRequestsLimitEnabled: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   httpRequestsMaxPerSecond: double [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   internalListenerName: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   isAllowAutoUpdateSchemaEnabled: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   isRunningStandalone: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   isSchemaValidationEnforced: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   jvmGCMetricsLoggerClassName: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   keepAliveIntervalSeconds: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   kinitCommand: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   lazyCursorRecovery: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   loadBalancerAutoBundleSplitEnabled: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   loadBalancerAutoUnloadSplitBundlesEnabled: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   loadBalancerBandwithInResourceWeight: double [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   loadBalancerBandwithOutResourceWeight: double [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   loadBalancerBrokerComfortLoadLevelPercentage: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   loadBalancerBrokerMaxTopics: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   loadBalancerBrokerOverloadedThresholdPercentage: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   loadBalancerBrokerThresholdShedderPercentage: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   loadBalancerBrokerUnderloadedThresholdPercentage: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   loadBalancerBundleUnloadMinThroughputThreshold: double [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   loadBalancerCPUResourceWeight: double [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   loadBalancerDirectMemoryResourceWeight: double [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   loadBalancerEnabled: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   loadBalancerHistoryResourcePercentage: double [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   loadBalancerHostUsageCheckIntervalMinutes: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   loadBalancerLoadSheddingStrategy: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   loadBalancerMemoryResourceWeight: double [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   loadBalancerMsgRateDifferenceShedderThreshold: double [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   loadBalancerMsgThroughputMultiplierDifferenceShedderThreshold: double [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   loadBalancerNamespaceBundleMaxBandwidthMbytes: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   loadBalancerNamespaceBundleMaxMsgRate: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   loadBalancerNamespaceBundleMaxSessions: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   loadBalancerNamespaceBundleMaxTopics: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   loadBalancerNamespaceMaximumBundles: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   loadBalancerOverrideBrokerNicSpeedGbps: Optional&lt;Double&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   loadBalancerPlacementStrategy: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   loadBalancerReportUpdateMaxIntervalMinutes: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   loadBalancerReportUpdateThresholdPercentage: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   loadBalancerResourceQuotaUpdateIntervalMinutes: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   loadBalancerSheddingEnabled: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   loadBalancerSheddingGracePeriodMinutes: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   loadBalancerSheddingIntervalMinutes: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   loadManagerClassName: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   managedLedgerAddEntryTimeoutSeconds: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   managedLedgerCacheCopyEntries: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   managedLedgerCacheEvictionFrequency: double [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   managedLedgerCacheEvictionTimeThresholdMillis: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   managedLedgerCacheEvictionWatermark: double [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   managedLedgerCacheSizeMB: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   managedLedgerCursorBackloggedThreshold: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   managedLedgerCursorMaxEntriesPerLedger: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   managedLedgerCursorPositionFlushSeconds: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   managedLedgerCursorRolloverTimeInSeconds: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   managedLedgerDataReadPriority: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   managedLedgerDefaultAckQuorum: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   managedLedgerDefaultEnsembleSize: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   managedLedgerDefaultMarkDeleteRateLimit: double [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   managedLedgerDefaultWriteQuorum: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   managedLedgerDigestType: DigestType [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   managedLedgerInactiveLedgerRolloverTimeSeconds: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   managedLedgerInfoCompressionType: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   managedLedgerMaxAckQuorum: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   managedLedgerMaxEnsembleSize: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   managedLedgerMaxEntriesPerLedger: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   managedLedgerMaxLedgerRolloverTimeMinutes: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   managedLedgerMaxSizePerLedgerMbytes: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   managedLedgerMaxUnackedRangesToPersist: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   managedLedgerMaxUnackedRangesToPersistInZooKeeper: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   managedLedgerMaxWriteQuorum: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   managedLedgerMetadataOperationsTimeoutSeconds: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   managedLedgerMinLedgerRolloverTimeMinutes: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   managedLedgerNewEntriesCheckDelayInMillis: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   managedLedgerNumSchedulerThreads: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   managedLedgerNumWorkerThreads: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   managedLedgerOffloadAutoTriggerSizeThresholdBytes: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   managedLedgerOffloadDeletionLagMs: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   managedLedgerOffloadDriver: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   managedLedgerOffloadMaxThreads: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   managedLedgerOffloadPrefetchRounds: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   managedLedgerPassword: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   managedLedgerPrometheusStatsLatencyRolloverSeconds: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   managedLedgerReadEntryTimeoutSeconds: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   managedLedgerStatsPeriodSeconds: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   managedLedgerStorageClassName: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   managedLedgerTraceTaskExecution: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   managedLedgerUnackedRangesOpenCacheSetEnabled: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   maxConcurrentHttpRequests: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   maxConcurrentLookupRequest: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   maxConcurrentNonPersistentMessagePerConnection: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   maxConcurrentTopicLoadRequest: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   maxConsumersPerSubscription: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   maxConsumersPerTopic: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   maxMessagePublishBufferSizeInMB: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   maxMessageSize: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   maxNamespacesPerTenant: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   maxNumPartitionsPerPartitionedTopic: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   maxPendingPublishRequestsPerConnection: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   maxProducersPerTopic: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   maxPublishRatePerTopicInBytes: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   maxPublishRatePerTopicInMessages: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   maxSameAddressConsumersPerTopic: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   maxSameAddressProducersPerTopic: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   maxSubscriptionsPerTopic: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   maxTenants: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   maxTopicsPerNamespace: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   maxUnackedMessagesPerBroker: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   maxUnackedMessagesPerConsumer: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   maxUnackedMessagesPerSubscription: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   maxUnackedMessagesPerSubscriptionOnBrokerBlocked: double [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   messageExpiryCheckIntervalInMinutes: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   messagePublishBufferCheckIntervalInMillis: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   messagingProtocols: Set&lt;String&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   metadataStoreBatchingEnabled: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   metadataStoreBatchingMaxDelayMillis: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   metadataStoreBatchingMaxOperations: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   metadataStoreBatchingMaxSizeKb: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   metadataStoreCacheExpirySeconds: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   metadataStoreConfigPath: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   metadataStoreOperationTimeoutSeconds: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   metadataStoreSessionTimeoutMillis: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   metadataStoreUrl: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   metricsServletTimeoutMs: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   namespaceBundleUnloadingTimeoutMs: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   narExtractionDirectory: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   numAcceptorThreads: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   numCacheExecutorThreadPoolSize: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   numExecutorThreadPoolSize: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   numHttpServerThreads: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   numIOThreads: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   numOrderedExecutorThreads: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   numTransactionReplayThreadPoolSize: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   numWorkerThreadsForNonPersistentTopic: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   offloadersDirectory: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   packagesManagementLedgerRootPath: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   packagesManagementStorageProvider: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   packagesReplicas: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   preciseDispatcherFlowControl: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   preciseTimeBasedBacklogQuotaCheck: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   preciseTopicPublishRateLimiterEnable: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   preferLaterVersions: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   properties: Properties [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   protocolHandlerDirectory: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   proxyRoles: Set&lt;String&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   replicatedSubscriptionsSnapshotFrequencyMillis: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   replicatedSubscriptionsSnapshotMaxCachedPerSubscription: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   replicatedSubscriptionsSnapshotTimeoutSeconds: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   replicationConnectionsPerBroker: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   replicationMetricsEnabled: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   replicationPolicyCheckDurationSeconds: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   replicationProducerQueueSize: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   replicationTlsEnabled: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   replicatorPrefix: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   resourceUsageTransportClassName: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   resourceUsageTransportPublishIntervalInSecs: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   retentionCheckIntervalInSeconds: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   saslJaasClientAllowedIds: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   saslJaasServerSectionName: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   schemaCompatibilityStrategy: SchemaCompatibilityStrategy [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   schemaRegistryCompatibilityCheckers: Set&lt;String&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   schemaRegistryStorageClassName: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   skipBrokerShutdownOnOOM: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   splitTopicAndPartitionLabelInPrometheus: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   statsUpdateFrequencyInSecs: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   statsUpdateInitialDelayInSecs: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   statusFilePath: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   streamingDispatch: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   subscribeRatePeriodPerConsumerInSecond: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   subscribeThrottlingRatePerConsumer: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   subscriptionExpirationTimeMinutes: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   subscriptionExpiryCheckIntervalInMinutes: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   subscriptionKeySharedConsistentHashingReplicaPoints: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   subscriptionKeySharedEnable: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   subscriptionKeySharedUseConsistentHashing: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   subscriptionRedeliveryTrackerEnabled: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   subscriptionTypesEnabled: Set&lt;String&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   superUserRoles: Set&lt;String&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   supportedNamespaceBundleSplitAlgorithms: List&lt;String&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   systemTopicEnabled: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   systemTopicSchemaCompatibilityStrategy: SchemaCompatibilityStrategy [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   tlsAllowInsecureConnection: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   tlsCertRefreshCheckDurationSec: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   tlsCertificateFilePath: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   tlsCiphers: Set&lt;String&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   tlsEnabled: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   tlsEnabledWithKeyStore: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   tlsKeyFilePath: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   tlsKeyStore: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   tlsKeyStorePassword: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   tlsKeyStoreType: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   tlsProtocols: Set&lt;String&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   tlsProvider: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   tlsRequireTrustedClientCertOnConnect: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   tlsTrustCertsFilePath: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   tlsTrustStore: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   tlsTrustStorePassword: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   tlsTrustStoreType: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   topicFencingTimeoutSeconds: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   topicLevelPoliciesEnabled: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   topicLoadTimeoutSeconds: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   topicPublisherThrottlingTickTimeMillis: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   transactionBufferProviderClassName: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   transactionBufferSnapshotMaxTransactionCount: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   transactionBufferSnapshotMinTimeInMillis: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   transactionCoordinatorEnabled: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   transactionMetadataStoreProviderClassName: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   transactionPendingAckStoreProviderClassName: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   ttlDurationDefaultInSeconds: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   unblockStuckSubscriptionEnabled: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   useSeparateThreadPoolForProtocolHandlers: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   webServicePort: Optional&lt;Integer&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   webServicePortTls: Optional&lt;Integer&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   webServiceTlsCiphers: Set&lt;String&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   webServiceTlsProtocols: Set&lt;String&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   webSocketConnectionsPerBroker: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   webSocketMaxTextFrameSize: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   webSocketNumIoThreads: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   webSocketServiceEnabled: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   webSocketSessionIdleTimeoutMillis: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   zooKeeperCacheExpirySeconds: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   zooKeeperOperationTimeoutSeconds: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   zooKeeperSessionTimeoutMillis: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   zookeeperServers: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   zookeeperSessionExpiredPolicy: MetadataSessionExpiredPolicy [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ getProperty(key: String): Object</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

ServiceConfigurationUtils724302956[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)ServiceConfigurationUtils</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ brokerUrl(host: String, port: int): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ brokerUrlTls(host: String, port: int): String</TD></TR>
<TR><TD ALIGN="LEFT" >- createUriOrNull(scheme: String, hostname: String, port: Optional&lt;Integer&gt;): URI</TD></TR>
<TR><TD ALIGN="LEFT" >+ getAppliedAdvertisedAddress(configuration: ServiceConfiguration, ignoreAdvertisedListener: boolean): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ getDefaultOrConfiguredAddress(configuredAddress: String): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ getInternalListener(config: ServiceConfiguration): AdvertisedListener</TD></TR>
<TR><TD ALIGN="LEFT" >+ getWebServiceAddress(config: ServiceConfiguration): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ unsafeLocalhostResolve(): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ webServiceUrl(host: String, port: int): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ webServiceUrlTls(host: String, port: int): String</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

ServiceURI1605698901[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)ServiceURI</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   serviceHosts: String[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   serviceInfos: String[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   serviceName: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   servicePath: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   serviceUser: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   uri: URI [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># canEqual(other: Object): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ create(uriStr: String): ServiceURI</TD></TR>
<TR><TD ALIGN="LEFT" >+ create(uri: URI): ServiceURI</TD></TR>
<TR><TD ALIGN="LEFT" >- getServicePort(serviceName: String, serviceInfos: String[]): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ selectOne(): String</TD></TR>
<TR><TD ALIGN="LEFT" >- validateHostName(serviceName: String, serviceInfos: String[], hostname: String): String</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

ServiceUnitNotReadyException1254029274[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)ServiceUnitNotReadyException</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

ShortSchema1622012615[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)ShortSchema</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ decode(bytes: byte[]): Short</TD></TR>
<TR><TD ALIGN="LEFT" >+ decode(byteBuf: ByteBuf): Short</TD></TR>
<TR><TD ALIGN="LEFT" >+ encode(message: Short): byte[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ of(): ShortSchema</TD></TR>
<TR><TD ALIGN="LEFT" >+ validate(message: byte[])</TD></TR>
<TR><TD ALIGN="LEFT" >+ validate(message: ByteBuf)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

SimpleLoadManagerImpl109292786[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)SimpleLoadManagerImpl</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   availableBrokersCache: Set&lt;String&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   avgJvmHeapUsageMBytes: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   brokerCandidateCache: Set&lt;String&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   brokerHostUsage: BrokerHostUsage [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   brokerLock: ResourceLock&lt;LoadReport&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   brokerRotationCursor: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   brokerToNamespaceToBundleRange: ConcurrentOpenHashMap&lt;String, ConcurrentOpenHashMap&lt;String, ConcurrentOpenHashSet&lt;String&gt;&gt;&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   brokerTopicLoadingPredicate: BrokerTopicLoadingPredicate [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   bundleGainsCache: Set&lt;String&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   bundleLossesCache: Set&lt;String&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   currentLoadReports: Map&lt;ResourceUnit, LoadReport&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   dynamicConfigurationCache: MetadataCache&lt;Map&lt;String, String&gt;&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   forceLoadReportUpdate: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   lastLoadReport: LoadReport [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   lastResourceQuotaUpdateTimestamp: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   lastResourceUsageTimestamp: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   loadBalancingMetrics: AtomicReference&lt;List&lt;Metrics&gt;&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   loadReports: LockManager&lt;LoadReport&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   placementStrategy: PlacementStrategy [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   policies: SimpleResourceAllocationPolicies [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   pulsar: PulsarService [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   realtimeAvgResourceQuota: ResourceQuota [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   realtimeCpuLoadFactor: double [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   realtimeMemoryLoadFactor: double [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   realtimeResourceQuotas: AtomicReference&lt;Map&lt;String, ResourceQuota&gt;&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   resourceUnitRankings: Map&lt;ResourceUnit, ResourceUnitRanking&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   scheduler: ScheduledExecutorService [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   sortedRankings: AtomicReference&lt;Map&lt;Long, Set&lt;ResourceUnit&gt;&gt;&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   unloadedHotNamespaceCache: LoadingCache&lt;String, Long&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   updateRankingHandle: Future&lt;?&gt; [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ accept(n: Notification)</TD></TR>
<TR><TD ALIGN="LEFT" >- compareAndWriteQuota(bundle: String, oldQuota: ResourceQuota, newQuota: ResourceQuota)</TD></TR>
<TR><TD ALIGN="LEFT" >+ disableBroker()</TD></TR>
<TR><TD ALIGN="LEFT" >- doLoadRanking()</TD></TR>
<TR><TD ALIGN="LEFT" >+ doLoadShedding()</TD></TR>
<TR><TD ALIGN="LEFT" >+ doNamespaceBundleSplit()</TD></TR>
<TR><TD ALIGN="LEFT" >- findBrokerForPlacement(candidates: Multimap&lt;Long, ResourceUnit&gt;, serviceUnit: ServiceUnitId): ResourceUnit</TD></TR>
<TR><TD ALIGN="LEFT" >- fromLoadReport(report: LoadReport): PulsarResourceDescription</TD></TR>
<TR><TD ALIGN="LEFT" >+ generateLoadReport(): LoadReport</TD></TR>
<TR><TD ALIGN="LEFT" >- generateLoadReportForcefully(): LoadReport</TD></TR>
<TR><TD ALIGN="LEFT" >- getAvailableBrokers(serviceUnitId: ServiceUnitId): Map&lt;Long, Set&lt;ResourceUnit&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- getDynamicConfigurationBoolean(path: String, settingName: String, defaultValue: boolean): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >- getDynamicConfigurationDouble(path: String, settingName: String, defaultValue: double): double</TD></TR>
<TR><TD ALIGN="LEFT" >- getDynamicConfigurationFromStore(path: String, settingName: String, defaultValue: String): String</TD></TR>
<TR><TD ALIGN="LEFT" >- getFinalCandidates(serviceUnit: ServiceUnitId, availableBrokers: Map&lt;Long, Set&lt;ResourceUnit&gt;&gt;): Multimap&lt;Long, ResourceUnit&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getLeastLoaded(serviceUnit: ServiceUnitId): Optional&lt;ResourceUnit&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- getLeastLoadedBroker(serviceUnit: ServiceUnitId, availableBrokers: Map&lt;Long, Set&lt;ResourceUnit&gt;&gt;): ResourceUnit</TD></TR>
<TR><TD ALIGN="LEFT" >+ getResourceAvailabilityFor(serviceUnitId: ServiceUnitId): Multimap&lt;Long, ResourceUnit&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- getResourceQuota(bundle: String): ResourceQuota</TD></TR>
<TR><TD ALIGN="LEFT" >- getTotalAllocatedQuota(bundles: Set&lt;String&gt;): ResourceQuota</TD></TR>
<TR><TD ALIGN="LEFT" >+ initialize(pulsar: PulsarService)</TD></TR>
<TR><TD ALIGN="LEFT" >+ isAboveLoadLevel(usage: SystemResourceUsage, thresholdPercentage: float): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ isBelowLoadLevel(usage: SystemResourceUsage, thresholdPercentage: float): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >- isBrokerAvailableForRebalancing(bundleName: String, maxLoadLevel: long): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ start()</TD></TR>
<TR><TD ALIGN="LEFT" >+ stop()</TD></TR>
<TR><TD ALIGN="LEFT" >- timeSmoothQuota(oldQuota: ResourceQuota, msgRateIn: double, msgRateOut: double, bandwidthIn: double, bandwidthOut: double, memory: double, timePast: long): ResourceQuota</TD></TR>
<TR><TD ALIGN="LEFT" >- timeSmoothValue(oldValue: double, newSample: double, minValue: double, maxValue: double, timePast: long): double</TD></TR>
<TR><TD ALIGN="LEFT" >- unloadNamespacesFromOverLoadedBrokers(namespaceBundlesToUnload: Map&lt;ResourceUnit, String&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >- updateBrokerToNamespaceToBundle()</TD></TR>
<TR><TD ALIGN="LEFT" >- updateLoadBalancingMetrics(hostname: String, finalRank: long, ranking: ResourceUnitRanking)</TD></TR>
<TR><TD ALIGN="LEFT" >- updateRanking()</TD></TR>
<TR><TD ALIGN="LEFT" >- updateRealtimeResourceQuota()</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeLoadReportOnZookeeper()</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeResourceQuotasToZooKeeper()</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

SimpleResourceAllocationPolicies109292786[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)SimpleResourceAllocationPolicies</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   pulsar: PulsarService [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ areIsolationPoliciesPresent(namespace: NamespaceName): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ canAssign(srvUnit: ServiceUnit, rescrUnit: ResourceUnit, loadReports: Map&lt;ResourceUnit, LoadReport&gt;): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >- getIsolationPolicies(clusterName: String): Optional&lt;NamespaceIsolationPolicies&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- getNamespaceIsolationPolicy(namespace: NamespaceName): Optional&lt;NamespaceIsolationPolicy&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ isPrimaryBroker(namespace: NamespaceName, broker: String): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ isSecondaryBroker(namespace: NamespaceName, broker: String): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ isSharedBroker(broker: String): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ shouldFailoverToSecondaries(namespace: NamespaceName, totalPrimaryCandidates: int): boolean</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

SimpleResourceUnit109292786[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)SimpleResourceUnit</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   resourceDescription: ResourceDescription [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   resourceId: String [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ canFit(resourceDescription: ResourceDescription): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ compareTo(o: ResourceUnit): int</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

SingleConsumerPulsarSource1430540343[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)SingleConsumerPulsarSource&lt;T&gt;</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   consumer: Consumer&lt;T&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   functionClassLoader: ClassLoader [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   inputConsumers: List&lt;Consumer&lt;T&gt;&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   properties: Map&lt;String, String&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   pulsarClient: PulsarClient [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   pulsarSourceConfig: SingleConsumerPulsarSourceConfig [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   topicSchema: TopicSchema [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ open(config: Map&lt;String, Object&gt;, sourceContext: SourceContext)</TD></TR>
<TR><TD ALIGN="LEFT" >+ read(): Record&lt;T&gt;</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

SingleMessageMetadata297559756[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)SingleMessageMetadata</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   _bitField0: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _cachedSize: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _orderingKeyIdx: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _orderingKeyLen: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _parsedBuffer: ByteBuf [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _partitionKeyBufferIdx: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _partitionKeyBufferLen: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _propertiesCount: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   compactedOut: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   eventTime: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   nullPartitionKey: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   nullValue: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   orderingKey: ByteBuf [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   partitionKey: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   partitionKeyB64Encoded: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   payloadSize: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   properties: List&lt;KeyValue&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   sequenceId: long [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ addAllProperties(properties: Iterable&lt;KeyValue&gt;): SingleMessageMetadata</TD></TR>
<TR><TD ALIGN="LEFT" >+ addProperty(): KeyValue</TD></TR>
<TR><TD ALIGN="LEFT" >- checkRequiredFields()</TD></TR>
<TR><TD ALIGN="LEFT" >+ clear(): SingleMessageMetadata</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearCompactedOut(): SingleMessageMetadata</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearEventTime(): SingleMessageMetadata</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearNullPartitionKey(): SingleMessageMetadata</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearNullValue(): SingleMessageMetadata</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearOrderingKey(): SingleMessageMetadata</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearPartitionKey(): SingleMessageMetadata</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearPartitionKeyB64Encoded(): SingleMessageMetadata</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearPayloadSize(): SingleMessageMetadata</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearProperties(): SingleMessageMetadata</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearSequenceId(): SingleMessageMetadata</TD></TR>
<TR><TD ALIGN="LEFT" >+ copyFrom(_other: SingleMessageMetadata): SingleMessageMetadata</TD></TR>
<TR><TD ALIGN="LEFT" >+ getPropertyAt(idx: int): KeyValue</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(_buffer: ByteBuf, _size: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(a: byte[])</TD></TR>
<TR><TD ALIGN="LEFT" >+ setCompactedOut(compactedOut: boolean): SingleMessageMetadata</TD></TR>
<TR><TD ALIGN="LEFT" >+ setEventTime(eventTime: long): SingleMessageMetadata</TD></TR>
<TR><TD ALIGN="LEFT" >+ setNullPartitionKey(nullPartitionKey: boolean): SingleMessageMetadata</TD></TR>
<TR><TD ALIGN="LEFT" >+ setNullValue(nullValue: boolean): SingleMessageMetadata</TD></TR>
<TR><TD ALIGN="LEFT" >+ setOrderingKey(orderingKey: byte[]): SingleMessageMetadata</TD></TR>
<TR><TD ALIGN="LEFT" >+ setOrderingKey(orderingKey: ByteBuf): SingleMessageMetadata</TD></TR>
<TR><TD ALIGN="LEFT" >+ setPartitionKey(partitionKey: String): SingleMessageMetadata</TD></TR>
<TR><TD ALIGN="LEFT" >+ setPartitionKeyB64Encoded(partitionKeyB64Encoded: boolean): SingleMessageMetadata</TD></TR>
<TR><TD ALIGN="LEFT" >+ setPayloadSize(payloadSize: int): SingleMessageMetadata</TD></TR>
<TR><TD ALIGN="LEFT" >+ setSequenceId(sequenceId: long): SingleMessageMetadata</TD></TR>
<TR><TD ALIGN="LEFT" >+ toByteArray(): byte[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeTo(_b: ByteBuf): int</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

SinksBase229910521[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)SinksBase</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ deregisterSink(tenant: String, namespace: String, sinkName: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ getSinkConfigDefinition(name: String): List&lt;ConfigFieldDefinition&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getSinkInfo(tenant: String, namespace: String, sinkName: String): SinkConfig</TD></TR>
<TR><TD ALIGN="LEFT" >+ getSinkInstanceStatus(tenant: String, namespace: String, sinkName: String, instanceId: String): SinkInstanceStatusData</TD></TR>
<TR><TD ALIGN="LEFT" >+ getSinkStatus(tenant: String, namespace: String, sinkName: String): SinkStatus</TD></TR>
<TR><TD ALIGN="LEFT" >+ listSinks(tenant: String, namespace: String): List&lt;String&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ registerSink(tenant: String, namespace: String, sinkName: String, uploadedInputStream: InputStream, fileDetail: FormDataContentDisposition, sinkPkgUrl: String, sinkConfig: SinkConfig)</TD></TR>
<TR><TD ALIGN="LEFT" >+ reloadSinks()</TD></TR>
<TR><TD ALIGN="LEFT" >+ restartSink(tenant: String, namespace: String, sinkName: String, instanceId: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ restartSink(tenant: String, namespace: String, sinkName: String)</TD></TR>
<TR><TD ALIGN="LEFT" ># sinks(): Sinks&lt;? extends WorkerService&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ startSink(tenant: String, namespace: String, sinkName: String, instanceId: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ startSink(tenant: String, namespace: String, sinkName: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ stopSink(tenant: String, namespace: String, sinkName: String, instanceId: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ stopSink(tenant: String, namespace: String, sinkName: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ updateSink(tenant: String, namespace: String, sinkName: String, uploadedInputStream: InputStream, fileDetail: FormDataContentDisposition, sinkPkgUrl: String, sinkConfig: SinkConfig, updateOptions: UpdateOptionsImpl)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

SourcesBase229910521[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)SourcesBase</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ deregisterSource(tenant: String, namespace: String, sourceName: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ getSourceConfigDefinition(name: String): List&lt;ConfigFieldDefinition&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getSourceInfo(tenant: String, namespace: String, sourceName: String): SourceConfig</TD></TR>
<TR><TD ALIGN="LEFT" >+ getSourceInstanceStatus(tenant: String, namespace: String, sourceName: String, instanceId: String): SourceInstanceStatusData</TD></TR>
<TR><TD ALIGN="LEFT" >+ getSourceStatus(tenant: String, namespace: String, sourceName: String): SourceStatus</TD></TR>
<TR><TD ALIGN="LEFT" >+ listSources(tenant: String, namespace: String): List&lt;String&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ registerSource(tenant: String, namespace: String, sourceName: String, uploadedInputStream: InputStream, fileDetail: FormDataContentDisposition, sourcePkgUrl: String, sourceConfig: SourceConfig)</TD></TR>
<TR><TD ALIGN="LEFT" >+ reloadSources()</TD></TR>
<TR><TD ALIGN="LEFT" >+ restartSource(tenant: String, namespace: String, sourceName: String, instanceId: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ restartSource(tenant: String, namespace: String, sourceName: String)</TD></TR>
<TR><TD ALIGN="LEFT" ># sources(): Sources&lt;? extends WorkerService&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ startSource(tenant: String, namespace: String, sourceName: String, instanceId: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ startSource(tenant: String, namespace: String, sourceName: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ stopSource(tenant: String, namespace: String, sourceName: String, instanceId: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ stopSource(tenant: String, namespace: String, sourceName: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ updateSource(tenant: String, namespace: String, sourceName: String, uploadedInputStream: InputStream, fileDetail: FormDataContentDisposition, sourcePkgUrl: String, sourceConfig: SourceConfig, updateOptions: UpdateOptionsImpl)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

Stat845397418[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)Stat</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   createdBySelf: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   creationTimestamp: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   ephemeral: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   modificationTimestamp: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   path: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   version: long [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># canEqual(other: Object): boolean</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

StatsOutputStream1241162134[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)StatsOutputStream</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   separators: Stack&lt;Boolean&gt; [0..*]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- checkSeparator()</TD></TR>
<TR><TD ALIGN="LEFT" >+ endList(): StatsOutputStream</TD></TR>
<TR><TD ALIGN="LEFT" >+ endObject(): StatsOutputStream</TD></TR>
<TR><TD ALIGN="LEFT" >+ startList(): StatsOutputStream</TD></TR>
<TR><TD ALIGN="LEFT" >+ startList(key: String): StatsOutputStream</TD></TR>
<TR><TD ALIGN="LEFT" >+ startObject(): StatsOutputStream</TD></TR>
<TR><TD ALIGN="LEFT" >+ startObject(key: String): StatsOutputStream</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeItem(value: boolean): StatsOutputStream</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeItem(n: long): StatsOutputStream</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeItem(d: double): StatsOutputStream</TD></TR>
<TR><TD ALIGN="LEFT" ># writeItem(s: String): StatsOutputStream</TD></TR>
<TR><TD ALIGN="LEFT" >+ writePair(name: String, value: boolean): StatsOutputStream</TD></TR>
<TR><TD ALIGN="LEFT" >+ writePair(name: String, n: long): StatsOutputStream</TD></TR>
<TR><TD ALIGN="LEFT" >+ writePair(name: String, d: double): StatsOutputStream</TD></TR>
<TR><TD ALIGN="LEFT" >+ writePair(name: String, s: String): StatsOutputStream</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

StoredSchema1472480913[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)StoredSchema</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+   data: byte[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >+   version: SchemaVersion [0..1]</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

StreamingEntryReader679526921[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)StreamingEntryReader</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   currentReadSizeByte: AtomicInteger [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   cursor: ManagedCursorImpl [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   dispatcher: StreamingDispatcher [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   issuedReads: ConcurrentLinkedQueue&lt;PendingReadEntryRequest&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   maxReadSizeByte: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   maxRetry: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   pendingReads: ConcurrentLinkedQueue&lt;PendingReadEntryRequest&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   readFailureBackoff: Backoff [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   state: State [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   topic: PersistentTopic [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ asyncReadEntries(numEntriesToRead: int, maxReadSizeByte: long, ctx: Object)</TD></TR>
<TR><TD ALIGN="LEFT" >- cancelReadRequests(position: Position)</TD></TR>
<TR><TD ALIGN="LEFT" >+ cancelReadRequests(): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >- cleanQueue(queue: Queue&lt;PendingReadEntryRequest&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ entriesAvailable()</TD></TR>
<TR><TD ALIGN="LEFT" >- internalCancelReadRequests()</TD></TR>
<TR><TD ALIGN="LEFT" >- internalEntriesAvailable()</TD></TR>
<TR><TD ALIGN="LEFT" >- internalReadEntryComplete(entry: Entry, ctx: Object)</TD></TR>
<TR><TD ALIGN="LEFT" >- internalReadEntryFailed(exception: ManagedLedgerException, ctx: Object)</TD></TR>
<TR><TD ALIGN="LEFT" >+ readEntryComplete(entry: Entry, ctx: Object)</TD></TR>
<TR><TD ALIGN="LEFT" >+ readEntryFailed(exception: ManagedLedgerException, ctx: Object)</TD></TR>
<TR><TD ALIGN="LEFT" >- retryReadRequest(pendingReadEntryRequest: PendingReadEntryRequest, delay: long)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

StringHolder1726850686[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)StringHolder</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   idx: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   len: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   s: String [0..1]</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

StringHolder964745931[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)StringHolder</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   idx: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   len: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   s: String [0..1]</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

StringSchema1622012615[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)StringSchema</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   charset: Charset [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   schemaInfo: SchemaInfo [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ decode(bytes: byte[]): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ decode(byteBuf: ByteBuf): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ encode(message: String): byte[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ fromSchemaInfo(schemaInfo: SchemaInfo): StringSchema</TD></TR>
<TR><TD ALIGN="LEFT" >+ utf8(): StringSchema</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

StringSchemaDataValidator349782408[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)StringSchemaDataValidator</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ of(): StringSchemaDataValidator</TD></TR>
<TR><TD ALIGN="LEFT" >+ validate(schemaData: SchemaData)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

StructSchemaDataValidator349782408[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)StructSchemaDataValidator</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ of(): StructSchemaDataValidator</TD></TR>
<TR><TD ALIGN="LEFT" >- throwInvalidSchemaDataException(schemaData: SchemaData, cause: Throwable)</TD></TR>
<TR><TD ALIGN="LEFT" >+ validate(schemaData: SchemaData)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

SubscribeRateLimiter1101090806[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)SubscribeRateLimiter</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   brokerService: BrokerService [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   executorService: ScheduledExecutorService [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   resetTask: ScheduledFuture&lt;?&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   subscribeRate: SubscribeRate [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   subscribeRateLimiter: ConcurrentHashMap&lt;ConsumerIdentifier, RateLimiter&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   topicName: String [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- addSubscribeLimiterIfAbsent(consumerIdentifier: ConsumerIdentifier)</TD></TR>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >- closeAndClearRateLimiters()</TD></TR>
<TR><TD ALIGN="LEFT" >- createTask(): ScheduledFuture&lt;?&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getAvailableSubscribeRateLimit(consumerIdentifier: ConsumerIdentifier): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ getPoliciesSubscribeRate(brokerService: BrokerService, topicName: String): SubscribeRate</TD></TR>
<TR><TD ALIGN="LEFT" >+ getPoliciesSubscribeRate(cluster: String, policies: Optional&lt;Policies&gt;, topicName: String): SubscribeRate</TD></TR>
<TR><TD ALIGN="LEFT" >+ getSubscribeRatePerConsumer(consumerIdentifier: ConsumerIdentifier): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ isDispatchRateNeeded(brokerService: BrokerService, policies: Optional&lt;Policies&gt;, topicName: String): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >- isDispatchRateNeeded(serviceConfig: ServiceConfiguration, policies: Optional&lt;Policies&gt;, topicName: String): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >- isSubscribeRateEnabled(subscribeRate: SubscribeRate): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ onPoliciesUpdate(data: Policies)</TD></TR>
<TR><TD ALIGN="LEFT" >+ onSubscribeRateUpdate(subscribeRate: SubscribeRate)</TD></TR>
<TR><TD ALIGN="LEFT" >- removeSubscribeLimiter(consumerIdentifier: ConsumerIdentifier)</TD></TR>
<TR><TD ALIGN="LEFT" >- stopResetTask()</TD></TR>
<TR><TD ALIGN="LEFT" >+ subscribeAvailable(consumerIdentifier: ConsumerIdentifier): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ tryAcquire(consumerIdentifier: ConsumerIdentifier): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >- updateSubscribeRate(consumerIdentifier: ConsumerIdentifier, subscribeRate: SubscribeRate)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

Subscription297559756[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)Subscription</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   _bitField0: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _cachedSize: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _parsedBuffer: ByteBuf [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _subscriptionBufferIdx: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _subscriptionBufferLen: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _topicBufferIdx: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _topicBufferLen: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   subscription: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   topic: String [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- checkRequiredFields()</TD></TR>
<TR><TD ALIGN="LEFT" >+ clear(): Subscription</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearSubscription(): Subscription</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearTopic(): Subscription</TD></TR>
<TR><TD ALIGN="LEFT" >+ copyFrom(_other: Subscription): Subscription</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(_buffer: ByteBuf, _size: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(a: byte[])</TD></TR>
<TR><TD ALIGN="LEFT" >+ setSubscription(subscription: String): Subscription</TD></TR>
<TR><TD ALIGN="LEFT" >+ setTopic(topic: String): Subscription</TD></TR>
<TR><TD ALIGN="LEFT" >+ toByteArray(): byte[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeTo(_b: ByteBuf): int</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

SubscriptionBusyException1254029274[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)SubscriptionBusyException</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

SubscriptionFencedException1254029274[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)SubscriptionFencedException</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

SubscriptionInvalidCursorPosition1254029274[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)SubscriptionInvalidCursorPosition</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

SubscriptionNotFoundException1254029274[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)SubscriptionNotFoundException</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

SubscriptionOption1718290011[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)SubscriptionOption</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   cnx: TransportCnx [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   consumerEpoch: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   consumerId: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   consumerName: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   initialPosition: InitialPosition [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   isDurable: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   keySharedMeta: KeySharedMeta [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   metadata: Map&lt;String, String&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   priorityLevel: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   readCompacted: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   replicatedSubscriptionStateArg: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   startMessageId: MessageId [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   startMessageRollbackDurationSec: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   subType: SubType [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   subscriptionName: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   subscriptionProperties: Optional&lt;Map&lt;String, String&gt;&gt; [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ builder(): SubscriptionOptionBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ getPropertiesMap(list: List&lt;KeyValue&gt;): Optional&lt;Map&lt;String, String&gt;&gt;</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

SubscriptionStatsImpl2018762865[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)SubscriptionStatsImpl</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+   activeConsumerName: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   allowOutOfOrderDelivery: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   backlogSize: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   blockedSubscriptionOnUnackedMsgs: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   bytesOutCounter: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   chunkedMessageRate: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   consumers: List&lt;ConsumerStatsImpl&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >+   consumersAfterMarkDeletePosition: Map&lt;String, String&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >+   earliestMsgPublishTimeInBacklog: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   isDurable: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   isReplicated: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   keySharedMode: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   lastAckedTimestamp: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   lastConsumedFlowTimestamp: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   lastConsumedTimestamp: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   lastExpireTimestamp: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   lastMarkDeleteAdvancedTimestamp: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   msgBacklog: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   msgBacklogNoDelayed: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   msgDelayed: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   msgOutCounter: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   msgRateExpired: double [1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   msgRateOut: double [1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   msgRateRedeliver: double [1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   msgThroughputOut: double [1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   nonContiguousDeletedMessagesRanges: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   nonContiguousDeletedMessagesRangesSerializedSize: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   subscriptionProperties: Map&lt;String, String&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >+   totalMsgExpired: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   type: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   unackedMessages: long [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ add(stats: SubscriptionStatsImpl): SubscriptionStatsImpl</TD></TR>
<TR><TD ALIGN="LEFT" ># canEqual(other: Object): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ reset()</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

Summary1852472696[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)Summary</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   quantiles: List&lt;Double&gt; [0..*]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ build(name: String, help: String): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ build(): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ collect(): List&lt;MetricFamilySamples&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ describe(): List&lt;MetricFamilySamples&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># newChild(): Child</TD></TR>
<TR><TD ALIGN="LEFT" >+ observe(eventLatency: long, unit: TimeUnit)</TD></TR>
<TR><TD ALIGN="LEFT" >+ rotateLatencyCollection()</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

SystemTopic1101090806[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)SystemTopic</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ checkGC()</TD></TR>
<TR><TD ALIGN="LEFT" >+ checkMessageExpiry()</TD></TR>
<TR><TD ALIGN="LEFT" >+ checkReplication(): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ checkTimeBacklogExceeded(): CompletableFuture&lt;Boolean&gt;</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

SystemTopicBasedTopicPoliciesService1718290011[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)SystemTopicBasedTopicPoliciesService</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   clusterName: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   globalPoliciesCache: Map&lt;TopicName, TopicPolicies&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >#   listeners: Map&lt;TopicName, List&lt;TopicPolicyListener&lt;TopicPolicies&gt;&gt;&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   localCluster: HashSet [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   namespaceEventsSystemTopicFactory: NamespaceEventsSystemTopicFactory [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   ownedBundlesCountPerNamespace: Map&lt;NamespaceName, AtomicInteger&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >#   policiesCache: Map&lt;TopicName, TopicPolicies&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >#   policyCacheInitMap: Map&lt;NamespaceName, Boolean&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   pulsarService: PulsarService [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   readerCaches: Map&lt;NamespaceName, CompletableFuture&lt;Reader&lt;PulsarEvent&gt;&gt;&gt; [0..*]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ addOwnedNamespaceBundleAsync(namespaceBundle: NamespaceBundle): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># checkReaderIsCached(namespaceName: NamespaceName): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >- cleanCacheAndCloseReader(namespace: NamespaceName, cleanOwnedBundlesCount: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" ># createSystemTopicClientWithRetry(namespace: NamespaceName): CompletableFuture&lt;Reader&lt;PulsarEvent&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- createSystemTopicFactoryIfNeeded()</TD></TR>
<TR><TD ALIGN="LEFT" >+ deleteTopicPoliciesAsync(topicName: TopicName): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- fetchTopicPoliciesAsyncAndCloseReader(reader: Reader&lt;PulsarEvent&gt;, topicName: TopicName, policies: TopicPolicies, future: CompletableFuture&lt;TopicPolicies&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ getPoliciesCacheInit(namespaceName: NamespaceName): Boolean</TD></TR>
<TR><TD ALIGN="LEFT" >- getPulsarEvent(topicName: TopicName, actionType: ActionType, policies: TopicPolicies): PulsarEvent</TD></TR>
<TR><TD ALIGN="LEFT" >+ getTopicPolicies(topicName: TopicName): TopicPolicies</TD></TR>
<TR><TD ALIGN="LEFT" >+ getTopicPolicies(topicName: TopicName, isGlobal: boolean): TopicPolicies</TD></TR>
<TR><TD ALIGN="LEFT" >+ getTopicPoliciesBypassCacheAsync(topicName: TopicName): CompletableFuture&lt;TopicPolicies&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getTopicPoliciesIfExists(topicName: TopicName): TopicPolicies</TD></TR>
<TR><TD ALIGN="LEFT" >- hasReplicateTo(message: Message&lt;?&gt;): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >- initPolicesCache(reader: Reader&lt;PulsarEvent&gt;, future: CompletableFuture&lt;Void&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >- notifyListener(msg: Message&lt;PulsarEvent&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >- prepareInitPoliciesCache(namespace: NamespaceName, result: CompletableFuture&lt;Void&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >- readMorePolicies(reader: Reader&lt;PulsarEvent&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >- refreshTopicPoliciesCache(msg: Message&lt;PulsarEvent&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ registerListener(topicName: TopicName, listener: TopicPolicyListener&lt;TopicPolicies&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ removeOwnedNamespaceBundleAsync(namespaceBundle: NamespaceBundle): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- sendTopicPolicyEvent(topicName: TopicName, actionType: ActionType, policies: TopicPolicies): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ start()</TD></TR>
<TR><TD ALIGN="LEFT" >+ unregisterListener(topicName: TopicName, listener: TopicPolicyListener&lt;TopicPolicies&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ updateTopicPoliciesAsync(topicName: TopicName, policies: TopicPolicies): CompletableFuture&lt;Void&gt;</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

SystemTopicClientBase1970406500[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)SystemTopicClientBase&lt;T&gt;</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   client: PulsarClient [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   readers: List&lt;Reader&lt;T&gt;&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >#   topicName: TopicName [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   writers: List&lt;Writer&lt;T&gt;&gt; [0..*]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ closeAsync(): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ newReader(): Reader&lt;T&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ newReaderAsync(): CompletableFuture&lt;Reader&lt;T&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># newReaderAsyncInternal(): CompletableFuture&lt;Reader&lt;T&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ newWriter(): Writer&lt;T&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ newWriterAsync(): CompletableFuture&lt;Writer&lt;T&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># newWriterAsyncInternal(): CompletableFuture&lt;Writer&lt;T&gt;&gt;</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

TableViewImpl12001400[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)TableViewImpl&lt;T&gt;</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   client: PulsarClientImpl [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   conf: TableViewConfigurationData [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   data: ConcurrentMap&lt;String, T&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   listeners: List&lt;BiConsumer&lt;String, T&gt;&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   listenersMutex: ReentrantLock [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   readers: ConcurrentMap&lt;String, Reader&lt;T&gt;&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   schema: Schema&lt;T&gt; [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- checkForPartitionsChanges(timeout: Timeout)</TD></TR>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ closeAsync(): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ containsKey(key: String): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ entrySet(): Set&lt;Entry&lt;String, T&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ forEach(action: BiConsumer&lt;String, T&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ forEachAndListen(action: BiConsumer&lt;String, T&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ get(key: String): T</TD></TR>
<TR><TD ALIGN="LEFT" >- handleMessage(msg: Message&lt;T&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ keySet(): Set&lt;String&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- newReader(partition: String): CompletableFuture&lt;Reader&lt;T&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- readAllExistingMessages(reader: Reader&lt;T&gt;): CompletableFuture&lt;Reader&lt;T&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- readAllExistingMessages(reader: Reader&lt;T&gt;, future: CompletableFuture&lt;Reader&lt;T&gt;&gt;, startTime: long, messagesRead: AtomicLong)</TD></TR>
<TR><TD ALIGN="LEFT" >- readTailMessages(reader: Reader&lt;T&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >- schedulePartitionsCheck()</TD></TR>
<TR><TD ALIGN="LEFT" >+ size(): int</TD></TR>
<TR><TD ALIGN="LEFT" ># start(): CompletableFuture&lt;TableView&lt;T&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ values(): Collection&lt;T&gt;</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

TenantInfoImpl896442176[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)TenantInfoImpl</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   adminRoles: Set&lt;String&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   allowedClusters: Set&lt;String&gt; [0..*]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ builder(): TenantInfoImplBuilder</TD></TR>
<TR><TD ALIGN="LEFT" ># canEqual(other: Object): boolean</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

TenantResources220376139[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)TenantResources</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ createTenant(tenantName: String, ti: TenantInfo)</TD></TR>
<TR><TD ALIGN="LEFT" >+ createTenantAsync(tenantName: String, ti: TenantInfo): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ deleteTenantAsync(tenantName: String): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getActiveNamespaces(tenant: String, cluster: String): CompletableFuture&lt;List&lt;String&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getListOfNamespaces(tenant: String): List&lt;String&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getTenant(tenantName: String): Optional&lt;TenantInfo&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getTenantAsync(tenantName: String): CompletableFuture&lt;Optional&lt;TenantInfo&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ hasActiveNamespace(tenant: String): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ listTenants(): List&lt;String&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ listTenantsAsync(): CompletableFuture&lt;List&lt;String&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ tenantExists(tenantName: String): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ tenantExistsAsync(tenantName: String): CompletableFuture&lt;Boolean&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ updateTenantAsync(tenantName: String, f: Function&lt;TenantInfo, TenantInfo&gt;): CompletableFuture&lt;Void&gt;</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

Tenants620988779[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)Tenants</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

TenantsBase229910521[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)TenantsBase</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ createTenant(asyncResponse: AsyncResponse, tenant: String, tenantInfo: TenantInfoImpl)</TD></TR>
<TR><TD ALIGN="LEFT" >+ deleteTenant(asyncResponse: AsyncResponse, tenant: String, force: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ getTenantAdmin(asyncResponse: AsyncResponse, tenant: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ getTenants(asyncResponse: AsyncResponse)</TD></TR>
<TR><TD ALIGN="LEFT" ># internalDeleteTenant(asyncResponse: AsyncResponse, tenant: String, force: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" ># internalDeleteTenant(asyncResponse: AsyncResponse, tenant: String)</TD></TR>
<TR><TD ALIGN="LEFT" ># internalDeleteTenantForcefully(asyncResponse: AsyncResponse, tenant: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ updateTenant(asyncResponse: AsyncResponse, tenant: String, newTenantAdmin: TenantInfoImpl)</TD></TR>
<TR><TD ALIGN="LEFT" >- validateClusters(info: TenantInfo)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

TenantsImpl1292556772[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)TenantsImpl</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   adminTenants: WebTarget [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ createProperty(tenant: String, config: TenantInfo)</TD></TR>
<TR><TD ALIGN="LEFT" >+ createTenant(tenant: String, config: TenantInfo)</TD></TR>
<TR><TD ALIGN="LEFT" >+ createTenantAsync(tenant: String, config: TenantInfo): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ deleteProperty(tenant: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ deleteTenant(tenant: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ deleteTenant(tenant: String, force: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ deleteTenantAsync(tenant: String): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ deleteTenantAsync(tenant: String, force: boolean): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getPropertyAdmin(tenant: String): TenantInfo</TD></TR>
<TR><TD ALIGN="LEFT" >+ getTenantInfo(tenant: String): TenantInfo</TD></TR>
<TR><TD ALIGN="LEFT" >+ getTenantInfoAsync(tenant: String): CompletableFuture&lt;TenantInfo&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ updateProperty(tenant: String, config: TenantInfo)</TD></TR>
<TR><TD ALIGN="LEFT" >+ updateTenant(tenant: String, config: TenantInfo)</TD></TR>
<TR><TD ALIGN="LEFT" >+ updateTenantAsync(tenant: String, config: TenantInfo): CompletableFuture&lt;Void&gt;</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

TimeAverageMessageData724302956[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)TimeAverageMessageData</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   maxSamples: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   msgRateIn: double [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   msgRateOut: double [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   msgThroughputIn: double [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   msgThroughputOut: double [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   numSamples: int [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- getUpdatedValue(oldAverage: double, newSample: double): double</TD></TR>
<TR><TD ALIGN="LEFT" >+ totalMsgRate(): double</TD></TR>
<TR><TD ALIGN="LEFT" >+ totalMsgThroughput(): double</TD></TR>
<TR><TD ALIGN="LEFT" >+ update(newMsgThroughputIn: double, newMsgThroughputOut: double, newMsgRateIn: double, newMsgRateOut: double)</TD></TR>
<TR><TD ALIGN="LEFT" >+ update(newSample: NamespaceBundleStats)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

TimeSchema1622012615[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)TimeSchema</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ decode(bytes: byte[]): Time</TD></TR>
<TR><TD ALIGN="LEFT" >+ decode(byteBuf: ByteBuf): Time</TD></TR>
<TR><TD ALIGN="LEFT" >+ encode(message: Time): byte[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ of(): TimeSchema</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

TimestampSchema1622012615[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)TimestampSchema</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ decode(bytes: byte[]): Timestamp</TD></TR>
<TR><TD ALIGN="LEFT" >+ decode(byteBuf: ByteBuf): Timestamp</TD></TR>
<TR><TD ALIGN="LEFT" >+ encode(message: Timestamp): byte[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ of(): TimestampSchema</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

TokenAuthenticationState588253940[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)TokenAuthenticationState</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   authenticationDataSource: AuthenticationDataSource [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   expiration: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   jwt: Jwt&lt;?, Claims&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   provider: AuthenticationProviderToken [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   remoteAddress: SocketAddress [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   sslSession: SSLSession [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ authenticate(authData: AuthData): AuthData</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

TooManyRequestsException1254029274[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)TooManyRequestsException</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

TopicBacklogQuotaExceededException1254029274[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)TopicBacklogQuotaExceededException</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   retentionPolicy: RetentionPolicy [0..1]</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

TopicBusyException1254029274[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)TopicBusyException</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

TopicClosedException1254029274[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)TopicClosedException</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

TopicFencedException1254029274[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)TopicFencedException</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

TopicLoadingContext704824873[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)TopicLoadingContext</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   properties: Map&lt;String, String&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   topic: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   topicFuture: CompletableFuture&lt;Optional&lt;Topic&gt;&gt; [0..1]</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

TopicLookup941238890[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)TopicLookup</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ getNamespaceBundle(topicDomain: String, tenant: String, namespace: String, encodedTopic: String): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ lookupTopicAsync(topicDomain: String, tenant: String, namespace: String, encodedTopic: String, authoritative: boolean, asyncResponse: AsyncResponse, listenerName: String, listenerNameHeader: String)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

TopicLookupBase967123692[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)TopicLookupBase</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- completeLookupResponseExceptionally(asyncResponse: AsyncResponse, t: Throwable)</TD></TR>
<TR><TD ALIGN="LEFT" >- completeLookupResponseSuccessfully(asyncResponse: AsyncResponse, lookupData: LookupData)</TD></TR>
<TR><TD ALIGN="LEFT" ># getTopicName(topicDomain: String, tenant: String, cluster: String, namespace: String, encodedTopic: String): TopicName</TD></TR>
<TR><TD ALIGN="LEFT" ># getTopicName(topicDomain: String, tenant: String, namespace: String, encodedTopic: String): TopicName</TD></TR>
<TR><TD ALIGN="LEFT" ># internalGetNamespaceBundle(topicName: TopicName): String</TD></TR>
<TR><TD ALIGN="LEFT" ># internalLookupTopicAsync(topicName: TopicName, authoritative: boolean, asyncResponse: AsyncResponse, listenerName: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ lookupTopicAsync(pulsarService: PulsarService, topicName: TopicName, authoritative: boolean, clientAppId: String, authenticationData: AuthenticationDataSource, requestId: long): CompletableFuture&lt;ByteBuf&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ lookupTopicAsync(pulsarService: PulsarService, topicName: TopicName, authoritative: boolean, clientAppId: String, authenticationData: AuthenticationDataSource, requestId: long, advertisedListenerName: String): CompletableFuture&lt;ByteBuf&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- shouldRedirectThroughServiceUrl(conf: ServiceConfiguration, lookupData: LookupData): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >- validateAdminAndClientPermission(topic: TopicName)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

TopicMessageIdImpl12001400[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)TopicMessageIdImpl</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   messageId: MessageId [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   topicName: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   topicPartitionName: String [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ compareTo(o: MessageId): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ toByteArray(): byte[]</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

TopicMessageImpl12001400[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)TopicMessageImpl&lt;T&gt;</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   messageId: TopicMessageIdImpl [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   msg: Message&lt;T&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   receivedByconsumer: ConsumerImpl [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   topicPartitionName: String [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ getProperty(name: String): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ hasProperty(name: String): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ release()</TD></TR>
<TR><TD ALIGN="LEFT" >+ size(): int</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

TopicName1973581360[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)TopicName</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   cluster: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   completeTopicName: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   domain: TopicDomain [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   localName: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   namespaceName: NamespaceName [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   namespacePortion: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   partitionIndex: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   tenant: String [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ get(domain: String, namespaceName: NamespaceName, topic: String): TopicName</TD></TR>
<TR><TD ALIGN="LEFT" >+ get(domain: String, tenant: String, namespace: String, topic: String): TopicName</TD></TR>
<TR><TD ALIGN="LEFT" >+ get(domain: String, tenant: String, cluster: String, namespace: String, topic: String): TopicName</TD></TR>
<TR><TD ALIGN="LEFT" >+ get(topic: String): TopicName</TD></TR>
<TR><TD ALIGN="LEFT" >+ getPartition(index: int): TopicName</TD></TR>
<TR><TD ALIGN="LEFT" >+ getPartitionIndex(topic: String): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ getPartitionedTopicName(topic: String): TopicName</TD></TR>
<TR><TD ALIGN="LEFT" >+ getRestPath(includeDomain: boolean): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ includes(otherTopicName: TopicName): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ isValid(topic: String): boolean</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

TopicNotFoundException1254029274[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)TopicNotFoundException</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

TopicPolicies896442176[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)TopicPolicies</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   backLogQuotaMap: Map&lt;String, BacklogQuotaImpl&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   compactionThreshold: Long [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   deduplicationEnabled: Boolean [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   deduplicationSnapshotIntervalSeconds: Integer [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   delayedDeliveryEnabled: Boolean [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   delayedDeliveryTickTimeMillis: Long [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   dispatchRate: DispatchRateImpl [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   inactiveTopicPolicies: InactiveTopicPolicies [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   isGlobal: Boolean [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   maxConsumerPerTopic: Integer [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   maxConsumersPerSubscription: Integer [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   maxMessageSize: Integer [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   maxProducerPerTopic: Integer [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   maxSubscriptionsPerTopic: Integer [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   maxUnackedMessagesOnConsumer: Integer [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   maxUnackedMessagesOnSubscription: Integer [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   messageTTLInSeconds: Integer [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   offloadPolicies: OffloadPoliciesImpl [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   persistence: PersistencePolicies [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   publishRate: PublishRate [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   replicationClusters: List&lt;String&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   replicatorDispatchRate: DispatchRateImpl [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   retentionPolicies: RetentionPolicies [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   schemaCompatibilityStrategy: SchemaCompatibilityStrategy [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   subscribeRate: SubscribeRate [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   subscriptionDispatchRate: DispatchRateImpl [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   subscriptionTypesEnabled: List&lt;SubType&gt; [0..*]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- $default$backLogQuotaMap(): Map&lt;String, BacklogQuotaImpl&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- $default$subscriptionTypesEnabled(): List&lt;SubType&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ builder(): TopicPoliciesBuilder</TD></TR>
<TR><TD ALIGN="LEFT" ># canEqual(other: Object): boolean</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

TopicPoliciesCacheNotInitException1254029274[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)TopicPoliciesCacheNotInitException</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

TopicPoliciesEvent2082884193[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)TopicPoliciesEvent</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   domain: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   namespace: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   policies: TopicPolicies [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   tenant: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   topic: String [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ builder(): TopicPoliciesEventBuilder</TD></TR>
<TR><TD ALIGN="LEFT" ># canEqual(other: Object): boolean</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

TopicPoliciesServiceDisabled1529889815[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)TopicPoliciesServiceDisabled</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ addOwnedNamespaceBundleAsync(namespaceBundle: NamespaceBundle): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ deleteTopicPoliciesAsync(topicName: TopicName): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getTopicPolicies(topicName: TopicName): TopicPolicies</TD></TR>
<TR><TD ALIGN="LEFT" >+ getTopicPolicies(topicName: TopicName, isGlobal: boolean): TopicPolicies</TD></TR>
<TR><TD ALIGN="LEFT" >+ getTopicPoliciesBypassCacheAsync(topicName: TopicName): CompletableFuture&lt;TopicPolicies&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getTopicPoliciesIfExists(topicName: TopicName): TopicPolicies</TD></TR>
<TR><TD ALIGN="LEFT" >+ registerListener(topicName: TopicName, listener: TopicPolicyListener&lt;TopicPolicies&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ removeOwnedNamespaceBundleAsync(namespaceBundle: NamespaceBundle): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ start()</TD></TR>
<TR><TD ALIGN="LEFT" >+ unregisterListener(topicName: TopicName, listener: TopicPolicyListener&lt;TopicPolicies&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ updateTopicPoliciesAsync(topicName: TopicName, policies: TopicPolicies): CompletableFuture&lt;Void&gt;</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

TopicPoliciesSystemTopicClient1970406500[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)TopicPoliciesSystemTopicClient</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># newReaderAsyncInternal(): CompletableFuture&lt;Reader&lt;PulsarEvent&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># newWriterAsyncInternal(): CompletableFuture&lt;Writer&lt;PulsarEvent&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- validateActionType(event: PulsarEvent)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

TopicPolicyReader1851406594[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)TopicPolicyReader</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   reader: Reader&lt;PulsarEvent&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   systemTopic: TopicPoliciesSystemTopicClient [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ closeAsync(): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ readNext(): Message&lt;PulsarEvent&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ readNextAsync(): CompletableFuture&lt;Message&lt;PulsarEvent&gt;&gt;</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

TopicPolicyWriter1851406594[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)TopicPolicyWriter</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   producer: Producer&lt;PulsarEvent&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   systemTopicClient: SystemTopicClient&lt;PulsarEvent&gt; [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ closeAsync(): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ delete(event: PulsarEvent): MessageId</TD></TR>
<TR><TD ALIGN="LEFT" >+ deleteAsync(event: PulsarEvent): CompletableFuture&lt;MessageId&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- getEventKey(event: PulsarEvent): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ write(event: PulsarEvent): MessageId</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeAsync(event: PulsarEvent): CompletableFuture&lt;MessageId&gt;</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

TopicResources220376139[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)TopicResources</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   store: MetadataStore [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ clearDomainPersistence(ns: NamespaceName): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearNamespacePersistence(ns: NamespaceName): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearTenantPersistence(tenant: String): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ createPersistentTopicAsync(topic: TopicName): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ deletePersistentTopicAsync(topic: TopicName): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getExistingPartitions(topic: TopicName): CompletableFuture&lt;List&lt;String&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getExistingPartitions(ns: NamespaceName, domain: TopicDomain): CompletableFuture&lt;List&lt;String&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ listPersistentTopicsAsync(ns: NamespaceName): CompletableFuture&lt;List&lt;String&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ persistentTopicExists(topic: TopicName): CompletableFuture&lt;Boolean&gt;</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

TopicStatsImpl2018762865[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)TopicStatsImpl</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+   averageMsgSize: double [1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   backlogSize: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   bytesInCounter: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   bytesOutCounter: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   compaction: CompactionStatsImpl [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   count: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   deduplicationStatus: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   earliestMsgPublishTimeInBacklogs: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   lastOffloadFailureTimeStamp: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   lastOffloadLedgerId: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   lastOffloadSuccessTimeStamp: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   msgChunkPublished: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   msgInCounter: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   msgOutCounter: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   msgRateIn: double [1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   msgRateOut: double [1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   msgThroughputIn: double [1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   msgThroughputOut: double [1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   nonContiguousDeletedMessagesRanges: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   nonContiguousDeletedMessagesRangesSerializedSize: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   offloadedStorageSize: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   publishRateLimitedTimes: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   publishers: List&lt;PublisherStatsImpl&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   publishersMap: Map&lt;String, PublisherStatsImpl&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >+   replication: Map&lt;String, ReplicatorStatsImpl&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >+   storageSize: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   subscriptions: Map&lt;String, SubscriptionStatsImpl&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >+   topicEpoch: Long [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   waitingPublishers: int [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ add(ts: TopicStats): TopicStatsImpl</TD></TR>
<TR><TD ALIGN="LEFT" >+ addPublisher(stats: PublisherStatsImpl)</TD></TR>
<TR><TD ALIGN="LEFT" ># canEqual(other: Object): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ reset()</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

TopicTerminatedException1254029274[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)TopicTerminatedException</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

TopicTransactionBuffer1621168036[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)TopicTransactionBuffer</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   aborts: LinkedMap&lt;TxnID, PositionImpl&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   changeMaxReadPositionAndAddAbortTimes: AtomicLong [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   lastSnapshotTimestamps: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   maxReadPosition: PositionImpl [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   ongoingTxns: LinkedMap&lt;TxnID, PositionImpl&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   takeSnapshotIntervalNumber: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   takeSnapshotIntervalTime: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   takeSnapshotWriter: CompletableFuture&lt;Writer&lt;TransactionBufferSnapshot&gt;&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   timer: Timer [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   topic: PersistentTopic [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   transactionBufferFuture: CompletableFuture&lt;Void&gt; [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ abortTxn(txnID: TxnID, lowWaterMark: long): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ appendBufferToTxn(txnId: TxnID, sequenceId: long, buffer: ByteBuf): CompletableFuture&lt;Position&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ checkIfTBRecoverCompletely(isTxnEnabled: boolean): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- clearAbortedTransactions()</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearSnapshot(): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ closeAsync(): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ commitTxn(txnID: TxnID, lowWaterMark: long): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getTransactionInBufferStats(txnID: TxnID): TransactionInBufferStats</TD></TR>
<TR><TD ALIGN="LEFT" >+ getTransactionMeta(txnID: TxnID): CompletableFuture&lt;TransactionMeta&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- handleLowWaterMark(txnID: TxnID, lowWaterMark: long)</TD></TR>
<TR><TD ALIGN="LEFT" >- handleTransactionMessage(txnId: TxnID, position: Position)</TD></TR>
<TR><TD ALIGN="LEFT" >+ isTxnAborted(txnID: TxnID): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ openTransactionBufferReader(txnID: TxnID, startSequenceId: long): CompletableFuture&lt;TransactionBufferReader&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ purgeTxns(dataLedgers: List&lt;Long&gt;): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- recover()</TD></TR>
<TR><TD ALIGN="LEFT" >+ run(timeout: Timeout)</TD></TR>
<TR><TD ALIGN="LEFT" >+ syncMaxReadPositionForNormalPublish(position: PositionImpl)</TD></TR>
<TR><TD ALIGN="LEFT" >- takeSnapshot(): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- takeSnapshotByChangeTimes()</TD></TR>
<TR><TD ALIGN="LEFT" >- takeSnapshotByTimeout()</TD></TR>
<TR><TD ALIGN="LEFT" ># updateMaxReadPosition(txnID: TxnID)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

TopicTransactionBufferRecover230463737[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)TopicTransactionBufferRecover</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   callBack: TopicTransactionBufferRecoverCallBack [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   entryQueue: SpscArrayQueue&lt;Entry&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   exceptionNumber: AtomicLong [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   startReadCursorPosition: Position [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   topic: PersistentTopic [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   topicTransactionBuffer: TopicTransactionBuffer [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- callBackException(e: ManagedLedgerException)</TD></TR>
<TR><TD ALIGN="LEFT" >- closeCursor(cursor: ManagedCursor)</TD></TR>
<TR><TD ALIGN="LEFT" >+ run()</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

TopicTransactionBufferState1621168036[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)TopicTransactionBufferState</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   state: State [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># changeToCloseState()</TD></TR>
<TR><TD ALIGN="LEFT" ># changeToInitializingState(): boolean</TD></TR>
<TR><TD ALIGN="LEFT" ># changeToNoSnapshotState(): boolean</TD></TR>
<TR><TD ALIGN="LEFT" ># changeToReadyState(): boolean</TD></TR>
<TR><TD ALIGN="LEFT" ># changeToReadyStateFromNoSnapshot(): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ checkIfNoSnapshot(): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ checkIfReady(): boolean</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

Topics763407854[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)Topics</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ produceOnNonPersistentTopic(asyncResponse: AsyncResponse, tenant: String, namespace: String, encodedTopic: String, authoritative: boolean, producerMessages: ProducerMessages)</TD></TR>
<TR><TD ALIGN="LEFT" >+ produceOnNonPersistentTopicPartition(asyncResponse: AsyncResponse, tenant: String, namespace: String, encodedTopic: String, partition: int, authoritative: boolean, producerMessages: ProducerMessages)</TD></TR>
<TR><TD ALIGN="LEFT" >+ produceOnPersistentTopic(asyncResponse: AsyncResponse, tenant: String, namespace: String, encodedTopic: String, authoritative: boolean, producerMessages: ProducerMessages)</TD></TR>
<TR><TD ALIGN="LEFT" >+ produceOnPersistentTopicPartition(asyncResponse: AsyncResponse, tenant: String, namespace: String, encodedTopic: String, partition: int, authoritative: boolean, producerMessages: ProducerMessages)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

TopicsBase763407854[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)TopicsBase</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- addOrGetSchemaForTopic(schemaData: SchemaData, schemaVersion: LongSchemaVersion): CompletableFuture&lt;Pair&lt;SchemaData, SchemaVersion&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- addSchema(schemaData: SchemaData): CompletableFuture&lt;SchemaVersion&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- buildMessage(producerMessages: ProducerMessages, schema: Schema, producerName: String, topicName: TopicName): List&lt;Message&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- completeLookup(result: Pair&lt;List&lt;String&gt;, Boolean&gt;, redirectAddresses: List&lt;String&gt;, future: CompletableFuture&lt;Void&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >- encodeWithSchema(input: String, schema: Schema): byte[]</TD></TR>
<TR><TD ALIGN="LEFT" >- extractException(e: Exception, produceMessageResult: ProducerAck)</TD></TR>
<TR><TD ALIGN="LEFT" >- findOwnerBrokerForTopic(authoritative: boolean, asyncResponse: AsyncResponse): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >- getSchemaData(keySchema: String, valueSchema: String): SchemaData</TD></TR>
<TR><TD ALIGN="LEFT" >- internalPublishMessages(topicName: TopicName, request: ProducerMessages, partitionIndexes: List&lt;Integer&gt;, asyncResponse: AsyncResponse, schema: Schema, schemaVersion: SchemaVersion)</TD></TR>
<TR><TD ALIGN="LEFT" >- internalPublishMessagesToPartition(topicName: TopicName, request: ProducerMessages, partition: int, asyncResponse: AsyncResponse, schema: Schema, schemaVersion: SchemaVersion)</TD></TR>
<TR><TD ALIGN="LEFT" >- lookUpBrokerForTopic(partitionedTopicName: TopicName, authoritative: boolean, redirectAddresses: List&lt;String&gt;): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ messageToByteBuf(message: Message): ByteBuf</TD></TR>
<TR><TD ALIGN="LEFT" >- processLookUpResult(redirectAddresses: List&lt;String&gt;, asyncResponse: AsyncResponse, future: CompletableFuture&lt;Boolean&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >- processPublishMessageResults(produceMessageResults: List&lt;ProducerAck&gt;, publishResults: List&lt;CompletableFuture&lt;PositionImpl&gt;&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" ># publishMessages(asyncResponse: AsyncResponse, request: ProducerMessages, authoritative: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" ># publishMessagesToPartition(asyncResponse: AsyncResponse, request: ProducerMessages, authoritative: boolean, partition: int)</TD></TR>
<TR><TD ALIGN="LEFT" >- publishSingleMessageToPartition(topic: String, message: Message): CompletableFuture&lt;PositionImpl&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ validateProducePermission()</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

TopicsImpl1292556772[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)TopicsImpl</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   adminTopics: WebTarget [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   adminV2Topics: WebTarget [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ compactionStatus(topic: String): LongRunningProcessStatus</TD></TR>
<TR><TD ALIGN="LEFT" >+ compactionStatusAsync(topic: String): CompletableFuture&lt;LongRunningProcessStatus&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ createMissedPartitions(topic: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ createMissedPartitionsAsync(topic: String): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ createNonPartitionedTopic(topic: String, metadata: Map&lt;String, String&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ createNonPartitionedTopicAsync(topic: String, properties: Map&lt;String, String&gt;): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ createPartitionedTopic(topic: String, numPartitions: int, metadata: Map&lt;String, String&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ createPartitionedTopicAsync(topic: String, numPartitions: int, properties: Map&lt;String, String&gt;): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ createPartitionedTopicAsync(topic: String, numPartitions: int, createLocalTopicOnly: boolean, properties: Map&lt;String, String&gt;): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ createSubscription(topic: String, subscriptionName: String, messageId: MessageId)</TD></TR>
<TR><TD ALIGN="LEFT" >+ createSubscriptionAsync(topic: String, subscriptionName: String, messageId: MessageId): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ delete(topic: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ delete(topic: String, force: boolean, deleteSchema: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ deleteAsync(topic: String): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ deleteAsync(topic: String, force: boolean, deleteSchema: boolean): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ deletePartitionedTopic(topic: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ deletePartitionedTopic(topic: String, force: boolean, deleteSchema: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ deletePartitionedTopicAsync(topic: String): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ deletePartitionedTopicAsync(topic: String, force: boolean, deleteSchema: boolean): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ deleteSubscription(topic: String, subName: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ deleteSubscription(topic: String, subName: String, force: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ deleteSubscriptionAsync(topic: String, subName: String): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ deleteSubscriptionAsync(topic: String, subName: String, force: boolean): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ disableDeduplication(topic: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ disableDeduplicationAsync(topic: String): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ enableDeduplication(topic: String, enabled: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ enableDeduplicationAsync(topic: String, enabled: boolean): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ examineMessage(topic: String, initialPosition: String, messagePosition: long): Message&lt;byte[]&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ examineMessageAsync(topic: String, initialPosition: String, messagePosition: long): CompletableFuture&lt;Message&lt;byte[]&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ expireMessages(topic: String, subName: String, expireTimeInSeconds: long)</TD></TR>
<TR><TD ALIGN="LEFT" >+ expireMessages(topic: String, subscriptionName: String, messageId: MessageId, isExcluded: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ expireMessagesAsync(topic: String, subName: String, expireTimeInSeconds: long): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ expireMessagesAsync(topic: String, subscriptionName: String, messageId: MessageId, isExcluded: boolean): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ expireMessagesForAllSubscriptions(topic: String, expireTimeInSeconds: long)</TD></TR>
<TR><TD ALIGN="LEFT" >+ expireMessagesForAllSubscriptionsAsync(topic: String, expireTimeInSeconds: long): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getBacklogQuotaMap(topic: String): Map&lt;BacklogQuotaType, BacklogQuota&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getBacklogQuotaMap(topic: String, applied: boolean): Map&lt;BacklogQuotaType, BacklogQuota&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getBacklogSizeByMessageId(topic: String, messageId: MessageId): Long</TD></TR>
<TR><TD ALIGN="LEFT" >+ getBacklogSizeByMessageIdAsync(topic: String, messageId: MessageId): CompletableFuture&lt;Long&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getCompactionThreshold(topic: String): Long</TD></TR>
<TR><TD ALIGN="LEFT" >+ getCompactionThreshold(topic: String, applied: boolean): Long</TD></TR>
<TR><TD ALIGN="LEFT" >+ getCompactionThresholdAsync(topic: String): CompletableFuture&lt;Long&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getCompactionThresholdAsync(topic: String, applied: boolean): CompletableFuture&lt;Long&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getDeduplicationEnabled(topic: String): Boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ getDeduplicationEnabledAsync(topic: String): CompletableFuture&lt;Boolean&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getDeduplicationSnapshotInterval(topic: String): Integer</TD></TR>
<TR><TD ALIGN="LEFT" >+ getDeduplicationSnapshotIntervalAsync(topic: String): CompletableFuture&lt;Integer&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getDeduplicationStatus(topic: String): Boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ getDeduplicationStatus(topic: String, applied: boolean): Boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ getDeduplicationStatusAsync(topic: String): CompletableFuture&lt;Boolean&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getDeduplicationStatusAsync(topic: String, applied: boolean): CompletableFuture&lt;Boolean&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getDelayedDeliveryPolicy(topic: String, applied: boolean): DelayedDeliveryPolicies</TD></TR>
<TR><TD ALIGN="LEFT" >+ getDelayedDeliveryPolicy(topic: String): DelayedDeliveryPolicies</TD></TR>
<TR><TD ALIGN="LEFT" >+ getDelayedDeliveryPolicyAsync(topic: String, applied: boolean): CompletableFuture&lt;DelayedDeliveryPolicies&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getDelayedDeliveryPolicyAsync(topic: String): CompletableFuture&lt;DelayedDeliveryPolicies&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getDispatchRate(topic: String, applied: boolean): DispatchRate</TD></TR>
<TR><TD ALIGN="LEFT" >+ getDispatchRate(topic: String): DispatchRate</TD></TR>
<TR><TD ALIGN="LEFT" >+ getDispatchRateAsync(topic: String, applied: boolean): CompletableFuture&lt;DispatchRate&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getDispatchRateAsync(topic: String): CompletableFuture&lt;DispatchRate&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getInactiveTopicPolicies(topic: String, applied: boolean): InactiveTopicPolicies</TD></TR>
<TR><TD ALIGN="LEFT" >+ getInactiveTopicPolicies(topic: String): InactiveTopicPolicies</TD></TR>
<TR><TD ALIGN="LEFT" >+ getInactiveTopicPoliciesAsync(topic: String, applied: boolean): CompletableFuture&lt;InactiveTopicPolicies&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getInactiveTopicPoliciesAsync(topic: String): CompletableFuture&lt;InactiveTopicPolicies&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- getIndividualMsgsFromBatch(topic: String, msgId: String, data: byte[], properties: Map&lt;String, String&gt;, msgMetadataBuilder: MessageMetadata, brokerEntryMetadata: BrokerEntryMetadata): List&lt;Message&lt;byte[]&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getInternalInfo(topic: String): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ getInternalInfoAsync(topic: String): CompletableFuture&lt;String&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getInternalStats(topic: String): PersistentTopicInternalStats</TD></TR>
<TR><TD ALIGN="LEFT" >+ getInternalStats(topic: String, metadata: boolean): PersistentTopicInternalStats</TD></TR>
<TR><TD ALIGN="LEFT" >+ getInternalStatsAsync(topic: String): CompletableFuture&lt;PersistentTopicInternalStats&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getInternalStatsAsync(topic: String, metadata: boolean): CompletableFuture&lt;PersistentTopicInternalStats&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getLastMessageId(topic: String): MessageId</TD></TR>
<TR><TD ALIGN="LEFT" >+ getLastMessageIdAsync(topic: String): CompletableFuture&lt;MessageId&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getList(namespace: String): List&lt;String&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getList(namespace: String, topicDomain: TopicDomain): List&lt;String&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getList(namespace: String, topicDomain: TopicDomain, params: Map&lt;QueryParam, Object&gt;): List&lt;String&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getListAsync(namespace: String): CompletableFuture&lt;List&lt;String&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getListAsync(namespace: String, topicDomain: TopicDomain): CompletableFuture&lt;List&lt;String&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getListAsync(namespace: String, topicDomain: TopicDomain, params: Map&lt;QueryParam, Object&gt;): CompletableFuture&lt;List&lt;String&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getListInBundle(namespace: String, bundleRange: String): List&lt;String&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getListInBundleAsync(namespace: String, bundleRange: String): CompletableFuture&lt;List&lt;String&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getMaxConsumers(topic: String): Integer</TD></TR>
<TR><TD ALIGN="LEFT" >+ getMaxConsumers(topic: String, applied: boolean): Integer</TD></TR>
<TR><TD ALIGN="LEFT" >+ getMaxConsumersAsync(topic: String): CompletableFuture&lt;Integer&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getMaxConsumersAsync(topic: String, applied: boolean): CompletableFuture&lt;Integer&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getMaxConsumersPerSubscription(topic: String): Integer</TD></TR>
<TR><TD ALIGN="LEFT" >+ getMaxConsumersPerSubscriptionAsync(topic: String): CompletableFuture&lt;Integer&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getMaxMessageSize(topic: String): Integer</TD></TR>
<TR><TD ALIGN="LEFT" >+ getMaxMessageSizeAsync(topic: String): CompletableFuture&lt;Integer&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getMaxProducers(topic: String): Integer</TD></TR>
<TR><TD ALIGN="LEFT" >+ getMaxProducers(topic: String, applied: boolean): Integer</TD></TR>
<TR><TD ALIGN="LEFT" >+ getMaxProducersAsync(topic: String): CompletableFuture&lt;Integer&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getMaxProducersAsync(topic: String, applied: boolean): CompletableFuture&lt;Integer&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getMaxSubscriptionsPerTopic(topic: String): Integer</TD></TR>
<TR><TD ALIGN="LEFT" >+ getMaxSubscriptionsPerTopicAsync(topic: String): CompletableFuture&lt;Integer&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getMaxUnackedMessagesOnConsumer(topic: String): Integer</TD></TR>
<TR><TD ALIGN="LEFT" >+ getMaxUnackedMessagesOnConsumer(topic: String, applied: boolean): Integer</TD></TR>
<TR><TD ALIGN="LEFT" >+ getMaxUnackedMessagesOnConsumerAsync(topic: String): CompletableFuture&lt;Integer&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getMaxUnackedMessagesOnConsumerAsync(topic: String, applied: boolean): CompletableFuture&lt;Integer&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getMaxUnackedMessagesOnSubscription(topic: String): Integer</TD></TR>
<TR><TD ALIGN="LEFT" >+ getMaxUnackedMessagesOnSubscription(topic: String, applied: boolean): Integer</TD></TR>
<TR><TD ALIGN="LEFT" >+ getMaxUnackedMessagesOnSubscriptionAsync(topic: String): CompletableFuture&lt;Integer&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getMaxUnackedMessagesOnSubscriptionAsync(topic: String, applied: boolean): CompletableFuture&lt;Integer&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getMessageById(topic: String, ledgerId: long, entryId: long): Message&lt;byte[]&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getMessageByIdAsync(topic: String, ledgerId: long, entryId: long): CompletableFuture&lt;Message&lt;byte[]&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getMessageIdByTimestamp(topic: String, timestamp: long): MessageId</TD></TR>
<TR><TD ALIGN="LEFT" >+ getMessageIdByTimestampAsync(topic: String, timestamp: long): CompletableFuture&lt;MessageId&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getMessageTTL(topic: String): Integer</TD></TR>
<TR><TD ALIGN="LEFT" >+ getMessageTTL(topic: String, applied: boolean): Integer</TD></TR>
<TR><TD ALIGN="LEFT" >- getMessagesFromHttpResponse(topic: String, response: Response): List&lt;Message&lt;byte[]&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getOffloadPolicies(topic: String): OffloadPolicies</TD></TR>
<TR><TD ALIGN="LEFT" >+ getOffloadPolicies(topic: String, applied: boolean): OffloadPolicies</TD></TR>
<TR><TD ALIGN="LEFT" >+ getOffloadPoliciesAsync(topic: String): CompletableFuture&lt;OffloadPolicies&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getOffloadPoliciesAsync(topic: String, applied: boolean): CompletableFuture&lt;OffloadPolicies&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getPartitionedInternalStats(topic: String): PartitionedTopicInternalStats</TD></TR>
<TR><TD ALIGN="LEFT" >+ getPartitionedInternalStatsAsync(topic: String): CompletableFuture&lt;PartitionedTopicInternalStats&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getPartitionedStats(topic: String, perPartition: boolean, getPreciseBacklog: boolean, subscriptionBacklogSize: boolean): PartitionedTopicStats</TD></TR>
<TR><TD ALIGN="LEFT" >+ getPartitionedStatsAsync(topic: String, perPartition: boolean, getPreciseBacklog: boolean, subscriptionBacklogSize: boolean): CompletableFuture&lt;PartitionedTopicStats&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getPartitionedTopicList(namespace: String): List&lt;String&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getPartitionedTopicListAsync(namespace: String): CompletableFuture&lt;List&lt;String&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getPartitionedTopicMetadata(topic: String): PartitionedTopicMetadata</TD></TR>
<TR><TD ALIGN="LEFT" >+ getPartitionedTopicMetadataAsync(topic: String): CompletableFuture&lt;PartitionedTopicMetadata&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getPermissions(topic: String): Map&lt;String, Set&lt;AuthAction&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getPermissionsAsync(topic: String): CompletableFuture&lt;Map&lt;String, Set&lt;AuthAction&gt;&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getPersistence(topic: String): PersistencePolicies</TD></TR>
<TR><TD ALIGN="LEFT" >+ getPersistence(topic: String, applied: boolean): PersistencePolicies</TD></TR>
<TR><TD ALIGN="LEFT" >+ getPersistenceAsync(topic: String): CompletableFuture&lt;PersistencePolicies&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getPersistenceAsync(topic: String, applied: boolean): CompletableFuture&lt;PersistencePolicies&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getPublishRate(topic: String): PublishRate</TD></TR>
<TR><TD ALIGN="LEFT" >+ getPublishRateAsync(topic: String): CompletableFuture&lt;PublishRate&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- getRemoteMessageById(topic: String, ledgerId: long, entryId: long): CompletableFuture&lt;Message&lt;byte[]&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getReplicatedSubscriptionStatus(topic: String, subName: String): Map&lt;String, Boolean&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getReplicatedSubscriptionStatusAsync(topic: String, subName: String): CompletableFuture&lt;Map&lt;String, Boolean&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getReplicationClusters(topic: String, applied: boolean): Set&lt;String&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getReplicationClustersAsync(topic: String, applied: boolean): CompletableFuture&lt;Set&lt;String&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getReplicatorDispatchRate(topic: String): DispatchRate</TD></TR>
<TR><TD ALIGN="LEFT" >+ getReplicatorDispatchRate(topic: String, applied: boolean): DispatchRate</TD></TR>
<TR><TD ALIGN="LEFT" >+ getReplicatorDispatchRateAsync(topic: String): CompletableFuture&lt;DispatchRate&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getReplicatorDispatchRateAsync(topic: String, applied: boolean): CompletableFuture&lt;DispatchRate&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getRetention(topic: String): RetentionPolicies</TD></TR>
<TR><TD ALIGN="LEFT" >+ getRetention(topic: String, applied: boolean): RetentionPolicies</TD></TR>
<TR><TD ALIGN="LEFT" >+ getRetentionAsync(topic: String): CompletableFuture&lt;RetentionPolicies&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getRetentionAsync(topic: String, applied: boolean): CompletableFuture&lt;RetentionPolicies&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getStats(topic: String, getStatsOptions: GetStatsOptions): TopicStats</TD></TR>
<TR><TD ALIGN="LEFT" >+ getStatsAsync(topic: String, getPreciseBacklog: boolean, subscriptionBacklogSize: boolean, getEarliestTimeInBacklog: boolean): CompletableFuture&lt;TopicStats&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getSubscribeRate(topic: String): SubscribeRate</TD></TR>
<TR><TD ALIGN="LEFT" >+ getSubscribeRate(topic: String, applied: boolean): SubscribeRate</TD></TR>
<TR><TD ALIGN="LEFT" >+ getSubscribeRateAsync(topic: String): CompletableFuture&lt;SubscribeRate&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getSubscribeRateAsync(topic: String, applied: boolean): CompletableFuture&lt;SubscribeRate&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getSubscriptionDispatchRate(topic: String, applied: boolean): DispatchRate</TD></TR>
<TR><TD ALIGN="LEFT" >+ getSubscriptionDispatchRate(topic: String): DispatchRate</TD></TR>
<TR><TD ALIGN="LEFT" >+ getSubscriptionDispatchRateAsync(topic: String, applied: boolean): CompletableFuture&lt;DispatchRate&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getSubscriptionDispatchRateAsync(topic: String): CompletableFuture&lt;DispatchRate&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getSubscriptionTypesEnabled(topic: String): Set&lt;SubscriptionType&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getSubscriptionTypesEnabledAsync(topic: String): CompletableFuture&lt;Set&lt;SubscriptionType&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getSubscriptions(topic: String): List&lt;String&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getSubscriptionsAsync(topic: String): CompletableFuture&lt;List&lt;String&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ grantPermission(topic: String, role: String, actions: Set&lt;AuthAction&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ grantPermissionAsync(topic: String, role: String, actions: Set&lt;AuthAction&gt;): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- namespacePath(domain: String, namespace: NamespaceName, parts: String...): WebTarget</TD></TR>
<TR><TD ALIGN="LEFT" >+ offloadStatus(topic: String): OffloadProcessStatus</TD></TR>
<TR><TD ALIGN="LEFT" >+ offloadStatusAsync(topic: String): CompletableFuture&lt;OffloadProcessStatus&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ peekMessages(topic: String, subName: String, numMessages: int): List&lt;Message&lt;byte[]&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ peekMessagesAsync(topic: String, subName: String, numMessages: int): CompletableFuture&lt;List&lt;Message&lt;byte[]&gt;&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- peekMessagesAsync(topic: String, subName: String, numMessages: int, messages: List&lt;Message&lt;byte[]&gt;&gt;, future: CompletableFuture&lt;List&lt;Message&lt;byte[]&gt;&gt;&gt;, nthMessage: int)</TD></TR>
<TR><TD ALIGN="LEFT" >- peekNthMessage(topic: String, subName: String, messagePosition: int): CompletableFuture&lt;List&lt;Message&lt;byte[]&gt;&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ removeBacklogQuota(topic: String, backlogQuotaType: BacklogQuotaType)</TD></TR>
<TR><TD ALIGN="LEFT" >+ removeCompactionThreshold(topic: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ removeCompactionThresholdAsync(topic: String): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ removeDeduplicationSnapshotInterval(topic: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ removeDeduplicationSnapshotIntervalAsync(topic: String): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ removeDeduplicationStatus(topic: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ removeDeduplicationStatusAsync(topic: String): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ removeDelayedDeliveryPolicy(topic: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ removeDelayedDeliveryPolicyAsync(topic: String): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ removeDispatchRate(topic: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ removeDispatchRateAsync(topic: String): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ removeInactiveTopicPolicies(topic: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ removeInactiveTopicPoliciesAsync(topic: String): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ removeMaxConsumers(topic: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ removeMaxConsumersAsync(topic: String): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ removeMaxConsumersPerSubscription(topic: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ removeMaxConsumersPerSubscriptionAsync(topic: String): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ removeMaxMessageSize(topic: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ removeMaxMessageSizeAsync(topic: String): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ removeMaxProducers(topic: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ removeMaxProducersAsync(topic: String): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ removeMaxSubscriptionsPerTopic(topic: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ removeMaxSubscriptionsPerTopicAsync(topic: String): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ removeMaxUnackedMessagesOnConsumer(topic: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ removeMaxUnackedMessagesOnConsumerAsync(topic: String): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ removeMaxUnackedMessagesOnSubscription(topic: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ removeMaxUnackedMessagesOnSubscriptionAsync(topic: String): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ removeMessageTTL(topic: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ removeOffloadPolicies(topic: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ removeOffloadPoliciesAsync(topic: String): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ removePersistence(topic: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ removePersistenceAsync(topic: String): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ removePublishRate(topic: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ removePublishRateAsync(topic: String): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ removeReplicationClusters(topic: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ removeReplicationClustersAsync(topic: String): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ removeReplicatorDispatchRate(topic: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ removeReplicatorDispatchRateAsync(topic: String): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ removeRetention(topic: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ removeRetentionAsync(topic: String): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ removeSubscribeRate(topic: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ removeSubscribeRateAsync(topic: String): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ removeSubscriptionDispatchRate(topic: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ removeSubscriptionDispatchRateAsync(topic: String): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ removeSubscriptionTypesEnabled(topic: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ removeSubscriptionTypesEnabledAsync(topic: String): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ resetCursor(topic: String, subName: String, timestamp: long)</TD></TR>
<TR><TD ALIGN="LEFT" >+ resetCursor(topic: String, subName: String, messageId: MessageId)</TD></TR>
<TR><TD ALIGN="LEFT" >+ resetCursor(topic: String, subName: String, messageId: MessageId, isExcluded: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ resetCursorAsync(topic: String, subName: String, timestamp: long): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ resetCursorAsync(topic: String, subName: String, messageId: MessageId): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ resetCursorAsync(topic: String, subName: String, messageId: MessageId, isExcluded: boolean): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ revokePermissions(topic: String, role: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ revokePermissionsAsync(topic: String, role: String): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ setCompactionThresholdAsync(topic: String, compactionThreshold: long): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ setDeduplicationSnapshotIntervalAsync(topic: String, interval: int): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ setDeduplicationStatusAsync(topic: String, enabled: boolean): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ setDelayedDeliveryPolicyAsync(topic: String, delayedDeliveryPolicies: DelayedDeliveryPolicies): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ setDispatchRateAsync(topic: String, dispatchRate: DispatchRate): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ setInactiveTopicPoliciesAsync(topic: String, inactiveTopicPolicies: InactiveTopicPolicies): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ setMaxConsumersAsync(topic: String, maxConsumers: int): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ setMaxConsumersPerSubscriptionAsync(topic: String, maxConsumersPerSubscription: int): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ setMaxMessageSizeAsync(topic: String, maxMessageSize: int): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ setMaxProducersAsync(topic: String, maxProducers: int): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ setMaxSubscriptionsPerTopicAsync(topic: String, maxSubscriptionsPerTopic: int): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ setMaxUnackedMessagesOnConsumerAsync(topic: String, maxNum: int): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ setMaxUnackedMessagesOnSubscriptionAsync(topic: String, maxNum: int): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ setOffloadPoliciesAsync(topic: String, offloadPolicies: OffloadPolicies): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ setPersistenceAsync(topic: String, persistencePolicies: PersistencePolicies): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ setPublishRateAsync(topic: String, publishRate: PublishRate): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ setReplicatedSubscriptionStatusAsync(topic: String, subName: String, enabled: boolean): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ setReplicationClustersAsync(topic: String, clusterIds: List&lt;String&gt;): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ setReplicatorDispatchRateAsync(topic: String, dispatchRate: DispatchRate): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ setRetentionAsync(topic: String, retention: RetentionPolicies): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ setSubscribeRateAsync(topic: String, subscribeRate: SubscribeRate): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ setSubscriptionDispatchRateAsync(topic: String, dispatchRate: DispatchRate): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ setSubscriptionTypesEnabledAsync(topic: String, subscriptionTypesEnabled: Set&lt;SubscriptionType&gt;): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ skipAllMessages(topic: String, subName: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ skipAllMessagesAsync(topic: String, subName: String): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ skipMessages(topic: String, subName: String, numMessages: long)</TD></TR>
<TR><TD ALIGN="LEFT" >+ skipMessagesAsync(topic: String, subName: String, numMessages: long): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ terminatePartitionedTopic(topic: String): Map&lt;Integer, MessageId&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ terminatePartitionedTopicAsync(topic: String): CompletableFuture&lt;Map&lt;Integer, MessageId&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ terminateTopic(topic: String): MessageId</TD></TR>
<TR><TD ALIGN="LEFT" >+ terminateTopicAsync(topic: String): CompletableFuture&lt;MessageId&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- topicPath(topic: TopicName, parts: String...): WebTarget</TD></TR>
<TR><TD ALIGN="LEFT" >+ triggerCompaction(topic: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ triggerCompactionAsync(topic: String): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ triggerOffload(topic: String, messageId: MessageId)</TD></TR>
<TR><TD ALIGN="LEFT" >+ triggerOffloadAsync(topic: String, messageId: MessageId): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ truncate(topic: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ truncateAsync(topic: String): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ unload(topic: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ unloadAsync(topic: String): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ updatePartitionedTopic(topic: String, numPartitions: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ updatePartitionedTopic(topic: String, numPartitions: int, updateLocalTopicOnly: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ updatePartitionedTopic(topic: String, numPartitions: int, updateLocalTopicOnly: boolean, force: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ updatePartitionedTopicAsync(topic: String, numPartitions: int): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ updatePartitionedTopicAsync(topic: String, numPartitions: int, updateLocalTopicOnly: boolean): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ updatePartitionedTopicAsync(topic: String, numPartitions: int, updateLocalTopicOnly: boolean, force: boolean): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- validateTopic(topic: String): TopicName</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

TradeUnit1840568558[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)TradeUnit</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   client: PulsarClient [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   consumerFuture: Future&lt;Consumer&lt;byte[]&gt;&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   payload: AtomicReference&lt;byte[]&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   payloadCache: Map&lt;Integer, byte[]&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >#   rateLimiter: RateLimiter [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   stop: AtomicBoolean [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   topic: String [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ change(tradeConf: TradeConfiguration)</TD></TR>
<TR><TD ALIGN="LEFT" >+ start()</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

TransactionBufferClientImpl1621168036[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)TransactionBufferClientImpl</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   tbHandler: TransactionBufferHandler [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ abortTxnOnSubscription(topic: String, subscription: String, txnIdMostBits: long, txnIdLeastBits: long, lowWaterMark: long): CompletableFuture&lt;TxnID&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ abortTxnOnTopic(topic: String, txnIdMostBits: long, txnIdLeastBits: long, lowWaterMark: long): CompletableFuture&lt;TxnID&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ commitTxnOnSubscription(topic: String, subscription: String, txnIdMostBits: long, txnIdLeastBits: long, lowWaterMark: long): CompletableFuture&lt;TxnID&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ commitTxnOnTopic(topic: String, txnIdMostBits: long, txnIdLeastBits: long, lowWaterMark: long): CompletableFuture&lt;TxnID&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ create(pulsarClient: PulsarClient, timer: HashedWheelTimer): TransactionBufferClient</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

TransactionBufferDisable1621168036[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)TransactionBufferDisable</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ abortTxn(txnID: TxnID, lowWaterMark: long): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ appendBufferToTxn(txnId: TxnID, sequenceId: long, buffer: ByteBuf): CompletableFuture&lt;Position&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ checkIfTBRecoverCompletely(isTxn: boolean): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearSnapshot(): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ closeAsync(): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ commitTxn(txnID: TxnID, lowWaterMark: long): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getTransactionInBufferStats(txnID: TxnID): TransactionInBufferStats</TD></TR>
<TR><TD ALIGN="LEFT" >+ getTransactionMeta(txnID: TxnID): CompletableFuture&lt;TransactionMeta&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ isTxnAborted(txnID: TxnID): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ openTransactionBufferReader(txnID: TxnID, startSequenceId: long): CompletableFuture&lt;TransactionBufferReader&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ purgeTxns(dataLedgers: List&lt;Long&gt;): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ syncMaxReadPositionForNormalPublish(position: PositionImpl)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

TransactionBufferHandlerImpl1621168036[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)TransactionBufferHandlerImpl</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   cache: LoadingCache&lt;String, CompletableFuture&lt;ClientCnx&gt;&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   operationTimeoutInMills: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   pendingRequests: ConcurrentSkipListMap&lt;Long, OpRequestSend&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   pulsarClient: PulsarClient [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   requestIdGenerator: AtomicLong [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   timer: HashedWheelTimer [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >- endTxn(requestId: long, topic: String, cmd: ByteBuf, cb: CompletableFuture&lt;TxnID&gt;): CompletableFuture&lt;TxnID&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ endTxnOnSubscription(topic: String, subscription: String, txnIdMostBits: long, txnIdLeastBits: long, action: TxnAction, lowWaterMark: long): CompletableFuture&lt;TxnID&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ endTxnOnTopic(topic: String, txnIdMostBits: long, txnIdLeastBits: long, action: TxnAction, lowWaterMark: long): CompletableFuture&lt;TxnID&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- getClientCnx(topic: String): CompletableFuture&lt;ClientCnx&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ handleEndTxnOnSubscriptionResponse(requestId: long, response: CommandEndTxnOnSubscriptionResponse)</TD></TR>
<TR><TD ALIGN="LEFT" >+ handleEndTxnOnTopicResponse(requestId: long, response: CommandEndTxnOnPartitionResponse)</TD></TR>
<TR><TD ALIGN="LEFT" ># onResponse(op: OpRequestSend)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

TransactionBufferSnapshotReader1252191935[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)TransactionBufferSnapshotReader</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   reader: Reader&lt;TransactionBufferSnapshot&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   transactionBufferSystemTopicClient: TransactionBufferSystemTopicClient [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ closeAsync(): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ readNext(): Message&lt;TransactionBufferSnapshot&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ readNextAsync(): CompletableFuture&lt;Message&lt;TransactionBufferSnapshot&gt;&gt;</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

TransactionBufferSnapshotWriter1252191935[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)TransactionBufferSnapshotWriter</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   producer: Producer&lt;TransactionBufferSnapshot&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   transactionBufferSystemTopicClient: TransactionBufferSystemTopicClient [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ closeAsync(): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ delete(transactionBufferSnapshot: TransactionBufferSnapshot): MessageId</TD></TR>
<TR><TD ALIGN="LEFT" >+ deleteAsync(transactionBufferSnapshot: TransactionBufferSnapshot): CompletableFuture&lt;MessageId&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ write(transactionBufferSnapshot: TransactionBufferSnapshot): MessageId</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeAsync(transactionBufferSnapshot: TransactionBufferSnapshot): CompletableFuture&lt;MessageId&gt;</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

TransactionBufferSystemTopicClient1970406500[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)TransactionBufferSystemTopicClient</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   transactionBufferSnapshotService: TransactionBufferSnapshotService [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># newReaderAsyncInternal(): CompletableFuture&lt;Reader&lt;TransactionBufferSnapshot&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># newWriterAsyncInternal(): CompletableFuture&lt;Writer&lt;TransactionBufferSnapshot&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># removeReader(reader: TransactionBufferSnapshotReader)</TD></TR>
<TR><TD ALIGN="LEFT" ># removeWriter(writer: TransactionBufferSnapshotWriter)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

TransactionCoordinatorClientImpl219831672[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)TransactionCoordinatorClientImpl</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   epoch: AtomicLong [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   handlerMap: ConcurrentLongHashMap&lt;TransactionMetaStoreHandler&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   handlers: TransactionMetaStoreHandler[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   pulsarClient: PulsarClientImpl [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   state: State [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ abort(txnID: TxnID)</TD></TR>
<TR><TD ALIGN="LEFT" >+ abortAsync(txnID: TxnID): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ addPublishPartitionToTxn(txnID: TxnID, partitions: List&lt;String&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ addPublishPartitionToTxnAsync(txnID: TxnID, partitions: List&lt;String&gt;): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ addSubscriptionToTxn(txnID: TxnID, topic: String, subscription: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ addSubscriptionToTxnAsync(txnID: TxnID, topic: String, subscription: String): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ closeAsync(): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ commit(txnID: TxnID)</TD></TR>
<TR><TD ALIGN="LEFT" >+ commitAsync(txnID: TxnID): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- getTCAssignTopicName(partition: int): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ newTransaction(): TxnID</TD></TR>
<TR><TD ALIGN="LEFT" >+ newTransaction(timeout: long, unit: TimeUnit): TxnID</TD></TR>
<TR><TD ALIGN="LEFT" >+ newTransactionAsync(): CompletableFuture&lt;TxnID&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ newTransactionAsync(timeout: long, unit: TimeUnit): CompletableFuture&lt;TxnID&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- nextHandler(): TransactionMetaStoreHandler</TD></TR>
<TR><TD ALIGN="LEFT" >+ start()</TD></TR>
<TR><TD ALIGN="LEFT" >+ startAsync(): CompletableFuture&lt;Void&gt;</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

TransactionCoordinatorID923625925[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)TransactionCoordinatorID</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   id: long [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># canEqual(other: Object): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ get(id: long): TransactionCoordinatorID</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

TransactionEntryImpl1621168036[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)TransactionEntryImpl</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   committedAtEntryId: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   committedAtLedgerId: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   entry: Entry [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   numMessageInTxn: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   sequenceId: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   startBatchIndex: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   txnId: TxnID [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ committedAtEntryId(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ committedAtLedgerId(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ numMessageInTxn(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ release(): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ sequenceId(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ txnId(): TxnID</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

TransactionImpl219831672[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)TransactionImpl</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   ackFutureList: ArrayList&lt;CompletableFuture&lt;Void&gt;&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   client: PulsarClientImpl [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   cumulativeAckConsumers: Map&lt;ConsumerImpl&lt;?&gt;, Integer&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   registerPartitionMap: Map&lt;String, CompletableFuture&lt;Void&gt;&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   registerSubscriptionMap: Map&lt;Pair&lt;String, String&gt;, CompletableFuture&lt;Void&gt;&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   sendFutureList: ArrayList&lt;CompletableFuture&lt;MessageId&gt;&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   state: State [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   tcClient: TransactionCoordinatorClientImpl [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   timeout: Timeout [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   transactionTimeoutMs: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   txnIdLeastBits: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   txnIdMostBits: long [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ abort(): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- allOpComplete(): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ checkIfOpen(completableFuture: CompletableFuture&lt;T&gt;): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >- checkIfOpenOrAborting(): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- checkIfOpenOrCommitting(): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ commit(): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- invalidTxnStatusFuture(): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ registerAckOp(ackFuture: CompletableFuture&lt;Void&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ registerAckedTopic(topic: String, subscription: String): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ registerCumulativeAckConsumer(consumer: ConsumerImpl&lt;?&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ registerProducedTopic(topic: String): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ registerSendOp(sendFuture: CompletableFuture&lt;MessageId&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ run(timeout: Timeout)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

TransactionLogReplayer389689066[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)TransactionLogReplayer</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   fillEntryQueueCallback: FillEntryQueueCallback [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   transactionLogReplayCallback: TransactionLogReplayCallback [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ start()</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

TransactionMetaStoreHandler12001400[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)TransactionMetaStoreHandler</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   blockIfReachMaxPendingOps: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   connectFuture: CompletableFuture&lt;Void&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   connectionHandler: ConnectionHandler [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   internalPinnedExecutor: ExecutorService [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   pendingRequests: ConcurrentLongHashMap&lt;OpBase&lt;?&gt;&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   requestTimeout: Timeout [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   semaphore: Semaphore [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   timeoutQueue: ConcurrentLinkedQueue&lt;RequestTime&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >#   timer: Timer [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   transactionCoordinatorId: long [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ addPublishPartitionToTxnAsync(txnID: TxnID, partitions: List&lt;String&gt;): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ addSubscriptionToTxn(txnID: TxnID, subscriptionList: List&lt;Subscription&gt;): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- canSendRequest(callback: CompletableFuture&lt;?&gt;): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >- checkIfNeedRetryByError(error: ServerError, message: String, op: OpBase&lt;?&gt;): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >- checkStateAndSendRequest(op: OpBase&lt;?&gt;): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >- cnx(): ClientCnx</TD></TR>
<TR><TD ALIGN="LEFT" ># connectionClosed(cnx: ClientCnx)</TD></TR>
<TR><TD ALIGN="LEFT" >+ connectionFailed(exception: PulsarClientException)</TD></TR>
<TR><TD ALIGN="LEFT" >+ connectionOpened(cnx: ClientCnx)</TD></TR>
<TR><TD ALIGN="LEFT" >+ endTxnAsync(txnID: TxnID, action: TxnAction): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- failPendingRequest()</TD></TR>
<TR><TD ALIGN="LEFT" >+ getExceptionByServerError(serverError: ServerError, msg: String): TransactionCoordinatorClientException</TD></TR>
<TR><TD ALIGN="LEFT" ># handleAddPublishPartitionToTxnResponse(response: CommandAddPartitionToTxnResponse)</TD></TR>
<TR><TD ALIGN="LEFT" >+ handleAddSubscriptionToTxnResponse(response: CommandAddSubscriptionToTxnResponse)</TD></TR>
<TR><TD ALIGN="LEFT" ># handleEndTxnResponse(response: CommandEndTxnResponse)</TD></TR>
<TR><TD ALIGN="LEFT" ># handleNewTxnResponse(response: CommandNewTxnResponse)</TD></TR>
<TR><TD ALIGN="LEFT" >+ newTransactionAsync(timeout: long, unit: TimeUnit): CompletableFuture&lt;TxnID&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- onResponse(op: OpBase&lt;?&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ run(timeout: Timeout)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

TransactionMetadataEntry1906636927[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)TransactionMetadataEntry</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   _bitField0: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _cachedSize: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _parsedBuffer: ByteBuf [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _partitionsCount: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _subscriptionsCount: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   expectedStatus: TxnStatus [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   lastModificationTime: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   maxLocalTxnId: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   metadataOp: TransactionMetadataOp [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   newStatus: TxnStatus [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   partitions: List&lt;StringHolder&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   startTime: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   subscriptions: List&lt;Subscription&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   timeoutMs: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   txnidLeastBits: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   txnidMostBits: long [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- _newPartitionStringHolder(): StringHolder</TD></TR>
<TR><TD ALIGN="LEFT" >+ addAllPartitions(partitions: Iterable&lt;String&gt;): TransactionMetadataEntry</TD></TR>
<TR><TD ALIGN="LEFT" >+ addAllSubscriptions(subscriptions: Iterable&lt;Subscription&gt;): TransactionMetadataEntry</TD></TR>
<TR><TD ALIGN="LEFT" >+ addPartition(partition: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ addSubscription(): Subscription</TD></TR>
<TR><TD ALIGN="LEFT" >+ clear(): TransactionMetadataEntry</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearExpectedStatus(): TransactionMetadataEntry</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearLastModificationTime(): TransactionMetadataEntry</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearMaxLocalTxnId(): TransactionMetadataEntry</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearMetadataOp(): TransactionMetadataEntry</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearNewStatus(): TransactionMetadataEntry</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearPartitions(): TransactionMetadataEntry</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearStartTime(): TransactionMetadataEntry</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearSubscriptions(): TransactionMetadataEntry</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearTimeoutMs(): TransactionMetadataEntry</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearTxnidLeastBits(): TransactionMetadataEntry</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearTxnidMostBits(): TransactionMetadataEntry</TD></TR>
<TR><TD ALIGN="LEFT" >+ copyFrom(_other: TransactionMetadataEntry): TransactionMetadataEntry</TD></TR>
<TR><TD ALIGN="LEFT" >+ getPartitionAt(idx: int): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ getSubscriptionAt(idx: int): Subscription</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(_buffer: ByteBuf, _size: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(a: byte[])</TD></TR>
<TR><TD ALIGN="LEFT" >+ setExpectedStatus(expectedStatus: TxnStatus): TransactionMetadataEntry</TD></TR>
<TR><TD ALIGN="LEFT" >+ setLastModificationTime(lastModificationTime: long): TransactionMetadataEntry</TD></TR>
<TR><TD ALIGN="LEFT" >+ setMaxLocalTxnId(maxLocalTxnId: long): TransactionMetadataEntry</TD></TR>
<TR><TD ALIGN="LEFT" >+ setMetadataOp(metadataOp: TransactionMetadataOp): TransactionMetadataEntry</TD></TR>
<TR><TD ALIGN="LEFT" >+ setNewStatus(newStatus: TxnStatus): TransactionMetadataEntry</TD></TR>
<TR><TD ALIGN="LEFT" >+ setStartTime(startTime: long): TransactionMetadataEntry</TD></TR>
<TR><TD ALIGN="LEFT" >+ setTimeoutMs(timeoutMs: long): TransactionMetadataEntry</TD></TR>
<TR><TD ALIGN="LEFT" >+ setTxnidLeastBits(txnidLeastBits: long): TransactionMetadataEntry</TD></TR>
<TR><TD ALIGN="LEFT" >+ setTxnidMostBits(txnidMostBits: long): TransactionMetadataEntry</TD></TR>
<TR><TD ALIGN="LEFT" >+ toByteArray(): byte[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeTo(_b: ByteBuf): int</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

TransactionMetadataStoreService724302956[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)TransactionMetadataStoreService</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   internalPinnedExecutor: ExecutorService [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   pendingConnectRequests: ConcurrentLongHashMap&lt;ConcurrentLinkedDeque&lt;CompletableFuture&lt;Void&gt;&gt;&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   pulsarService: PulsarService [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   stores: Map&lt;TransactionCoordinatorID, TransactionMetadataStore&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   tbClient: TransactionBufferClient [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   tcLoadSemaphores: ConcurrentLongHashMap&lt;Semaphore&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   threadFactory: ThreadFactory [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   timeoutTrackerFactory: TransactionTimeoutTrackerFactory [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   transactionMetadataStoreProvider: TransactionMetadataStoreProvider [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   transactionOpRetryTimer: Timer [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ addAckedPartitionToTxn(txnId: TxnID, partitions: List&lt;TransactionSubscription&gt;): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ addProducedPartitionToTxn(txnId: TxnID, partitions: List&lt;String&gt;): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ endTransaction(txnID: TxnID, txnAction: int, isTimeout: boolean): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ endTransaction(txnID: TxnID, txnAction: int, isTimeout: boolean, completableFuture: CompletableFuture&lt;Void&gt;): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ endTransactionForTimeout(txnID: TxnID)</TD></TR>
<TR><TD ALIGN="LEFT" >- endTxnInTransactionBuffer(txnID: TxnID, txnAction: int): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- endTxnInTransactionMetadataStore(txnID: TxnID, txnAction: int): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getLowWaterMark(txnID: TxnID): long</TD></TR>
<TR><TD ALIGN="LEFT" >- getTcIdFromTxnId(txnId: TxnID): TransactionCoordinatorID</TD></TR>
<TR><TD ALIGN="LEFT" >+ getTxnMeta(txnId: TxnID): CompletableFuture&lt;TxnMeta&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ handleOpFail(e: Throwable, tcId: TransactionCoordinatorID)</TD></TR>
<TR><TD ALIGN="LEFT" >+ handleTcClientConnect(tcId: TransactionCoordinatorID): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- isRetryableException(e: Throwable): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ newTransaction(tcId: TransactionCoordinatorID, timeoutInMills: long): CompletableFuture&lt;TxnID&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ openTransactionMetadataStore(tcId: TransactionCoordinatorID): CompletableFuture&lt;TransactionMetadataStore&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ removeTransactionMetadataStore(tcId: TransactionCoordinatorID): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ start()</TD></TR>
<TR><TD ALIGN="LEFT" >+ updateTxnStatus(txnId: TxnID, newStatus: TxnStatus, expectedStatus: TxnStatus, isTimeout: boolean): CompletableFuture&lt;Void&gt;</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

TransactionMetadataStoreState923625925[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)TransactionMetadataStoreState</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   state: State [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># changeToCloseState(): boolean</TD></TR>
<TR><TD ALIGN="LEFT" ># changeToClosingState(): boolean</TD></TR>
<TR><TD ALIGN="LEFT" ># changeToInitializingState(): boolean</TD></TR>
<TR><TD ALIGN="LEFT" ># changeToReadyState(): boolean</TD></TR>
<TR><TD ALIGN="LEFT" ># checkIfReady(): boolean</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

TransactionMetadataStoreStats1462729559[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)TransactionMetadataStoreStats</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+   abortedCount: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   actives: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   appendLogCount: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   committedCount: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   coordinatorId: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   createdCount: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   executionLatencyBuckets: StatsBuckets [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   timeoutCount: long [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ addTransactionExecutionLatencySample(latency: long)</TD></TR>
<TR><TD ALIGN="LEFT" ># canEqual(other: Object): boolean</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

TransactionSubscription923625925[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)TransactionSubscription</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   subscription: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   topic: String [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ builder(): TransactionSubscriptionBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ compareTo(o: TransactionSubscription): int</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

TransactionTimeoutTrackerFactoryImpl949786377[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)TransactionTimeoutTrackerFactoryImpl</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   timer: Timer [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   transactionMetadataStoreService: TransactionMetadataStoreService [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ newTracker(tcID: TransactionCoordinatorID): TransactionTimeoutTracker</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

TransactionTimeoutTrackerImpl949786377[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)TransactionTimeoutTrackerImpl</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   clock: Clock [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   currentTimeout: Timeout [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   nowTaskTimeoutTime: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   priorityQueue: TripleLongPriorityQueue [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   tcId: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   tickTimeMillis: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   timer: Timer [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   transactionMetadataStoreService: TransactionMetadataStoreService [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ addTransaction(sequenceId: long, timeout: long): CompletableFuture&lt;Boolean&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ replayAddTransaction(sequenceId: long, timeout: long)</TD></TR>
<TR><TD ALIGN="LEFT" >+ run(timeout: Timeout)</TD></TR>
<TR><TD ALIGN="LEFT" >+ start()</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

TransactionUtil1462365557[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)TransactionUtil</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ canTransitionTo(currentStatus: TxnStatus, newStatus: TxnStatus): boolean</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

TransactionsBase229910521[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)TransactionsBase</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- getTransactionMetadata(txnMeta: TxnMeta, transactionMetadataFuture: CompletableFuture&lt;TransactionMetadata&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" ># internalGetCoordinatorInternalStats(asyncResponse: AsyncResponse, authoritative: boolean, metadata: boolean, coordinatorId: int)</TD></TR>
<TR><TD ALIGN="LEFT" ># internalGetCoordinatorStats(asyncResponse: AsyncResponse, authoritative: boolean, coordinatorId: Integer)</TD></TR>
<TR><TD ALIGN="LEFT" ># internalGetPendingAckInternalStats(asyncResponse: AsyncResponse, authoritative: boolean, topicName: TopicName, subName: String, metadata: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" ># internalGetPendingAckStats(asyncResponse: AsyncResponse, authoritative: boolean, subName: String)</TD></TR>
<TR><TD ALIGN="LEFT" ># internalGetSlowTransactions(asyncResponse: AsyncResponse, authoritative: boolean, timeout: long, coordinatorId: Integer)</TD></TR>
<TR><TD ALIGN="LEFT" ># internalGetTransactionBufferStats(asyncResponse: AsyncResponse, authoritative: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" ># internalGetTransactionInBufferStats(asyncResponse: AsyncResponse, authoritative: boolean, mostSigBits: long, leastSigBits: long)</TD></TR>
<TR><TD ALIGN="LEFT" ># internalGetTransactionInPendingAckStats(asyncResponse: AsyncResponse, authoritative: boolean, mostSigBits: long, leastSigBits: long, subName: String)</TD></TR>
<TR><TD ALIGN="LEFT" ># internalGetTransactionMetadata(asyncResponse: AsyncResponse, authoritative: boolean, mostSigBits: int, leastSigBits: long)</TD></TR>
<TR><TD ALIGN="LEFT" ># validateTopicName(property: String, namespace: String, encodedTopic: String)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

TripleLongPriorityQueue201476337[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)TripleLongPriorityQueue</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   buffer: ByteBuf [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   capacity: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   size: int [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ add(n1: long, n2: long, n3: long)</TD></TR>
<TR><TD ALIGN="LEFT" >+ clear()</TD></TR>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >- compare(idx1: int, idx2: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >- increaseCapacity()</TD></TR>
<TR><TD ALIGN="LEFT" >+ peekN1(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ peekN2(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ peekN3(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ pop()</TD></TR>
<TR><TD ALIGN="LEFT" >- put(idx: int, n1: long, n2: long, n3: long)</TD></TR>
<TR><TD ALIGN="LEFT" >- siftDown(idx: int)</TD></TR>
<TR><TD ALIGN="LEFT" >- siftUp(idx: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ size(): int</TD></TR>
<TR><TD ALIGN="LEFT" >- swap(idx1: int, idx2: int)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

TxnID320258398[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)TxnID</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   leastSigBits: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   mostSigBits: long [1]</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

TxnMetaImpl1462729559[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)TxnMetaImpl</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   ackedPartitions: Set&lt;TransactionSubscription&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   openTimestamp: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   producedPartitions: Set&lt;String&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   timeoutAt: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   txnID: TxnID [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   txnStatus: TxnStatus [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ ackedPartitions(): List&lt;TransactionSubscription&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ addAckedPartitions(partitions: List&lt;TransactionSubscription&gt;): TxnMetaImpl</TD></TR>
<TR><TD ALIGN="LEFT" >+ addProducedPartitions(partitions: List&lt;String&gt;): TxnMetaImpl</TD></TR>
<TR><TD ALIGN="LEFT" >- checkTxnStatus(expectedStatus: TxnStatus)</TD></TR>
<TR><TD ALIGN="LEFT" >+ id(): TxnID</TD></TR>
<TR><TD ALIGN="LEFT" >+ producedPartitions(): List&lt;String&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ status(): TxnStatus</TD></TR>
<TR><TD ALIGN="LEFT" >+ updateTxnStatus(newStatus: TxnStatus, expectedStatus: TxnStatus): TxnMetaImpl</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

TypedMessageBuilderImpl12001400[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)TypedMessageBuilderImpl&lt;T&gt;</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   content: ByteBuffer [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   msgMetadata: MessageMetadata [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   producer: ProducerBase&lt;?&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   schema: Schema&lt;T&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   txn: TransactionImpl [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- beforeSend(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ deliverAfter(delay: long, unit: TimeUnit): TypedMessageBuilder&lt;T&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ deliverAt(timestamp: long): TypedMessageBuilder&lt;T&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ disableReplication(): TypedMessageBuilder&lt;T&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ eventTime(timestamp: long): TypedMessageBuilder&lt;T&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ key(key: String): TypedMessageBuilder&lt;T&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ keyBytes(key: byte[]): TypedMessageBuilder&lt;T&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ loadConf(config: Map&lt;String, Object&gt;): TypedMessageBuilder&lt;T&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ orderingKey(orderingKey: byte[]): TypedMessageBuilder&lt;T&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ properties(properties: Map&lt;String, String&gt;): TypedMessageBuilder&lt;T&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ property(name: String, value: String): TypedMessageBuilder&lt;T&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ replicationClusters(clusters: List&lt;String&gt;): TypedMessageBuilder&lt;T&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ send(): MessageId</TD></TR>
<TR><TD ALIGN="LEFT" >+ sendAsync(): CompletableFuture&lt;MessageId&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ sequenceId(sequenceId: long): TypedMessageBuilder&lt;T&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ value(value: T): TypedMessageBuilder&lt;T&gt;</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

UnsupportedVersionException1254029274[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)UnsupportedVersionException</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

WRRPlacementStrategy109292786[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)WRRPlacementStrategy</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   rand: Random [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ findBrokerForPlacement(finalCandidates: Multimap&lt;Long, ResourceUnit&gt;): ResourceUnit</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

WebTargets1292556772[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)WebTargets</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># addParts(target: WebTarget, parts: String[]): WebTarget</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

Worker620988779[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)Worker</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ drain()</TD></TR>
<TR><TD ALIGN="LEFT" >+ drainAtLeader(workerId: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ getDrainStatusFromLeader(workerId: String): LongRunningProcessStatus</TD></TR>
<TR><TD ALIGN="LEFT" >+ rebalance()</TD></TR>
<TR><TD ALIGN="LEFT" ># workers(): Workers&lt;? extends WorkerService&gt;</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

WorkerStats620988779[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)WorkerStats</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ workers(): Workers&lt;? extends WorkerService&gt;</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

WorkerStatsManager1316119764[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)WorkerStatsManager</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   _drainTotalExecutionTime: Child [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _rebalanceStrategyExecutionTime: Child [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _rebalanceTotalExecutionTime: Child [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _scheduleStrategyExecutionTime: Child [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _scheduleTotalExecutionTime: Child [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _startInstanceProcessTime: Child [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _statNumInstances: Child [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _statWorkerStartupTime: Child [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   _stopInstanceProcessTime: Child [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   collectorRegistry: CollectorRegistry [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   drainTotalExecTimeStart: Long [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   drainTotalExecutionTime: Summary [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   functionMetaDataManager: FunctionMetaDataManager [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   functionRuntimeManager: FunctionRuntimeManager [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   isLeader: Supplier&lt;Boolean&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   leaderService: LeaderService [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   metricsLabels: String[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   rebalanceStrategyExecTimeStart: Long [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   rebalanceStrategyExecutionTime: Summary [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   rebalanceTotalExecTimeStart: Long [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   rebalanceTotalExecutionTime: Summary [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   scheduleStrategyExecTimeStart: Long [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   scheduleStrategyExecutionTime: Summary [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   scheduleTotalExecTimeStart: Long [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   scheduleTotalExecutionTime: Summary [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   startInstanceProcessTime: Summary [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   startInstanceProcessTimeStart: Long [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   startupTimeStart: Long [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   statNumInstances: Gauge [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   statWorkerStartupTime: Summary [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   stopInstanceProcessTime: Summary [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   stopInstanceProcessTimeStart: Long [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ drainTotalExecTimeEnd()</TD></TR>
<TR><TD ALIGN="LEFT" >+ drainTotalExecTimeStart()</TD></TR>
<TR><TD ALIGN="LEFT" >- generateLeaderMetrics(stream: StringWriter)</TD></TR>
<TR><TD ALIGN="LEFT" >+ rebalanceStrategyExecTimeEnd()</TD></TR>
<TR><TD ALIGN="LEFT" >+ rebalanceStrategyExecTimeStart()</TD></TR>
<TR><TD ALIGN="LEFT" >+ rebalanceTotalExecTimeEnd()</TD></TR>
<TR><TD ALIGN="LEFT" >+ rebalanceTotalExecTimeStart()</TD></TR>
<TR><TD ALIGN="LEFT" >+ scheduleStrategyExecTimeStartEnd()</TD></TR>
<TR><TD ALIGN="LEFT" >+ scheduleStrategyExecTimeStartStart()</TD></TR>
<TR><TD ALIGN="LEFT" >+ scheduleTotalExecTimeEnd()</TD></TR>
<TR><TD ALIGN="LEFT" >+ scheduleTotalExecTimeStart()</TD></TR>
<TR><TD ALIGN="LEFT" >+ startInstanceProcessTimeEnd()</TD></TR>
<TR><TD ALIGN="LEFT" >+ startInstanceProcessTimeStart()</TD></TR>
<TR><TD ALIGN="LEFT" >+ startupTimeEnd()</TD></TR>
<TR><TD ALIGN="LEFT" >+ startupTimeStart()</TD></TR>
<TR><TD ALIGN="LEFT" >+ stopInstanceProcessTimeEnd()</TD></TR>
<TR><TD ALIGN="LEFT" >+ stopInstanceProcessTimeStart()</TD></TR>
<TR><TD ALIGN="LEFT" >- writeMetric(metricName: String, value: long, stream: StringWriter)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

WrappedVersionedSchema2009232385[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)WrappedVersionedSchema&lt;T&gt;</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   parent: AbstractStructSchema&lt;T&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   schemaVersion: byte[] [0..*]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ decode(bytes: byte[]): T</TD></TR>
<TR><TD ALIGN="LEFT" >+ decode(byteBuf: ByteBuf): T</TD></TR>
<TR><TD ALIGN="LEFT" >+ encode(message: T): byte[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ requireFetchingSchemaInfo(): boolean</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

WriteInEventLoopCallback1331407256[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)WriteInEventLoopCallback</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   cmd: ByteBufPair [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   cnx: ClientCnx [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   op: OpSendMsg [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   producer: ProducerImpl&lt;?&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   recyclerHandle: Handle&lt;WriteInEventLoopCallback&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   sequenceId: long [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># create(producer: ProducerImpl&lt;?&gt;, cnx: ClientCnx, op: OpSendMsg): WriteInEventLoopCallback</TD></TR>
<TR><TD ALIGN="LEFT" >- recycle()</TD></TR>
<TR><TD ALIGN="LEFT" >+ run()</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

ZKMetadataStore437280412[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)ZKMetadataStore</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   isZkManaged: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   metadataStoreConfig: MetadataStoreConfig [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   sessionWatcher: Optional&lt;ZKSessionWatcher&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   zkConnectString: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   zkc: ZooKeeper [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- asyncCreateFullPathOptimistic(zk: ZooKeeper, originalPath: String, data: byte[], createMode: CreateMode, callback: StringCallback)</TD></TR>
<TR><TD ALIGN="LEFT" ># batchOperation(ops: List&lt;MetadataOp&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >- convertOp(op: MetadataOp): Op</TD></TR>
<TR><TD ALIGN="LEFT" >- createFullPathOptimistic(zkc: ZooKeeper, path: String, data: byte[], createMode: CreateMode)</TD></TR>
<TR><TD ALIGN="LEFT" >+ existsFromStore(path: String): CompletableFuture&lt;Boolean&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- getCreateMode(options: EnumSet&lt;CreateOption&gt;): CreateMode</TD></TR>
<TR><TD ALIGN="LEFT" >- getException(code: Code, path: String): MetadataStoreException</TD></TR>
<TR><TD ALIGN="LEFT" >- getStat(path: String, zkStat: Stat): Stat</TD></TR>
<TR><TD ALIGN="LEFT" >- handleDeleteResult(op: OpDelete, opr: OpResult)</TD></TR>
<TR><TD ALIGN="LEFT" >- handleGetChildrenResult(op: OpGetChildren, opr: OpResult)</TD></TR>
<TR><TD ALIGN="LEFT" >- handleGetResult(op: OpGet, opr: OpResult)</TD></TR>
<TR><TD ALIGN="LEFT" >- handlePutResult(op: OpPut, opr: OpResult)</TD></TR>
<TR><TD ALIGN="LEFT" >- handleWatchEvent(event: WatchedEvent)</TD></TR>
<TR><TD ALIGN="LEFT" >+ initializeCluster(): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- internalStoreDelete(op: OpDelete)</TD></TR>
<TR><TD ALIGN="LEFT" >- internalStorePut(opPut: OpPut)</TD></TR>
<TR><TD ALIGN="LEFT" ># receivedSessionEvent(event: SessionEvent)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

ZeroQueueConsumerImpl12001400[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)ZeroQueueConsumerImpl&lt;T&gt;</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   waitingOnListenerForZeroQueueSize: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   waitingOnReceiveForZeroQueueSize: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   zeroQueueLock: Lock [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># canEnqueueMessage(message: Message&lt;T&gt;): boolean</TD></TR>
<TR><TD ALIGN="LEFT" ># consumerIsReconnectedToBroker(cnx: ClientCnx, currentQueueSize: int)</TD></TR>
<TR><TD ALIGN="LEFT" >- fetchSingleMessageFromBroker(): Message&lt;T&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># internalReceive(): Message&lt;T&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># internalReceiveAsync(): CompletableFuture&lt;Message&lt;T&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># receiveIndividualMessagesFromBatch(brokerEntryMetadata: BrokerEntryMetadata, msgMetadata: MessageMetadata, redeliveryCount: int, ackSet: List&lt;Long&gt;, uncompressedPayload: ByteBuf, messageId: MessageIdData, cnx: ClientCnx, consumerEpoch: long)</TD></TR>
<TR><TD ALIGN="LEFT" ># triggerListener()</TD></TR>
<TR><TD ALIGN="LEFT" >- triggerZeroQueueSizeListener(message: Message&lt;T&gt;)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];
} 

subgraph cluster_91979707 { 
   	label=bookkeeper
	labeljust=l
	fillcolor="#d8d8d8"
	style=filled
   
   BackedInputStream1619784327[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)BackedInputStream</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ seek(position: long)</TD></TR>
<TR><TD ALIGN="LEFT" >+ seekForward(position: long)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

BatchedEntryDeletionIndexInfo1682746216[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)BatchedEntryDeletionIndexInfo</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   bitField0_: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   deleteSet_: LongList [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   memoizedIsInitialized: byte [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   position_: NestedPositionInfo [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ getDeleteSet(index: int): long</TD></TR>
<TR><TD ALIGN="LEFT" ># internalGetFieldAccessorTable(): FieldAccessorTable</TD></TR>
<TR><TD ALIGN="LEFT" >+ newBuilder(): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ newBuilder(prototype: BatchedEntryDeletionIndexInfo): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ newBuilderForType(): Builder</TD></TR>
<TR><TD ALIGN="LEFT" ># newBuilderForType(parent: BuilderParent): Builder</TD></TR>
<TR><TD ALIGN="LEFT" ># newInstance(unused: UnusedPrivateParameter): Object</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseDelimitedFrom(input: InputStream): BatchedEntryDeletionIndexInfo</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseDelimitedFrom(input: InputStream, extensionRegistry: ExtensionRegistryLite): BatchedEntryDeletionIndexInfo</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(data: ByteBuffer): BatchedEntryDeletionIndexInfo</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(data: ByteBuffer, extensionRegistry: ExtensionRegistryLite): BatchedEntryDeletionIndexInfo</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(data: ByteString): BatchedEntryDeletionIndexInfo</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(data: ByteString, extensionRegistry: ExtensionRegistryLite): BatchedEntryDeletionIndexInfo</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(data: byte[]): BatchedEntryDeletionIndexInfo</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(data: byte[], extensionRegistry: ExtensionRegistryLite): BatchedEntryDeletionIndexInfo</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(input: InputStream): BatchedEntryDeletionIndexInfo</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(input: InputStream, extensionRegistry: ExtensionRegistryLite): BatchedEntryDeletionIndexInfo</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(input: CodedInputStream): BatchedEntryDeletionIndexInfo</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(input: CodedInputStream, extensionRegistry: ExtensionRegistryLite): BatchedEntryDeletionIndexInfo</TD></TR>
<TR><TD ALIGN="LEFT" >+ parser(): Parser&lt;BatchedEntryDeletionIndexInfo&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ toBuilder(): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeTo(output: CodedOutputStream)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

BlobStoreBackedReadHandleImpl381677195[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)BlobStoreBackedReadHandleImpl</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   dataStream: DataInputStream [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   executor: ExecutorService [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   index: OffloadIndexBlock [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   inputStream: BackedInputStream [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   ledgerId: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   state: State [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ closeAsync(): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ open(executor: ScheduledExecutorService, blobStore: BlobStore, bucket: String, key: String, indexKey: String, versionCheck: VersionCheck, ledgerId: long, readBufferSize: int): ReadHandle</TD></TR>
<TR><TD ALIGN="LEFT" >+ readAsync(firstEntry: long, lastEntry: long): CompletableFuture&lt;LedgerEntries&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ readLastAddConfirmedAndEntryAsync(entryId: long, timeOutInMillis: long, parallel: boolean): CompletableFuture&lt;LastConfirmedAndEntry&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ readLastAddConfirmedAsync(): CompletableFuture&lt;Long&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ readUnconfirmedAsync(firstEntry: long, lastEntry: long): CompletableFuture&lt;LedgerEntries&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ tryReadLastAddConfirmedAsync(): CompletableFuture&lt;Long&gt;</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

BlobStoreBackedReadHandleImplV2381677195[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)BlobStoreBackedReadHandleImplV2</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   dataStreams: List&lt;DataInputStream&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   executor: ExecutorService [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   indices: List&lt;OffloadIndexBlockV2&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   inputStreams: List&lt;BackedInputStream&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   ledgerId: long [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ closeAsync(): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- getGroupedReader(firstEntry: long, lastEntry: long): List&lt;GroupedReader&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ open(executor: ScheduledExecutorService, blobStore: BlobStore, bucket: String, keys: List&lt;String&gt;, indexKeys: List&lt;String&gt;, versionCheck: VersionCheck, ledgerId: long, readBufferSize: int): ReadHandle</TD></TR>
<TR><TD ALIGN="LEFT" >+ readAsync(firstEntry: long, lastEntry: long): CompletableFuture&lt;LedgerEntries&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ readLastAddConfirmedAndEntryAsync(entryId: long, timeOutInMillis: long, parallel: boolean): CompletableFuture&lt;LastConfirmedAndEntry&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ readLastAddConfirmedAsync(): CompletableFuture&lt;Long&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ readUnconfirmedAsync(firstEntry: long, lastEntry: long): CompletableFuture&lt;LedgerEntries&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ tryReadLastAddConfirmedAsync(): CompletableFuture&lt;Long&gt;</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

BlobStoreLocation502334150[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)BlobStoreLocation</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   bucket: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   endpoint: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   providerName: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   region: String [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># canEqual(other: Object): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ getBucket(offloadDriverMetadata: Map&lt;String, String&gt;): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ getEndpoint(offloadDriverMetadata: Map&lt;String, String&gt;): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ getProvider(offloadDriverMetadata: Map&lt;String, String&gt;): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ getRegion(offloadDriverMetadata: Map&lt;String, String&gt;): String</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

BlobStoreManagedLedgerOffloader381677195[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)BlobStoreManagedLedgerOffloader</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   blobStore: BlobStore [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   blobStores: ConcurrentMap&lt;BlobStoreLocation, BlobStore&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   bufferLength: AtomicLong [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   config: TieredStorageConfiguration [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   lastOfferedPosition: PositionImpl [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   maxBufferLength: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   maxSegmentCloseTime: Duration [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   maxSegmentLength: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   minSegmentCloseTimeMillis: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   ml: ManagedLedger [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   offloadBuffer: ConcurrentLinkedQueue&lt;Entry&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   offloadResult: CompletableFuture&lt;OffloadResult&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   scheduler: OrderedScheduler [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   segmentBeginTimeMillis: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   segmentInfo: OffloadSegmentInfoImpl [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   segmentLength: AtomicLong [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   streamingBlockSize: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   streamingDataBlockKey: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   streamingDataIndexKey: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   streamingIndexBuilder: OffloadIndexBlockV2Builder [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   streamingMpu: MultipartUpload [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   streamingParts: List&lt;MultipartPart&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   userMetadata: Map&lt;String, String&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   writeLocation: Location [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- buildBlockAndUpload(blockSize: int, entries: List&lt;Entry&gt;, blockLedgerId: long, beginEntryId: long, partId: int)</TD></TR>
<TR><TD ALIGN="LEFT" >- buildIndexAndCompleteResult(dataObjectLength: long)</TD></TR>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >- closeSegment(): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ create(config: TieredStorageConfiguration, userMetadata: Map&lt;String, String&gt;, scheduler: OrderedScheduler): BlobStoreManagedLedgerOffloader</TD></TR>
<TR><TD ALIGN="LEFT" >+ deleteOffloaded(ledgerId: long, uid: UUID, offloadDriverMetadata: Map&lt;String, String&gt;): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ deleteOffloaded(uid: UUID, offloadDriverMetadata: Map&lt;String, String&gt;): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- getBlobStoreLocation(offloadDriverMetadata: Map&lt;String, String&gt;): BlobStoreLocation</TD></TR>
<TR><TD ALIGN="LEFT" >- lastOffered(): PositionImpl</TD></TR>
<TR><TD ALIGN="LEFT" >- offerEntry(entry: Entry): OfferEntryResult</TD></TR>
<TR><TD ALIGN="LEFT" >+ offload(readHandle: ReadHandle, uuid: UUID, extraMetadata: Map&lt;String, String&gt;): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ readOffloaded(ledgerId: long, uid: UUID, offloadDriverMetadata: Map&lt;String, String&gt;): CompletableFuture&lt;ReadHandle&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ readOffloaded(ledgerId: long, ledgerContext: OffloadContext, offloadDriverMetadata: Map&lt;String, String&gt;): CompletableFuture&lt;ReadHandle&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ streamingOffload(ml: ManagedLedger, uuid: UUID, beginLedger: long, beginEntry: long, driverMetadata: Map&lt;String, String&gt;): CompletableFuture&lt;OffloadHandle&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- streamingOffloadLoop(partId: int, dataObjectLength: int)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

BlockAwareSegmentInputStream1619784327[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)BlockAwareSegmentInputStream</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

BlockAwareSegmentInputStreamImpl381677195[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)BlockAwareSegmentInputStreamImpl</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   blockEntryCount: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   blockSize: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   bytesReadOffset: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   dataBlockFullOffset: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   dataBlockHeaderStream: InputStream [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   entriesByteBuf: List&lt;ByteBuf&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   ledger: ReadHandle [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   startEntryId: long [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ calculateBlockSize(maxBlockSize: int, readHandle: ReadHandle, firstEntryToWrite: long, entryBytesAlreadyWritten: long): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ read(): int</TD></TR>
<TR><TD ALIGN="LEFT" >- readEntries(): int</TD></TR>
<TR><TD ALIGN="LEFT" >- readNextEntriesFromLedger(start: long, maxNumberEntries: long): List&lt;ByteBuf&gt;</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

BufferedOffloadStream381677195[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)BufferedOffloadStream</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   beginEntryId: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   blockHead: InputStream [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   blockSize: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   currentEntry: CompositeByteBuf [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   endEntryId: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   entryBuffer: List&lt;Entry&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   ledgerId: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   offset: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   validDataOffset: int [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ calculateBlockSize(streamingBlockSize: int, entryCount: int, entrySize: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ read(): int</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

Builder140384045[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)Builder</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   batchedEntryDeletionIndexInfoBuilder_: RepeatedFieldBuilderV3&lt;BatchedEntryDeletionIndexInfo, Builder, BatchedEntryDeletionIndexInfoOrBuilder&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   batchedEntryDeletionIndexInfo_: List&lt;BatchedEntryDeletionIndexInfo&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   bitField0_: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   entryId_: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   individualDeletedMessagesBuilder_: RepeatedFieldBuilderV3&lt;MessageRange, Builder, MessageRangeOrBuilder&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   individualDeletedMessages_: List&lt;MessageRange&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   ledgerId_: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   propertiesBuilder_: RepeatedFieldBuilderV3&lt;LongProperty, Builder, LongPropertyOrBuilder&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   properties_: List&lt;LongProperty&gt; [0..*]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ addAllBatchedEntryDeletionIndexInfo(values: Iterable&lt;? extends BatchedEntryDeletionIndexInfo&gt;): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ addAllIndividualDeletedMessages(values: Iterable&lt;? extends MessageRange&gt;): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ addAllProperties(values: Iterable&lt;? extends LongProperty&gt;): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ addBatchedEntryDeletionIndexInfo(value: BatchedEntryDeletionIndexInfo): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ addBatchedEntryDeletionIndexInfo(index: int, value: BatchedEntryDeletionIndexInfo): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ addBatchedEntryDeletionIndexInfo(builderForValue: Builder): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ addBatchedEntryDeletionIndexInfo(index: int, builderForValue: Builder): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ addBatchedEntryDeletionIndexInfoBuilder(): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ addBatchedEntryDeletionIndexInfoBuilder(index: int): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ addIndividualDeletedMessages(value: MessageRange): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ addIndividualDeletedMessages(index: int, value: MessageRange): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ addIndividualDeletedMessages(builderForValue: Builder): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ addIndividualDeletedMessages(index: int, builderForValue: Builder): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ addIndividualDeletedMessagesBuilder(): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ addIndividualDeletedMessagesBuilder(index: int): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ addProperties(value: LongProperty): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ addProperties(index: int, value: LongProperty): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ addProperties(builderForValue: Builder): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ addProperties(index: int, builderForValue: Builder): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ addPropertiesBuilder(): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ addPropertiesBuilder(index: int): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ addRepeatedField(field: FieldDescriptor, value: Object): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ build(): PositionInfo</TD></TR>
<TR><TD ALIGN="LEFT" >+ buildPartial(): PositionInfo</TD></TR>
<TR><TD ALIGN="LEFT" >+ clear(): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearBatchedEntryDeletionIndexInfo(): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearEntryId(): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearField(field: FieldDescriptor): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearIndividualDeletedMessages(): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearLedgerId(): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearOneof(oneof: OneofDescriptor): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearProperties(): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ clone(): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >- ensureBatchedEntryDeletionIndexInfoIsMutable()</TD></TR>
<TR><TD ALIGN="LEFT" >- ensureIndividualDeletedMessagesIsMutable()</TD></TR>
<TR><TD ALIGN="LEFT" >- ensurePropertiesIsMutable()</TD></TR>
<TR><TD ALIGN="LEFT" >+ getBatchedEntryDeletionIndexInfo(index: int): BatchedEntryDeletionIndexInfo</TD></TR>
<TR><TD ALIGN="LEFT" >+ getBatchedEntryDeletionIndexInfoBuilder(index: int): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ getBatchedEntryDeletionIndexInfoOrBuilder(index: int): BatchedEntryDeletionIndexInfoOrBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ getIndividualDeletedMessages(index: int): MessageRange</TD></TR>
<TR><TD ALIGN="LEFT" >+ getIndividualDeletedMessagesBuilder(index: int): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ getIndividualDeletedMessagesOrBuilder(index: int): MessageRangeOrBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ getProperties(index: int): LongProperty</TD></TR>
<TR><TD ALIGN="LEFT" >+ getPropertiesBuilder(index: int): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ getPropertiesOrBuilder(index: int): LongPropertyOrBuilder</TD></TR>
<TR><TD ALIGN="LEFT" ># internalGetFieldAccessorTable(): FieldAccessorTable</TD></TR>
<TR><TD ALIGN="LEFT" >- maybeForceBuilderInitialization()</TD></TR>
<TR><TD ALIGN="LEFT" >+ mergeFrom(other: Message): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ mergeFrom(other: PositionInfo): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ mergeFrom(input: CodedInputStream, extensionRegistry: ExtensionRegistryLite): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ mergeUnknownFields(unknownFields: UnknownFieldSet): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ removeBatchedEntryDeletionIndexInfo(index: int): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ removeIndividualDeletedMessages(index: int): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ removeProperties(index: int): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ setBatchedEntryDeletionIndexInfo(index: int, value: BatchedEntryDeletionIndexInfo): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ setBatchedEntryDeletionIndexInfo(index: int, builderForValue: Builder): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ setEntryId(value: long): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ setField(field: FieldDescriptor, value: Object): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ setIndividualDeletedMessages(index: int, value: MessageRange): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ setIndividualDeletedMessages(index: int, builderForValue: Builder): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ setLedgerId(value: long): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ setProperties(index: int, value: LongProperty): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ setProperties(index: int, builderForValue: Builder): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ setRepeatedField(field: FieldDescriptor, index: int, value: Object): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ setUnknownFields(unknownFields: UnknownFieldSet): Builder</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

Builder854020549[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)Builder</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   bitField0_: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   entries_: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   ledgerId_: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   offloadContextBuilder_: SingleFieldBuilderV3&lt;OffloadContext, Builder, OffloadContextOrBuilder&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   offloadContext_: OffloadContext [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   size_: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   timestamp_: long [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ addRepeatedField(field: FieldDescriptor, value: Object): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ build(): LedgerInfo</TD></TR>
<TR><TD ALIGN="LEFT" >+ buildPartial(): LedgerInfo</TD></TR>
<TR><TD ALIGN="LEFT" >+ clear(): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearEntries(): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearField(field: FieldDescriptor): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearLedgerId(): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearOffloadContext(): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearOneof(oneof: OneofDescriptor): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearSize(): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearTimestamp(): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ clone(): Builder</TD></TR>
<TR><TD ALIGN="LEFT" ># internalGetFieldAccessorTable(): FieldAccessorTable</TD></TR>
<TR><TD ALIGN="LEFT" >- maybeForceBuilderInitialization()</TD></TR>
<TR><TD ALIGN="LEFT" >+ mergeFrom(other: Message): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ mergeFrom(other: LedgerInfo): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ mergeFrom(input: CodedInputStream, extensionRegistry: ExtensionRegistryLite): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ mergeOffloadContext(value: OffloadContext): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ mergeUnknownFields(unknownFields: UnknownFieldSet): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ setEntries(value: long): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ setField(field: FieldDescriptor, value: Object): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ setLedgerId(value: long): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ setOffloadContext(value: OffloadContext): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ setOffloadContext(builderForValue: Builder): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ setRepeatedField(field: FieldDescriptor, index: int, value: Object): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ setSize(value: long): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ setTimestamp(value: long): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ setUnknownFields(unknownFields: UnknownFieldSet): Builder</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

CloseFuture1733299833[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)CloseFuture</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ closeComplete(ctx: Object)</TD></TR>
<TR><TD ALIGN="LEFT" >+ closeFailed(exception: ManagedLedgerException, ctx: Object)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

DataBlockUtils381677195[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)DataBlockUtils</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ addVersionInfo(blobBuilder: BlobBuilder, userMetadata: Map&lt;String, String&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ dataBlockOffloadKey(ledgerId: long, uuid: UUID): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ indexBlockOffloadKey(ledgerId: long, uuid: UUID): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ indexBlockOffloadKey(uuid: UUID): String</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

DefaultBkFactory1746234011[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)DefaultBkFactory</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   bkClient: BookKeeper [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ get(policy: EnsemblePlacementPolicyConfig): BookKeeper</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

EntryCacheManager997059435[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)EntryCacheManager</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   cacheEvictionWatermark: double [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   caches: ConcurrentMap&lt;String, EntryCache&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   currentSize: AtomicLong [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   evictionInProgress: AtomicBoolean [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   evictionPolicy: EntryCacheEvictionPolicy [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   evictionTriggerThreshold: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   maxSize: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   mlFactory: ManagedLedgerFactoryImpl [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   mlFactoryMBean: ManagedLedgerFactoryMBeanImpl [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ clear()</TD></TR>
<TR><TD ALIGN="LEFT" >+ create(ledgerId: long, entryId: long, data: ByteBuf): Entry</TD></TR>
<TR><TD ALIGN="LEFT" >+ create(ledgerEntry: LedgerEntry, interceptor: ManagedLedgerInterceptor): EntryImpl</TD></TR>
<TR><TD ALIGN="LEFT" ># entriesRemoved(size: long)</TD></TR>
<TR><TD ALIGN="LEFT" ># entryAdded(size: long)</TD></TR>
<TR><TD ALIGN="LEFT" >+ getEntryCache(ml: ManagedLedgerImpl): EntryCache</TD></TR>
<TR><TD ALIGN="LEFT" ># removeEntryCache(name: String)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

EntryImpl997059435[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)EntryImpl</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   data: ByteBuf [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   entryId: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   ledgerId: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   recyclerHandle: Handle&lt;EntryImpl&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   timestamp: long [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ compareTo(other: EntryImpl): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ create(ledgerEntry: LedgerEntry): EntryImpl</TD></TR>
<TR><TD ALIGN="LEFT" >+ create(ledgerId: long, entryId: long, data: byte[]): EntryImpl</TD></TR>
<TR><TD ALIGN="LEFT" >+ create(ledgerId: long, entryId: long, data: ByteBuf): EntryImpl</TD></TR>
<TR><TD ALIGN="LEFT" >+ create(position: PositionImpl, data: ByteBuf): EntryImpl</TD></TR>
<TR><TD ALIGN="LEFT" >+ create(other: EntryImpl): EntryImpl</TD></TR>
<TR><TD ALIGN="LEFT" ># deallocate()</TD></TR>
<TR><TD ALIGN="LEFT" >+ touch(hint: Object): ReferenceCounted</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

Errors996695433[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)Errors</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ isNoSuchLedgerExistsException(rc: int): boolean</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

FileStoreBackedReadHandleImpl1944580565[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)FileStoreBackedReadHandleImpl</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   executor: ExecutorService [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   ledgerId: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   ledgerMetadata: LedgerMetadata [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   reader: Reader [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ closeAsync(): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ open(executor: ScheduledExecutorService, reader: Reader, ledgerId: long): ReadHandle</TD></TR>
<TR><TD ALIGN="LEFT" >+ readAsync(firstEntry: long, lastEntry: long): CompletableFuture&lt;LedgerEntries&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ readLastAddConfirmedAndEntryAsync(entryId: long, timeOutInMillis: long, parallel: boolean): CompletableFuture&lt;LastConfirmedAndEntry&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ readLastAddConfirmedAsync(): CompletableFuture&lt;Long&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ readUnconfirmedAsync(firstEntry: long, lastEntry: long): CompletableFuture&lt;LedgerEntries&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ tryReadLastAddConfirmedAsync(): CompletableFuture&lt;Long&gt;</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

FileSystemManagedLedgerOffloader1944580565[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)FileSystemManagedLedgerOffloader</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   assignmentScheduler: OrderedScheduler [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   configuration: Configuration [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   driverName: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   fileSystem: FileSystem [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   offloadPolicies: OffloadPoliciesImpl [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   scheduler: OrderedScheduler [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   storageBasePath: String [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ create(conf: OffloadPoliciesImpl, scheduler: OrderedScheduler): FileSystemManagedLedgerOffloader</TD></TR>
<TR><TD ALIGN="LEFT" >+ deleteOffloaded(ledgerId: long, uid: UUID, offloadDriverMetadata: Map&lt;String, String&gt;): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ driverSupported(driver: String): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >- getDataFilePath(storagePath: String, ledgerId: long, uuid: UUID): String</TD></TR>
<TR><TD ALIGN="LEFT" >- getStoragePath(storageBasePath: String, managedLedgerName: String): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ offload(readHandle: ReadHandle, uuid: UUID, extraMetadata: Map&lt;String, String&gt;): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ readOffloaded(ledgerId: long, uuid: UUID, offloadDriverMetadata: Map&lt;String, String&gt;): CompletableFuture&lt;ReadHandle&gt;</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

Futures996695433[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)Futures</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ waitForAll(futures: List&lt;CompletableFuture&lt;Void&gt;&gt;): CompletableFuture&lt;Void&gt;</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

LedgerInfo912267968[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)LedgerInfo</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   bitField0_: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   entries_: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   ledgerId_: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   memoizedIsInitialized: byte [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   offloadContext_: OffloadContext [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   size_: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   timestamp_: long [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># internalGetFieldAccessorTable(): FieldAccessorTable</TD></TR>
<TR><TD ALIGN="LEFT" >+ newBuilder(): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ newBuilder(prototype: LedgerInfo): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ newBuilderForType(): Builder</TD></TR>
<TR><TD ALIGN="LEFT" ># newBuilderForType(parent: BuilderParent): Builder</TD></TR>
<TR><TD ALIGN="LEFT" ># newInstance(unused: UnusedPrivateParameter): Object</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseDelimitedFrom(input: InputStream): LedgerInfo</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseDelimitedFrom(input: InputStream, extensionRegistry: ExtensionRegistryLite): LedgerInfo</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(data: ByteBuffer): LedgerInfo</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(data: ByteBuffer, extensionRegistry: ExtensionRegistryLite): LedgerInfo</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(data: ByteString): LedgerInfo</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(data: ByteString, extensionRegistry: ExtensionRegistryLite): LedgerInfo</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(data: byte[]): LedgerInfo</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(data: byte[], extensionRegistry: ExtensionRegistryLite): LedgerInfo</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(input: InputStream): LedgerInfo</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(input: InputStream, extensionRegistry: ExtensionRegistryLite): LedgerInfo</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(input: CodedInputStream): LedgerInfo</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(input: CodedInputStream, extensionRegistry: ExtensionRegistryLite): LedgerInfo</TD></TR>
<TR><TD ALIGN="LEFT" >+ parser(): Parser&lt;LedgerInfo&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ toBuilder(): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeTo(output: CodedOutputStream)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

LedgerMetadataUtils997059435[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)LedgerMetadataUtils</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># buildAdditionalMetadataForCursor(name: String): Map&lt;String, byte[]&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># buildBaseManagedLedgerMetadata(name: String): Map&lt;String, byte[]&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ buildMetadataForCompactedLedger(compactedTopic: String, compactedToMessageId: byte[]): Map&lt;String, byte[]&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># buildMetadataForPlacementPolicyConfig(className: Class&lt;? extends EnsemblePlacementPolicy&gt;, properties: Map&lt;String, Object&gt;): Map&lt;String, byte[]&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ buildMetadataForSchema(schemaId: String): Map&lt;String, byte[]&gt;</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

LongProperty1682746216[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)LongProperty</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   bitField0_: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   memoizedIsInitialized: byte [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   name_: Object [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   value_: long [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># internalGetFieldAccessorTable(): FieldAccessorTable</TD></TR>
<TR><TD ALIGN="LEFT" >+ newBuilder(): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ newBuilder(prototype: LongProperty): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ newBuilderForType(): Builder</TD></TR>
<TR><TD ALIGN="LEFT" ># newBuilderForType(parent: BuilderParent): Builder</TD></TR>
<TR><TD ALIGN="LEFT" ># newInstance(unused: UnusedPrivateParameter): Object</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseDelimitedFrom(input: InputStream): LongProperty</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseDelimitedFrom(input: InputStream, extensionRegistry: ExtensionRegistryLite): LongProperty</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(data: ByteBuffer): LongProperty</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(data: ByteBuffer, extensionRegistry: ExtensionRegistryLite): LongProperty</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(data: ByteString): LongProperty</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(data: ByteString, extensionRegistry: ExtensionRegistryLite): LongProperty</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(data: byte[]): LongProperty</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(data: byte[], extensionRegistry: ExtensionRegistryLite): LongProperty</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(input: InputStream): LongProperty</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(input: InputStream, extensionRegistry: ExtensionRegistryLite): LongProperty</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(input: CodedInputStream): LongProperty</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(input: CodedInputStream, extensionRegistry: ExtensionRegistryLite): LongProperty</TD></TR>
<TR><TD ALIGN="LEFT" >+ parser(): Parser&lt;LongProperty&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ toBuilder(): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeTo(output: CodedOutputStream)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

ManagedCursorImpl997059435[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)ManagedCursorImpl</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   alwaysInactive: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   batchDeletedIndexes: ConcurrentSkipListMap&lt;PositionImpl, BitSetRecyclable&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >#   bookkeeper: BookKeeper [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   clock: Clock [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   config: ManagedLedgerConfig [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   cursorLedger: LedgerHandle [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   cursorLedgerStat: Stat [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   digestType: DigestType [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   entriesReadCount: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   entriesReadSize: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   individualDeletedMessages: LongPairRangeSet&lt;PositionImpl&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   individualDeletedMessagesSerializedSize: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   isCursorLedgerReadOnly: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   isDirty: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   lastActive: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   lastLedgerSwitchTimestamp: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   lastMarkDeleteEntry: MarkDeleteEntry [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   ledger: ManagedLedgerImpl [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   lock: ReadWriteLock [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   markDeleteLimiter: RateLimiter [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   markDeletePosition: PositionImpl [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   mbean: ManagedCursorMXBean [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   messagesConsumedCounter: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   name: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   pendingMarkDeleteOps: ArrayDeque&lt;MarkDeleteEntry&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   pendingMarkDeletedSubmittedCount: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   pendingReadOps: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   persistentMarkDeletePosition: PositionImpl [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   readPosition: PositionImpl [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   resetCursorInProgress: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   state: State [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   statsLastReadPosition: PositionImpl [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   waitingReadOp: OpReadEntry [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- applyMaxSizeCap(maxEntries: int, maxSizeBytes: long): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ asyncClearBacklog(callback: ClearBacklogCallback, ctx: Object)</TD></TR>
<TR><TD ALIGN="LEFT" >+ asyncClose(callback: CloseCallback, ctx: Object)</TD></TR>
<TR><TD ALIGN="LEFT" ># asyncCloseCursorLedger(callback: CloseCallback, ctx: Object)</TD></TR>
<TR><TD ALIGN="LEFT" >+ asyncDelete(pos: Position, callback: DeleteCallback, ctx: Object)</TD></TR>
<TR><TD ALIGN="LEFT" >+ asyncDelete(positions: Iterable&lt;Position&gt;, callback: DeleteCallback, ctx: Object)</TD></TR>
<TR><TD ALIGN="LEFT" ># asyncDeleteCursorLedger()</TD></TR>
<TR><TD ALIGN="LEFT" >- asyncDeleteCursorLedger(retry: int)</TD></TR>
<TR><TD ALIGN="LEFT" ># asyncDeleteLedger(lh: LedgerHandle)</TD></TR>
<TR><TD ALIGN="LEFT" >- asyncDeleteLedger(lh: LedgerHandle, retry: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ asyncFindNewestMatching(constraint: FindPositionConstraint, condition: Predicate&lt;Entry&gt;, callback: FindEntryCallback, ctx: Object)</TD></TR>
<TR><TD ALIGN="LEFT" >+ asyncGetNthEntry(n: int, deletedEntries: IndividualDeletedEntries, callback: ReadEntryCallback, ctx: Object)</TD></TR>
<TR><TD ALIGN="LEFT" >+ asyncMarkDelete(position: Position, callback: MarkDeleteCallback, ctx: Object)</TD></TR>
<TR><TD ALIGN="LEFT" >+ asyncMarkDelete(position: Position, properties: Map&lt;String, Long&gt;, callback: MarkDeleteCallback, ctx: Object)</TD></TR>
<TR><TD ALIGN="LEFT" >+ asyncReadEntries(numberOfEntriesToRead: int, callback: ReadEntriesCallback, ctx: Object, maxPosition: PositionImpl)</TD></TR>
<TR><TD ALIGN="LEFT" >+ asyncReadEntries(numberOfEntriesToRead: int, maxSizeBytes: long, callback: ReadEntriesCallback, ctx: Object, maxPosition: PositionImpl)</TD></TR>
<TR><TD ALIGN="LEFT" >+ asyncReadEntriesOrWait(numberOfEntriesToRead: int, callback: ReadEntriesCallback, ctx: Object, maxPosition: PositionImpl)</TD></TR>
<TR><TD ALIGN="LEFT" >+ asyncReadEntriesOrWait(maxEntries: int, maxSizeBytes: long, callback: ReadEntriesCallback, ctx: Object, maxPosition: PositionImpl)</TD></TR>
<TR><TD ALIGN="LEFT" >+ asyncReplayEntries(positions: Set&lt;? extends Position&gt;, callback: ReadEntriesCallback, ctx: Object): Set&lt;? extends Position&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ asyncReplayEntries(positions: Set&lt;? extends Position&gt;, callback: ReadEntriesCallback, ctx: Object, sortEntries: boolean): Set&lt;? extends Position&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ asyncResetCursor(newPos: Position, forceReset: boolean, callback: ResetCursorCallback)</TD></TR>
<TR><TD ALIGN="LEFT" >+ asyncSkipEntries(numEntriesToSkip: int, deletedEntries: IndividualDeletedEntries, callback: SkipEntriesCallback, ctx: Object)</TD></TR>
<TR><TD ALIGN="LEFT" >- buildBatchEntryDeletionIndexInfoList(): List&lt;BatchedEntryDeletionIndexInfo&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- buildIndividualDeletedMessageRanges(): List&lt;MessageRange&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- buildPropertiesMap(properties: Map&lt;String, Long&gt;): List&lt;LongProperty&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ cancelPendingReadRequest(): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ checkAndUpdateReadPositionChanged(): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >- checkForNewEntries(op: OpReadEntry, callback: ReadEntriesCallback, ctx: Object)</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearBacklog()</TD></TR>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" ># createNewMetadataLedger()</TD></TR>
<TR><TD ALIGN="LEFT" ># createNewMetadataLedger(callback: VoidCallback)</TD></TR>
<TR><TD ALIGN="LEFT" >- cursorImpl(): ManagedCursorImpl</TD></TR>
<TR><TD ALIGN="LEFT" ># decrementPendingMarkDeleteCount()</TD></TR>
<TR><TD ALIGN="LEFT" >+ delete(position: Position)</TD></TR>
<TR><TD ALIGN="LEFT" >+ delete(positions: Iterable&lt;Position&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" ># filterReadEntries(entries: List&lt;Entry&gt;): List&lt;Entry&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ findNewestMatching(condition: Predicate&lt;Entry&gt;): Position</TD></TR>
<TR><TD ALIGN="LEFT" >+ findNewestMatching(constraint: FindPositionConstraint, condition: Predicate&lt;Entry&gt;): Position</TD></TR>
<TR><TD ALIGN="LEFT" ># flush()</TD></TR>
<TR><TD ALIGN="LEFT" >- flushPendingMarkDeletes()</TD></TR>
<TR><TD ALIGN="LEFT" >+ getBatchPositionAckSet(position: Position): long[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ getDeletedBatchIndexesAsLongArray(position: PositionImpl): long[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ getNextAvailablePosition(position: PositionImpl): PositionImpl</TD></TR>
<TR><TD ALIGN="LEFT" >+ getNextLedgerPosition(currentLedgerId: long): Position</TD></TR>
<TR><TD ALIGN="LEFT" >+ getNthEntry(n: int, deletedEntries: IndividualDeletedEntries): Entry</TD></TR>
<TR><TD ALIGN="LEFT" ># getNumIndividualDeletedEntriesToSkip(numEntries: long): long</TD></TR>
<TR><TD ALIGN="LEFT" ># getNumberOfEntries(range: Range&lt;PositionImpl&gt;): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ getNumberOfEntriesInBacklog(isPrecise: boolean): long</TD></TR>
<TR><TD ALIGN="LEFT" >- getRollbackPosition(info: ManagedCursorInfo): PositionImpl</TD></TR>
<TR><TD ALIGN="LEFT" ># hasMoreEntries(position: PositionImpl): boolean</TD></TR>
<TR><TD ALIGN="LEFT" ># initialize(position: PositionImpl, properties: Map&lt;String, Long&gt;, callback: VoidCallback)</TD></TR>
<TR><TD ALIGN="LEFT" ># initializeCursorPosition(lastPositionCounter: Pair&lt;PositionImpl, Long&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" ># internalAsyncMarkDelete(newPosition: PositionImpl, properties: Map&lt;String, Long&gt;, callback: MarkDeleteCallback, ctx: Object)</TD></TR>
<TR><TD ALIGN="LEFT" ># internalFlushPendingMarkDeletes()</TD></TR>
<TR><TD ALIGN="LEFT" ># internalMarkDelete(mdEntry: MarkDeleteEntry)</TD></TR>
<TR><TD ALIGN="LEFT" ># internalResetCursor(position: PositionImpl, resetCursorCallback: ResetCursorCallback)</TD></TR>
<TR><TD ALIGN="LEFT" >+ isBkErrorNotRecoverable(rc: int): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ isMessageDeleted(position: Position): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ markDelete(position: Position)</TD></TR>
<TR><TD ALIGN="LEFT" >+ markDelete(position: Position, properties: Map&lt;String, Long&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" ># notifyEntriesAvailable()</TD></TR>
<TR><TD ALIGN="LEFT" >- persistPositionMetaStore(cursorsLedgerId: long, position: PositionImpl, properties: Map&lt;String, Long&gt;, callback: MetaStoreCallback&lt;Void&gt;, persistIndividualDeletedMessageRanges: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" ># persistPositionToLedger(lh: LedgerHandle, mdEntry: MarkDeleteEntry, callback: VoidCallback)</TD></TR>
<TR><TD ALIGN="LEFT" ># persistPositionWhenClosing(position: PositionImpl, properties: Map&lt;String, Long&gt;, callback: CloseCallback, ctx: Object)</TD></TR>
<TR><TD ALIGN="LEFT" >+ putProperty(key: String, value: Long): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ readEntries(numberOfEntriesToRead: int): List&lt;Entry&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ readEntriesOrWait(numberOfEntriesToRead: int): List&lt;Entry&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ readEntriesOrWait(numberOfEntriesToRead: int, maxSizeBytes: long): List&lt;Entry&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># readOperationCompleted()</TD></TR>
<TR><TD ALIGN="LEFT" ># recover(callback: VoidCallback)</TD></TR>
<TR><TD ALIGN="LEFT" >- recoverBatchDeletedIndexes(batchDeletedIndexInfoList: List&lt;BatchedEntryDeletionIndexInfo&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" ># recoverFromLedger(info: ManagedCursorInfo, callback: VoidCallback)</TD></TR>
<TR><TD ALIGN="LEFT" >- recoverIndividualDeletedMessages(individualDeletedMessagesList: List&lt;MessageRange&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >- recoveredCursor(position: PositionImpl, properties: Map&lt;String, Long&gt;, recoveredFromCursorLedger: LedgerHandle)</TD></TR>
<TR><TD ALIGN="LEFT" >+ removeProperty(key: String): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ replayEntries(positions: Set&lt;? extends Position&gt;): List&lt;Entry&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ resetCursor(newPos: Position)</TD></TR>
<TR><TD ALIGN="LEFT" >+ rewind()</TD></TR>
<TR><TD ALIGN="LEFT" >+ seek(newReadPositionInt: Position, force: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" ># setAcknowledgedPosition(newMarkDeletePosition: PositionImpl): PositionImpl</TD></TR>
<TR><TD ALIGN="LEFT" ># shouldCloseLedger(lh: LedgerHandle): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >- shouldPersistUnackRangesToLedger(): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ skipEntries(numEntriesToSkip: int, deletedEntries: IndividualDeletedEntries)</TD></TR>
<TR><TD ALIGN="LEFT" ># startCreatingNewMetadataLedger()</TD></TR>
<TR><TD ALIGN="LEFT" ># switchToNewLedger(lh: LedgerHandle, callback: VoidCallback)</TD></TR>
<TR><TD ALIGN="LEFT" >+ trimDeletedEntries(entries: List&lt;Entry&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ updateLastActive()</TD></TR>
<TR><TD ALIGN="LEFT" ># updateReadStats(readEntriesCount: int, readEntriesSize: long)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

ManagedCursorInfo1682746216[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)ManagedCursorInfo</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   batchedEntryDeletionIndexInfo_: List&lt;BatchedEntryDeletionIndexInfo&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   bitField0_: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   cursorsLedgerId_: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   individualDeletedMessages_: List&lt;MessageRange&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   lastActive_: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   markDeleteEntryId_: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   markDeleteLedgerId_: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   memoizedIsInitialized: byte [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   properties_: List&lt;LongProperty&gt; [0..*]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ getBatchedEntryDeletionIndexInfo(index: int): BatchedEntryDeletionIndexInfo</TD></TR>
<TR><TD ALIGN="LEFT" >+ getBatchedEntryDeletionIndexInfoOrBuilder(index: int): BatchedEntryDeletionIndexInfoOrBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ getIndividualDeletedMessages(index: int): MessageRange</TD></TR>
<TR><TD ALIGN="LEFT" >+ getIndividualDeletedMessagesOrBuilder(index: int): MessageRangeOrBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ getProperties(index: int): LongProperty</TD></TR>
<TR><TD ALIGN="LEFT" >+ getPropertiesOrBuilder(index: int): LongPropertyOrBuilder</TD></TR>
<TR><TD ALIGN="LEFT" ># internalGetFieldAccessorTable(): FieldAccessorTable</TD></TR>
<TR><TD ALIGN="LEFT" >+ newBuilder(): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ newBuilder(prototype: ManagedCursorInfo): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ newBuilderForType(): Builder</TD></TR>
<TR><TD ALIGN="LEFT" ># newBuilderForType(parent: BuilderParent): Builder</TD></TR>
<TR><TD ALIGN="LEFT" ># newInstance(unused: UnusedPrivateParameter): Object</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseDelimitedFrom(input: InputStream): ManagedCursorInfo</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseDelimitedFrom(input: InputStream, extensionRegistry: ExtensionRegistryLite): ManagedCursorInfo</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(data: ByteBuffer): ManagedCursorInfo</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(data: ByteBuffer, extensionRegistry: ExtensionRegistryLite): ManagedCursorInfo</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(data: ByteString): ManagedCursorInfo</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(data: ByteString, extensionRegistry: ExtensionRegistryLite): ManagedCursorInfo</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(data: byte[]): ManagedCursorInfo</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(data: byte[], extensionRegistry: ExtensionRegistryLite): ManagedCursorInfo</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(input: InputStream): ManagedCursorInfo</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(input: InputStream, extensionRegistry: ExtensionRegistryLite): ManagedCursorInfo</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(input: CodedInputStream): ManagedCursorInfo</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(input: CodedInputStream, extensionRegistry: ExtensionRegistryLite): ManagedCursorInfo</TD></TR>
<TR><TD ALIGN="LEFT" >+ parser(): Parser&lt;ManagedCursorInfo&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ toBuilder(): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeTo(output: CodedOutputStream)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

ManagedCursorMXBeanImpl997059435[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)ManagedCursorMXBeanImpl</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   managedCursor: ManagedCursor [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   persistLedgeFailed: LongAdder [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   persistLedgeSucceed: LongAdder [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   persistZookeeperFailed: LongAdder [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   persistZookeeperSucceed: LongAdder [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   readCursorLedgerSize: LongAdder [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   writeCursorLedgerLogicalSize: LongAdder [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   writeCursorLedgerSize: LongAdder [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ addReadCursorLedgerSize(size: long)</TD></TR>
<TR><TD ALIGN="LEFT" >+ addWriteCursorLedgerSize(size: long)</TD></TR>
<TR><TD ALIGN="LEFT" >+ persistToLedger(success: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ persistToZookeeper(success: boolean)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

ManagedLedgerConfig359962201[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)ManagedLedgerConfig</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   ackQuorumSize: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   addEntryTimeoutSeconds: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   autoSkipNonRecoverableData: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   bookKeeperEnsemblePlacementPolicyClassName: Class&lt;? extends EnsemblePlacementPolicy&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   bookKeeperEnsemblePlacementPolicyProperties: Map&lt;String, Object&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   clock: Clock [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   createIfMissing: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   deletionAtBatchIndexLevelEnabled: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   digestType: DigestType [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   ensembleSize: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   inactiveLedgerRollOverTimeMs: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   lazyCursorRecovery: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   ledgerOffloader: LedgerOffloader [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   ledgerRolloverTimeout: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   managedLedgerInterceptor: ManagedLedgerInterceptor [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   maxBatchDeletedIndexToPersist: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   maxEntriesPerLedger: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   maxSizePerLedgerMb: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   maxUnackedRangesToPersist: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   maxUnackedRangesToPersistInZk: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   maximumRolloverTimeMs: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   metadataAckQuorumSize: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   metadataEnsembleSize: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   metadataMaxEntriesPerLedger: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   metadataOperationsTimeoutSeconds: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   metadataWriteQuorumSize: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   minimumRolloverTimeMs: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   newEntriesCheckDelayInMillis: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   password: byte[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   properties: Map&lt;String, String&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   readEntryTimeoutSeconds: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   retentionSizeInMB: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   retentionTimeMs: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   throttleMarkDelete: double [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   unackedRangesOpenCacheSetEnabled: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   writeQuorumSize: int [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ setAckQuorumSize(ackQuorumSize: int): ManagedLedgerConfig</TD></TR>
<TR><TD ALIGN="LEFT" >+ setAddEntryTimeoutSeconds(addEntryTimeoutSeconds: long): ManagedLedgerConfig</TD></TR>
<TR><TD ALIGN="LEFT" >+ setClock(clock: Clock): ManagedLedgerConfig</TD></TR>
<TR><TD ALIGN="LEFT" >+ setCreateIfMissing(createIfMissing: boolean): ManagedLedgerConfig</TD></TR>
<TR><TD ALIGN="LEFT" >+ setDigestType(digestType: DigestType): ManagedLedgerConfig</TD></TR>
<TR><TD ALIGN="LEFT" >+ setEnsembleSize(ensembleSize: int): ManagedLedgerConfig</TD></TR>
<TR><TD ALIGN="LEFT" >+ setLazyCursorRecovery(lazyCursorRecovery: boolean): ManagedLedgerConfig</TD></TR>
<TR><TD ALIGN="LEFT" >+ setLedgerOffloader(offloader: LedgerOffloader): ManagedLedgerConfig</TD></TR>
<TR><TD ALIGN="LEFT" >+ setLedgerRolloverTimeout(ledgerRolloverTimeout: int): ManagedLedgerConfig</TD></TR>
<TR><TD ALIGN="LEFT" >+ setMaxEntriesPerLedger(maxEntriesPerLedger: int): ManagedLedgerConfig</TD></TR>
<TR><TD ALIGN="LEFT" >+ setMaxSizePerLedgerMb(maxSizePerLedgerMb: int): ManagedLedgerConfig</TD></TR>
<TR><TD ALIGN="LEFT" >+ setMaxUnackedRangesToPersist(maxUnackedRangesToPersist: int): ManagedLedgerConfig</TD></TR>
<TR><TD ALIGN="LEFT" >+ setMetadataAckQuorumSize(metadataAckQuorumSize: int): ManagedLedgerConfig</TD></TR>
<TR><TD ALIGN="LEFT" >+ setMetadataEnsembleSize(metadataEnsembleSize: int): ManagedLedgerConfig</TD></TR>
<TR><TD ALIGN="LEFT" >+ setMetadataMaxEntriesPerLedger(metadataMaxEntriesPerLedger: int): ManagedLedgerConfig</TD></TR>
<TR><TD ALIGN="LEFT" >+ setMetadataOperationsTimeoutSeconds(metadataOperationsTimeoutSeconds: long): ManagedLedgerConfig</TD></TR>
<TR><TD ALIGN="LEFT" >+ setMetadataWriteQuorumSize(metadataWriteQuorumSize: int): ManagedLedgerConfig</TD></TR>
<TR><TD ALIGN="LEFT" >+ setPassword(password: String): ManagedLedgerConfig</TD></TR>
<TR><TD ALIGN="LEFT" >+ setReadEntryTimeoutSeconds(readEntryTimeoutSeconds: long): ManagedLedgerConfig</TD></TR>
<TR><TD ALIGN="LEFT" >+ setRetentionSizeInMB(retentionSizeInMB: long): ManagedLedgerConfig</TD></TR>
<TR><TD ALIGN="LEFT" >+ setRetentionTime(retentionTime: int, unit: TimeUnit): ManagedLedgerConfig</TD></TR>
<TR><TD ALIGN="LEFT" >+ setThrottleMarkDelete(throttleMarkDelete: double): ManagedLedgerConfig</TD></TR>
<TR><TD ALIGN="LEFT" >+ setUnackedRangesOpenCacheSetEnabled(unackedRangesOpenCacheSetEnabled: boolean): ManagedLedgerConfig</TD></TR>
<TR><TD ALIGN="LEFT" >+ setWriteQuorumSize(writeQuorumSize: int): ManagedLedgerConfig</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

ManagedLedgerException359962201[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)ManagedLedgerException</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ fillInStackTrace(): Throwable</TD></TR>
<TR><TD ALIGN="LEFT" >+ getManagedLedgerException(e: Throwable): ManagedLedgerException</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

ManagedLedgerFactoryConfig359962201[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)ManagedLedgerFactoryConfig</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   cacheEvictionFrequency: double [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   cacheEvictionTimeThresholdMillis: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   cacheEvictionWatermark: double [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   clusterName: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   copyEntriesInCache: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   cursorPositionFlushSeconds: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   managedLedgerInfoCompressionType: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   maxCacheSize: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   numManagedLedgerSchedulerThreads: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   numManagedLedgerWorkerThreads: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   prometheusStatsLatencyRolloverSeconds: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   statsPeriodSeconds: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   traceTaskExecution: boolean [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># canEqual(other: Object): boolean</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

ManagedLedgerFactoryImpl997059435[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)ManagedLedgerFactoryImpl</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   bookkeeperFactory: BookkeeperFactoryForCustomEnsemblePlacementPolicy [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   cacheEvictionExecutor: ExecutorService [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   cacheEvictionTimeThresholdNanos: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   closed: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   config: ManagedLedgerFactoryConfig [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   entryCacheManager: EntryCacheManager [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   flushCursorsTask: ScheduledFuture&lt;?&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   isBookkeeperManaged: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   lastStatTimestamp: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   ledgers: ConcurrentHashMap&lt;String, CompletableFuture&lt;ManagedLedgerImpl&gt;&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >#   mbean: ManagedLedgerFactoryMBeanImpl [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   metadataServiceAvailable: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   metadataStore: MetadataStore [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   pendingInitializeLedgers: ConcurrentHashMap&lt;String, PendingInitializeManagedLedger&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >#   scheduledExecutor: OrderedScheduler [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   statsTask: ScheduledFuture&lt;?&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   store: MetaStore [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ asyncDelete(name: String, callback: DeleteLedgerCallback, ctx: Object)</TD></TR>
<TR><TD ALIGN="LEFT" >+ asyncExists(ledgerName: String): CompletableFuture&lt;Boolean&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ asyncGetManagedLedgerInfo(name: String, callback: ManagedLedgerInfoCallback, ctx: Object)</TD></TR>
<TR><TD ALIGN="LEFT" >+ asyncOpen(name: String, callback: OpenLedgerCallback, ctx: Object)</TD></TR>
<TR><TD ALIGN="LEFT" >+ asyncOpen(name: String, config: ManagedLedgerConfig, callback: OpenLedgerCallback, mlOwnershipChecker: Supplier&lt;Boolean&gt;, ctx: Object)</TD></TR>
<TR><TD ALIGN="LEFT" >+ asyncOpenReadOnlyCursor(managedLedgerName: String, startPosition: Position, config: ManagedLedgerConfig, callback: OpenReadOnlyCursorCallback, ctx: Object)</TD></TR>
<TR><TD ALIGN="LEFT" >- cacheEvictionTask()</TD></TR>
<TR><TD ALIGN="LEFT" ># close(ledger: ManagedLedger)</TD></TR>
<TR><TD ALIGN="LEFT" >+ delete(name: String)</TD></TR>
<TR><TD ALIGN="LEFT" >- deleteCursor(bkc: BookKeeper, managedLedgerName: String, cursorName: String, cursor: CursorInfo): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># deleteManagedLedger(managedLedgerName: String, callback: DeleteLedgerCallback, ctx: Object)</TD></TR>
<TR><TD ALIGN="LEFT" >- deleteManagedLedgerData(bkc: BookKeeper, managedLedgerName: String, info: ManagedLedgerInfo, callback: DeleteLedgerCallback, ctx: Object)</TD></TR>
<TR><TD ALIGN="LEFT" >- doCacheEviction()</TD></TR>
<TR><TD ALIGN="LEFT" >- flushCursors()</TD></TR>
<TR><TD ALIGN="LEFT" >+ getManagedLedgerInfo(name: String): ManagedLedgerInfo</TD></TR>
<TR><TD ALIGN="LEFT" >- handleMetadataStoreNotification(e: SessionEvent)</TD></TR>
<TR><TD ALIGN="LEFT" >+ open(name: String): ManagedLedger</TD></TR>
<TR><TD ALIGN="LEFT" >+ open(name: String, config: ManagedLedgerConfig): ManagedLedger</TD></TR>
<TR><TD ALIGN="LEFT" >+ openReadOnlyCursor(managedLedgerName: String, startPosition: Position, config: ManagedLedgerConfig): ReadOnlyCursor</TD></TR>
<TR><TD ALIGN="LEFT" >- refreshStats()</TD></TR>
<TR><TD ALIGN="LEFT" >+ shutdown()</TD></TR>
<TR><TD ALIGN="LEFT" >+ shutdownAsync(): CompletableFuture&lt;Void&gt;</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

ManagedLedgerFactoryMBeanImpl997059435[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)ManagedLedgerFactoryMBeanImpl</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   cacheEvictions: Rate [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   cacheHits: Rate [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   cacheMisses: Rate [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   factory: ManagedLedgerFactoryImpl [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ recordCacheEviction()</TD></TR>
<TR><TD ALIGN="LEFT" >+ recordCacheHit(size: long)</TD></TR>
<TR><TD ALIGN="LEFT" >+ recordCacheHits(count: int, totalSize: long)</TD></TR>
<TR><TD ALIGN="LEFT" >+ recordCacheMiss(count: int, totalSize: long)</TD></TR>
<TR><TD ALIGN="LEFT" >+ refreshStats(period: long, unit: TimeUnit)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

ManagedLedgerImpl997059435[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)ManagedLedgerImpl</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   activeCursors: ManagedCursorContainer [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   addOpCount: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   bookKeeper: BookKeeper [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   checkLedgerRollTask: ScheduledFuture&lt;?&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   clock: Clock [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   config: ManagedLedgerConfig [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   createdLedgerCustomMetadata: Map&lt;String, byte[]&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   currentLedger: LedgerHandle [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   currentLedgerEntries: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   currentLedgerSize: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   cursors: ManagedCursorContainer [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   digestType: DigestType [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   entriesAddedCounter: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   entryCache: EntryCache [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   executor: OrderedExecutor [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   factory: ManagedLedgerFactoryImpl [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   inactiveLedgerRollOverTimeMs: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   lastAddEntryTimeMs: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   lastConfirmedEntry: PositionImpl [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   lastLedgerCreatedTimestamp: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   lastLedgerCreationFailureTimestamp: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   lastLedgerCreationInitiationTimestamp: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   lastOffloadFailureTimestamp: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   lastOffloadLedgerId: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   lastOffloadSuccessTimestamp: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   lastReadCallback: ReadEntryCallbackWrapper [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   ledgerCache: ConcurrentLongHashMap&lt;CompletableFuture&lt;ReadHandle&gt;&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   ledgerMetadata: Map&lt;String, byte[]&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >#   ledgers: NavigableMap&lt;Long, LedgerInfo&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   ledgersStat: Stat [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   managedLedgerInterceptor: ManagedLedgerInterceptor [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   maximumRolloverTimeMs: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   mbean: ManagedLedgerMBeanImpl [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   metadataMutex: CallbackMutex [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   mlOwnershipChecker: Supplier&lt;Boolean&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   name: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   nonDurableActiveCursors: ManagedCursorContainer [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   numberOfEntries: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   offloadMutex: CallbackMutex [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   pendingAddEntries: ConcurrentLinkedQueue&lt;OpAddEntry&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >#   propertiesMap: Map&lt;String, String&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   readOpCount: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   scheduledExecutor: OrderedScheduler [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   state: State [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   store: MetaStore [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   timeoutTask: ScheduledFuture&lt;?&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   totalSize: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   trimmerMutex: CallbackMutex [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   uninitializedCursors: Map&lt;String, CompletableFuture&lt;ManagedCursor&gt;&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >#   waitingCursors: ConcurrentLinkedQueue&lt;ManagedCursorImpl&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >#   waitingEntryCallBacks: ConcurrentLinkedQueue&lt;WaitingEntryCallBack&gt; [0..*]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ activateCursor(cursor: ManagedCursor)</TD></TR>
<TR><TD ALIGN="LEFT" >+ addEntry(data: byte[]): Position</TD></TR>
<TR><TD ALIGN="LEFT" >+ addEntry(data: byte[], numberOfMessages: int): Position</TD></TR>
<TR><TD ALIGN="LEFT" >+ addEntry(data: byte[], offset: int, length: int): Position</TD></TR>
<TR><TD ALIGN="LEFT" >+ addEntry(data: byte[], numberOfMessages: int, offset: int, length: int): Position</TD></TR>
<TR><TD ALIGN="LEFT" >+ addWaitingEntryCallBack(cb: WaitingEntryCallBack)</TD></TR>
<TR><TD ALIGN="LEFT" >- advanceCursorsIfNecessary(ledgersToDelete: List&lt;LedgerInfo&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ asyncAddEntry(data: byte[], callback: AddEntryCallback, ctx: Object)</TD></TR>
<TR><TD ALIGN="LEFT" >+ asyncAddEntry(data: byte[], offset: int, length: int, callback: AddEntryCallback, ctx: Object)</TD></TR>
<TR><TD ALIGN="LEFT" >+ asyncAddEntry(data: byte[], numberOfMessages: int, offset: int, length: int, callback: AddEntryCallback, ctx: Object)</TD></TR>
<TR><TD ALIGN="LEFT" >+ asyncAddEntry(buffer: ByteBuf, callback: AddEntryCallback, ctx: Object)</TD></TR>
<TR><TD ALIGN="LEFT" >+ asyncAddEntry(buffer: ByteBuf, numberOfMessages: int, callback: AddEntryCallback, ctx: Object)</TD></TR>
<TR><TD ALIGN="LEFT" >+ asyncClose(callback: CloseCallback, ctx: Object)</TD></TR>
<TR><TD ALIGN="LEFT" ># asyncCreateLedger(bookKeeper: BookKeeper, config: ManagedLedgerConfig, digestType: DigestType, cb: CreateCallback, metadata: Map&lt;String, byte[]&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ asyncDelete(callback: DeleteLedgerCallback, ctx: Object)</TD></TR>
<TR><TD ALIGN="LEFT" >+ asyncDeleteCursor(consumerName: String, callback: DeleteCursorCallback, ctx: Object)</TD></TR>
<TR><TD ALIGN="LEFT" >- asyncDeleteLedger(ledgerId: long, info: LedgerInfo)</TD></TR>
<TR><TD ALIGN="LEFT" >- asyncDeleteLedger(ledgerId: long, retry: long)</TD></TR>
<TR><TD ALIGN="LEFT" >- asyncDeleteLedgerFromBookKeeper(ledgerId: long)</TD></TR>
<TR><TD ALIGN="LEFT" >+ asyncDeleteProperty(key: String, callback: UpdatePropertiesCallback, ctx: Object)</TD></TR>
<TR><TD ALIGN="LEFT" >+ asyncFindPosition(predicate: Predicate&lt;Entry&gt;): CompletableFuture&lt;Position&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ asyncOffloadPrefix(pos: Position, callback: OffloadCallback, ctx: Object)</TD></TR>
<TR><TD ALIGN="LEFT" >+ asyncOpenCursor(cursorName: String, callback: OpenCursorCallback, ctx: Object)</TD></TR>
<TR><TD ALIGN="LEFT" >+ asyncOpenCursor(cursorName: String, initialPosition: InitialPosition, callback: OpenCursorCallback, ctx: Object)</TD></TR>
<TR><TD ALIGN="LEFT" >+ asyncOpenCursor(cursorName: String, initialPosition: InitialPosition, properties: Map&lt;String, Long&gt;, callback: OpenCursorCallback, ctx: Object)</TD></TR>
<TR><TD ALIGN="LEFT" ># asyncReadEntries(opReadEntry: OpReadEntry)</TD></TR>
<TR><TD ALIGN="LEFT" >+ asyncReadEntry(position: PositionImpl, callback: ReadEntryCallback, ctx: Object)</TD></TR>
<TR><TD ALIGN="LEFT" ># asyncReadEntry(ledger: ReadHandle, position: PositionImpl, callback: ReadEntryCallback, ctx: Object)</TD></TR>
<TR><TD ALIGN="LEFT" ># asyncReadEntry(ledger: ReadHandle, firstEntry: long, lastEntry: long, isSlowestReader: boolean, opReadEntry: OpReadEntry, ctx: Object)</TD></TR>
<TR><TD ALIGN="LEFT" >+ asyncSetProperties(properties: Map&lt;String, String&gt;, callback: UpdatePropertiesCallback, ctx: Object)</TD></TR>
<TR><TD ALIGN="LEFT" >+ asyncSetProperty(key: String, value: String, callback: UpdatePropertiesCallback, ctx: Object)</TD></TR>
<TR><TD ALIGN="LEFT" >+ asyncTerminate(callback: TerminateCallback, ctx: Object)</TD></TR>
<TR><TD ALIGN="LEFT" >+ asyncTruncate(): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- asyncUpdateProperties(properties: Map&lt;String, String&gt;, isDelete: boolean, deleteKey: String, callback: UpdatePropertiesCallback, ctx: Object)</TD></TR>
<TR><TD ALIGN="LEFT" >- beforeAddEntry(addOperation: OpAddEntry): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >- buildManagedLedgerInfo(ledgers: Map&lt;Long, LedgerInfo&gt;): ManagedLedgerInfo</TD></TR>
<TR><TD ALIGN="LEFT" >- cancelScheduledTasks()</TD></TR>
<TR><TD ALIGN="LEFT" >- checkAddTimeout()</TD></TR>
<TR><TD ALIGN="LEFT" ># checkAndCompleteLedgerOpTask(rc: int, lh: LedgerHandle, ctx: Object): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >- checkFenced()</TD></TR>
<TR><TD ALIGN="LEFT" >+ checkInactiveLedgerAndRollOver()</TD></TR>
<TR><TD ALIGN="LEFT" >- checkManagedLedgerIsOpen()</TD></TR>
<TR><TD ALIGN="LEFT" >- checkReadTimeout()</TD></TR>
<TR><TD ALIGN="LEFT" >- cleanupOffloaded(ledgerId: long, uuid: UUID, offloadDriverName: String, offloadDriverMetadata: Map&lt;String, String&gt;, cleanupReason: String)</TD></TR>
<TR><TD ALIGN="LEFT" ># clearPendingAddEntries(e: ManagedLedgerException)</TD></TR>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >- closeAllCursors(callback: CloseCallback, ctx: Object)</TD></TR>
<TR><TD ALIGN="LEFT" >- completeLedgerInfoForOffloaded(ledgerId: long, uuid: UUID): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- consumedLedgerSize(ledgerSize: long, ledgerEntries: long, consumedEntries: long): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ createComplete(rc: int, lh: LedgerHandle, ctx: Object)</TD></TR>
<TR><TD ALIGN="LEFT" ># createLedgerAfterClosed()</TD></TR>
<TR><TD ALIGN="LEFT" >+ createManagedLedgerException(bkErrorCode: int): ManagedLedgerException</TD></TR>
<TR><TD ALIGN="LEFT" >+ createManagedLedgerException(t: Throwable): ManagedLedgerException</TD></TR>
<TR><TD ALIGN="LEFT" >- currentLedgerIsFull(): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ deactivateCursor(cursor: ManagedCursor)</TD></TR>
<TR><TD ALIGN="LEFT" >+ delete()</TD></TR>
<TR><TD ALIGN="LEFT" >- deleteAllLedgers(callback: DeleteLedgerCallback, ctx: Object)</TD></TR>
<TR><TD ALIGN="LEFT" >+ deleteCursor(name: String)</TD></TR>
<TR><TD ALIGN="LEFT" >- deleteMetadata(callback: DeleteLedgerCallback, ctx: Object)</TD></TR>
<TR><TD ALIGN="LEFT" >+ deleteProperty(key: String)</TD></TR>
<TR><TD ALIGN="LEFT" ># discardEntriesFromCache(cursor: ManagedCursorImpl, newPosition: PositionImpl)</TD></TR>
<TR><TD ALIGN="LEFT" ># doCacheEviction(maxTimestamp: long)</TD></TR>
<TR><TD ALIGN="LEFT" ># estimateBacklogFromPosition(pos: PositionImpl): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ getEarliestMessagePublishTimeOfPos(pos: PositionImpl): CompletableFuture&lt;Long&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getEnsemblesAsync(ledgerId: long): CompletableFuture&lt;Set&lt;BookieId&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getEstimatedBacklogSize(pos: PositionImpl): long</TD></TR>
<TR><TD ALIGN="LEFT" ># getLedgerHandle(ledgerId: long): CompletableFuture&lt;ReadHandle&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getLedgerInfo(ledgerId: long): CompletableFuture&lt;LedgerInfo&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getLedgerMetadata(ledgerId: long): CompletableFuture&lt;String&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getManagedLedgerInternalStats(includeLedgerMetadata: boolean): CompletableFuture&lt;ManagedLedgerInternalStats&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- getMaximumRolloverTimeMs(config: ManagedLedgerConfig): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ getNextValidLedger(ledgerId: long): Long</TD></TR>
<TR><TD ALIGN="LEFT" >+ getNextValidPosition(position: PositionImpl): PositionImpl</TD></TR>
<TR><TD ALIGN="LEFT" >+ getNextValidPositionInternal(position: PositionImpl): PositionImpl</TD></TR>
<TR><TD ALIGN="LEFT" ># getNumberOfEntries(range: Range&lt;PositionImpl&gt;): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ getPositionAfterN(startPosition: PositionImpl, n: long, startRange: PositionBound): PositionImpl</TD></TR>
<TR><TD ALIGN="LEFT" >+ getPreviousPosition(position: PositionImpl): PositionImpl</TD></TR>
<TR><TD ALIGN="LEFT" >- hasLedgerRetentionExpired(ledgerTimestamp: long): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ hasMoreEntries(position: PositionImpl): boolean</TD></TR>
<TR><TD ALIGN="LEFT" ># initialize(callback: ManagedLedgerInitializeLedgerCallback, ctx: Object)</TD></TR>
<TR><TD ALIGN="LEFT" >- initializeBookKeeper(callback: ManagedLedgerInitializeLedgerCallback)</TD></TR>
<TR><TD ALIGN="LEFT" >- initializeCursors(callback: ManagedLedgerInitializeLedgerCallback)</TD></TR>
<TR><TD ALIGN="LEFT" >- internalAsyncAddEntry(addOperation: OpAddEntry)</TD></TR>
<TR><TD ALIGN="LEFT" >- internalReadFromLedger(ledger: ReadHandle, opReadEntry: OpReadEntry)</TD></TR>
<TR><TD ALIGN="LEFT" ># internalTrimConsumedLedgers(promise: CompletableFuture&lt;?&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" ># internalTrimLedgers(isTruncate: boolean, promise: CompletableFuture&lt;?&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" ># invalidateLedgerHandle(ledgerHandle: ReadHandle)</TD></TR>
<TR><TD ALIGN="LEFT" ># invalidateReadHandle(ledgerId: long)</TD></TR>
<TR><TD ALIGN="LEFT" >- isBkErrorNotRecoverable(rc: int): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ isCursorActive(cursor: ManagedCursor): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >- isLedgerRetentionOverSizeQuota(sizeToDelete: long): boolean</TD></TR>
<TR><TD ALIGN="LEFT" ># isOffloadedNeedsDelete(offload: OffloadContext, offloadPolicies: Optional&lt;OffloadPolicies&gt;): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ isValidPosition(position: PositionImpl): boolean</TD></TR>
<TR><TD ALIGN="LEFT" ># ledgerClosed(lh: LedgerHandle)</TD></TR>
<TR><TD ALIGN="LEFT" >+ ledgerExists(ledgerId: long): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >- maybeOffload(finalPromise: CompletableFuture&lt;PositionImpl&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >- maybeOffloadInBackground(promise: CompletableFuture&lt;PositionImpl&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ maybeUpdateCursorBeforeTrimmingConsumedLedger()</TD></TR>
<TR><TD ALIGN="LEFT" >+ newNonDurableCursor(startCursorPosition: Position): ManagedCursor</TD></TR>
<TR><TD ALIGN="LEFT" >+ newNonDurableCursor(startPosition: Position, subscriptionName: String): ManagedCursor</TD></TR>
<TR><TD ALIGN="LEFT" >+ newNonDurableCursor(startCursorPosition: Position, cursorName: String, initialPosition: InitialPosition, isReadCompacted: boolean): ManagedCursor</TD></TR>
<TR><TD ALIGN="LEFT" ># notifyCursors()</TD></TR>
<TR><TD ALIGN="LEFT" ># notifyWaitingEntryCallBacks()</TD></TR>
<TR><TD ALIGN="LEFT" >- offloadLoop(promise: CompletableFuture&lt;PositionImpl&gt;, ledgersToOffload: Queue&lt;LedgerInfo&gt;, firstUnoffloaded: PositionImpl, firstError: Optional&lt;Throwable&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ offloadPrefix(pos: Position): Position</TD></TR>
<TR><TD ALIGN="LEFT" >+ openCursor(cursorName: String): ManagedCursor</TD></TR>
<TR><TD ALIGN="LEFT" >+ openCursor(cursorName: String, initialPosition: InitialPosition): ManagedCursor</TD></TR>
<TR><TD ALIGN="LEFT" >+ openCursor(cursorName: String, initialPosition: InitialPosition, properties: Map&lt;String, Long&gt;): ManagedCursor</TD></TR>
<TR><TD ALIGN="LEFT" >- prepareLedgerInfoForOffloaded(ledgerId: long, uuid: UUID, offloadDriverName: String, offloadDriverMetadata: Map&lt;String, String&gt;): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ readyToCreateNewLedger()</TD></TR>
<TR><TD ALIGN="LEFT" >+ removeWaitingCursor(cursor: ManagedCursor)</TD></TR>
<TR><TD ALIGN="LEFT" >+ rollCurrentLedgerIfFull()</TD></TR>
<TR><TD ALIGN="LEFT" >- scheduleDeferredTrimming(isTruncate: boolean, promise: CompletableFuture&lt;?&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >- scheduleTimeoutTask()</TD></TR>
<TR><TD ALIGN="LEFT" ># startReadOperationOnLedger(position: PositionImpl, opReadEntry: OpReadEntry): PositionImpl</TD></TR>
<TR><TD ALIGN="LEFT" >+ terminate(): Position</TD></TR>
<TR><TD ALIGN="LEFT" >- transformLedgerInfo(ledgerId: long, transformation: LedgerInfoTransformation): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- trimConsumedLedgersInBackground()</TD></TR>
<TR><TD ALIGN="LEFT" >+ trimConsumedLedgersInBackground(promise: CompletableFuture&lt;?&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ trimConsumedLedgersInBackground(isTruncate: boolean, promise: CompletableFuture&lt;?&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >- tryTransformLedgerInfo(ledgerId: long, transformation: LedgerInfoTransformation, finalPromise: CompletableFuture&lt;Void&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" ># updateCursor(cursor: ManagedCursorImpl, newPosition: PositionImpl)</TD></TR>
<TR><TD ALIGN="LEFT" >- updateLastLedgerCreatedTimeAndScheduleRolloverTask()</TD></TR>
<TR><TD ALIGN="LEFT" >+ updateLedgersIdsComplete(stat: Stat)</TD></TR>
<TR><TD ALIGN="LEFT" >- updateLedgersListAfterRollover(callback: MetaStoreCallback&lt;Void&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >- updateProperties(properties: Map&lt;String, String&gt;, isDelete: boolean, deleteKey: String)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

ManagedLedgerInfo1682746216[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)ManagedLedgerInfo</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   bitField0_: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   ledgerInfo_: List&lt;LedgerInfo&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   memoizedIsInitialized: byte [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   properties_: List&lt;KeyValue&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   terminatedPosition_: NestedPositionInfo [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ getLedgerInfo(index: int): LedgerInfo</TD></TR>
<TR><TD ALIGN="LEFT" >+ getLedgerInfoOrBuilder(index: int): LedgerInfoOrBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ getProperties(index: int): KeyValue</TD></TR>
<TR><TD ALIGN="LEFT" >+ getPropertiesOrBuilder(index: int): KeyValueOrBuilder</TD></TR>
<TR><TD ALIGN="LEFT" ># internalGetFieldAccessorTable(): FieldAccessorTable</TD></TR>
<TR><TD ALIGN="LEFT" >+ newBuilder(): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ newBuilder(prototype: ManagedLedgerInfo): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ newBuilderForType(): Builder</TD></TR>
<TR><TD ALIGN="LEFT" ># newBuilderForType(parent: BuilderParent): Builder</TD></TR>
<TR><TD ALIGN="LEFT" ># newInstance(unused: UnusedPrivateParameter): Object</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseDelimitedFrom(input: InputStream): ManagedLedgerInfo</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseDelimitedFrom(input: InputStream, extensionRegistry: ExtensionRegistryLite): ManagedLedgerInfo</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(data: ByteBuffer): ManagedLedgerInfo</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(data: ByteBuffer, extensionRegistry: ExtensionRegistryLite): ManagedLedgerInfo</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(data: ByteString): ManagedLedgerInfo</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(data: ByteString, extensionRegistry: ExtensionRegistryLite): ManagedLedgerInfo</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(data: byte[]): ManagedLedgerInfo</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(data: byte[], extensionRegistry: ExtensionRegistryLite): ManagedLedgerInfo</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(input: InputStream): ManagedLedgerInfo</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(input: InputStream, extensionRegistry: ExtensionRegistryLite): ManagedLedgerInfo</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(input: CodedInputStream): ManagedLedgerInfo</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(input: CodedInputStream, extensionRegistry: ExtensionRegistryLite): ManagedLedgerInfo</TD></TR>
<TR><TD ALIGN="LEFT" >+ parser(): Parser&lt;ManagedLedgerInfo&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ toBuilder(): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeTo(output: CodedOutputStream)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

ManagedLedgerMBeanImpl997059435[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)ManagedLedgerMBeanImpl</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   addEntryLatencyStatsUsec: StatsBuckets [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   addEntryOps: Rate [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   addEntryOpsFailed: Rate [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   addEntryWithReplicasOps: Rate [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   cursorLedgerCloseOp: LongAdder [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   cursorLedgerCreateOp: LongAdder [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   cursorLedgerDeleteOp: LongAdder [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   cursorLedgerOpenOp: LongAdder [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   dataLedgerCloseOp: LongAdder [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   dataLedgerCreateOp: LongAdder [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   dataLedgerDeleteOp: LongAdder [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   dataLedgerOpenOp: LongAdder [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   entryStats: StatsBuckets [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   ledgerAddEntryLatencyStatsUsec: StatsBuckets [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   ledgerSwitchLatencyStatsUsec: StatsBuckets [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   managedLedger: ManagedLedgerImpl [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   markDeleteOps: Rate [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   readEntriesOps: Rate [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   readEntriesOpsFailed: Rate [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ addAddEntryLatencySample(latency: long, unit: TimeUnit)</TD></TR>
<TR><TD ALIGN="LEFT" >+ addAddEntrySample(size: long)</TD></TR>
<TR><TD ALIGN="LEFT" >+ addLedgerAddEntryLatencySample(latency: long, unit: TimeUnit)</TD></TR>
<TR><TD ALIGN="LEFT" >+ addLedgerSwitchLatencySample(latency: long, unit: TimeUnit)</TD></TR>
<TR><TD ALIGN="LEFT" >+ addMarkDeleteOp()</TD></TR>
<TR><TD ALIGN="LEFT" >+ addReadEntriesSample(count: int, totalSize: long)</TD></TR>
<TR><TD ALIGN="LEFT" >+ endCursorLedgerCloseOp()</TD></TR>
<TR><TD ALIGN="LEFT" >+ endCursorLedgerCreateOp()</TD></TR>
<TR><TD ALIGN="LEFT" >+ endCursorLedgerDeleteOp()</TD></TR>
<TR><TD ALIGN="LEFT" >+ endCursorLedgerOpenOp()</TD></TR>
<TR><TD ALIGN="LEFT" >+ endDataLedgerCloseOp()</TD></TR>
<TR><TD ALIGN="LEFT" >+ endDataLedgerCreateOp()</TD></TR>
<TR><TD ALIGN="LEFT" >+ endDataLedgerDeleteOp()</TD></TR>
<TR><TD ALIGN="LEFT" >+ endDataLedgerOpenOp()</TD></TR>
<TR><TD ALIGN="LEFT" >+ recordAddEntryError()</TD></TR>
<TR><TD ALIGN="LEFT" >+ recordReadEntriesError()</TD></TR>
<TR><TD ALIGN="LEFT" >+ refreshStats(period: long, unit: TimeUnit)</TD></TR>
<TR><TD ALIGN="LEFT" >+ startCursorLedgerCloseOp()</TD></TR>
<TR><TD ALIGN="LEFT" >+ startCursorLedgerCreateOp()</TD></TR>
<TR><TD ALIGN="LEFT" >+ startCursorLedgerDeleteOp()</TD></TR>
<TR><TD ALIGN="LEFT" >+ startCursorLedgerOpenOp()</TD></TR>
<TR><TD ALIGN="LEFT" >+ startDataLedgerCloseOp()</TD></TR>
<TR><TD ALIGN="LEFT" >+ startDataLedgerCreateOp()</TD></TR>
<TR><TD ALIGN="LEFT" >+ startDataLedgerDeleteOp()</TD></TR>
<TR><TD ALIGN="LEFT" >+ startDataLedgerOpenOp()</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

ManagedLedgerOfflineBacklog997059435[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)ManagedLedgerOfflineBacklog</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   accurate: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   brokerName: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   digestType: DigestType [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   password: byte[] [0..*]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- calculateCursorBacklogs(factory: ManagedLedgerFactoryImpl, topicName: TopicName, ledgers: NavigableMap&lt;Long, LedgerInfo&gt;, offlineTopicStats: PersistentOfflineTopicStats)</TD></TR>
<TR><TD ALIGN="LEFT" >+ estimateUnloadedTopicBacklog(factory: ManagedLedgerFactoryImpl, topicName: TopicName): PersistentOfflineTopicStats</TD></TR>
<TR><TD ALIGN="LEFT" >+ getEstimatedUnloadedTopicBacklog(factory: ManagedLedgerFactoryImpl, managedLedgerName: String): PersistentOfflineTopicStats</TD></TR>
<TR><TD ALIGN="LEFT" >- getNumberOfEntries(range: Range&lt;PositionImpl&gt;, ledgers: NavigableMap&lt;Long, LedgerInfo&gt;): long</TD></TR>
<TR><TD ALIGN="LEFT" >- readLedgerMeta(factory: ManagedLedgerFactoryImpl, topicName: TopicName, ledgers: NavigableMap&lt;Long, LedgerInfo&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >- tryGetMDPosition(bookKeeper: BookKeeper, ledgerId: long, cursorName: String): PositionImpl</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

MarkDeleteEntry1810717276[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)MarkDeleteEntry</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   callback: MarkDeleteCallback [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   callbackGroup: List&lt;MarkDeleteEntry&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >#   ctx: Object [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   newPosition: PositionImpl [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   properties: Map&lt;String, Long&gt; [0..*]</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

MessageRange1682746216[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)MessageRange</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   bitField0_: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   lowerEndpoint_: NestedPositionInfo [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   memoizedIsInitialized: byte [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   upperEndpoint_: NestedPositionInfo [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># internalGetFieldAccessorTable(): FieldAccessorTable</TD></TR>
<TR><TD ALIGN="LEFT" >+ newBuilder(): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ newBuilder(prototype: MessageRange): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ newBuilderForType(): Builder</TD></TR>
<TR><TD ALIGN="LEFT" ># newBuilderForType(parent: BuilderParent): Builder</TD></TR>
<TR><TD ALIGN="LEFT" ># newInstance(unused: UnusedPrivateParameter): Object</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseDelimitedFrom(input: InputStream): MessageRange</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseDelimitedFrom(input: InputStream, extensionRegistry: ExtensionRegistryLite): MessageRange</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(data: ByteBuffer): MessageRange</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(data: ByteBuffer, extensionRegistry: ExtensionRegistryLite): MessageRange</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(data: ByteString): MessageRange</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(data: ByteString, extensionRegistry: ExtensionRegistryLite): MessageRange</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(data: byte[]): MessageRange</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(data: byte[], extensionRegistry: ExtensionRegistryLite): MessageRange</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(input: InputStream): MessageRange</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(input: InputStream, extensionRegistry: ExtensionRegistryLite): MessageRange</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(input: CodedInputStream): MessageRange</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(input: CodedInputStream, extensionRegistry: ExtensionRegistryLite): MessageRange</TD></TR>
<TR><TD ALIGN="LEFT" >+ parser(): Parser&lt;MessageRange&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ toBuilder(): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeTo(output: CodedOutputStream)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

MetaStoreImpl997059435[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)MetaStoreImpl</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   compressionType: CompressionType [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   executor: OrderedExecutor [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   store: MetadataStore [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ asyncExists(path: String): CompletableFuture&lt;Boolean&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ asyncGetCursorInfo(ledgerName: String, cursorName: String, callback: MetaStoreCallback&lt;ManagedCursorInfo&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ asyncRemoveCursor(ledgerName: String, cursorName: String, callback: MetaStoreCallback&lt;Void&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ asyncUpdateCursorInfo(ledgerName: String, cursorName: String, info: ManagedCursorInfo, stat: Stat, callback: MetaStoreCallback&lt;Void&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ asyncUpdateLedgerIds(ledgerName: String, mlInfo: ManagedLedgerInfo, stat: Stat, callback: MetaStoreCallback&lt;Void&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ compressLedgerInfo(managedLedgerInfo: ManagedLedgerInfo): byte[]</TD></TR>
<TR><TD ALIGN="LEFT" >- getCompressionCodec(compressionType: CompressionType): CompressionCodec</TD></TR>
<TR><TD ALIGN="LEFT" >+ getCursors(ledgerName: String, callback: MetaStoreCallback&lt;List&lt;String&gt;&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >- getException(t: Throwable): MetaStoreException</TD></TR>
<TR><TD ALIGN="LEFT" >+ getManagedLedgerInfo(ledgerName: String, createIfMissing: boolean, properties: Map&lt;String, String&gt;, callback: MetaStoreCallback&lt;ManagedLedgerInfo&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseManagedLedgerInfo(data: byte[]): ManagedLedgerInfo</TD></TR>
<TR><TD ALIGN="LEFT" >+ removeManagedLedger(ledgerName: String, callback: MetaStoreCallback&lt;Void&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >- updateMLInfoTimestamp(info: ManagedLedgerInfo): ManagedLedgerInfo</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

NestedPositionInfo1682746216[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)NestedPositionInfo</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   bitField0_: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   entryId_: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   ledgerId_: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   memoizedIsInitialized: byte [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># internalGetFieldAccessorTable(): FieldAccessorTable</TD></TR>
<TR><TD ALIGN="LEFT" >+ newBuilder(): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ newBuilder(prototype: NestedPositionInfo): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ newBuilderForType(): Builder</TD></TR>
<TR><TD ALIGN="LEFT" ># newBuilderForType(parent: BuilderParent): Builder</TD></TR>
<TR><TD ALIGN="LEFT" ># newInstance(unused: UnusedPrivateParameter): Object</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseDelimitedFrom(input: InputStream): NestedPositionInfo</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseDelimitedFrom(input: InputStream, extensionRegistry: ExtensionRegistryLite): NestedPositionInfo</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(data: ByteBuffer): NestedPositionInfo</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(data: ByteBuffer, extensionRegistry: ExtensionRegistryLite): NestedPositionInfo</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(data: ByteString): NestedPositionInfo</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(data: ByteString, extensionRegistry: ExtensionRegistryLite): NestedPositionInfo</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(data: byte[]): NestedPositionInfo</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(data: byte[], extensionRegistry: ExtensionRegistryLite): NestedPositionInfo</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(input: InputStream): NestedPositionInfo</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(input: InputStream, extensionRegistry: ExtensionRegistryLite): NestedPositionInfo</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(input: CodedInputStream): NestedPositionInfo</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(input: CodedInputStream, extensionRegistry: ExtensionRegistryLite): NestedPositionInfo</TD></TR>
<TR><TD ALIGN="LEFT" >+ parser(): Parser&lt;NestedPositionInfo&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ toBuilder(): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeTo(output: CodedOutputStream)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

NonDurableCursorImpl997059435[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)NonDurableCursorImpl</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   readCompacted: boolean [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ asyncClose(callback: CloseCallback, ctx: Object)</TD></TR>
<TR><TD ALIGN="LEFT" >+ asyncDeleteCursor(consumerName: String, callback: DeleteCursorCallback, ctx: Object)</TD></TR>
<TR><TD ALIGN="LEFT" ># internalAsyncMarkDelete(newPosition: PositionImpl, properties: Map&lt;String, Long&gt;, callback: MarkDeleteCallback, ctx: Object)</TD></TR>
<TR><TD ALIGN="LEFT" ># recover(callback: VoidCallback)</TD></TR>
<TR><TD ALIGN="LEFT" >- recoverCursor(mdPosition: PositionImpl)</TD></TR>
<TR><TD ALIGN="LEFT" >+ rewind()</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

NullLedgerOffloader997059435[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)NullLedgerOffloader</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ deleteOffloaded(ledgerId: long, uid: UUID, offloadDriverMetadata: Map&lt;String, String&gt;): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ offload(ledger: ReadHandle, uid: UUID, extraMetadata: Map&lt;String, String&gt;): CompletableFuture&lt;Void&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ readOffloaded(ledgerId: long, uid: UUID, offloadDriverMetadata: Map&lt;String, String&gt;): CompletableFuture&lt;ReadHandle&gt;</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

OffloadContext1682746216[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)OffloadContext</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   bitField0_: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   bookkeeperDeleted_: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   complete_: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   driverMetadata_: OffloadDriverMetadata [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   memoizedIsInitialized: byte [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   offloadSegment_: List&lt;OffloadSegment&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   timestamp_: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   uidLsb_: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   uidMsb_: long [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ getOffloadSegment(index: int): OffloadSegment</TD></TR>
<TR><TD ALIGN="LEFT" >+ getOffloadSegmentOrBuilder(index: int): OffloadSegmentOrBuilder</TD></TR>
<TR><TD ALIGN="LEFT" ># internalGetFieldAccessorTable(): FieldAccessorTable</TD></TR>
<TR><TD ALIGN="LEFT" >+ newBuilder(): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ newBuilder(prototype: OffloadContext): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ newBuilderForType(): Builder</TD></TR>
<TR><TD ALIGN="LEFT" ># newBuilderForType(parent: BuilderParent): Builder</TD></TR>
<TR><TD ALIGN="LEFT" ># newInstance(unused: UnusedPrivateParameter): Object</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseDelimitedFrom(input: InputStream): OffloadContext</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseDelimitedFrom(input: InputStream, extensionRegistry: ExtensionRegistryLite): OffloadContext</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(data: ByteBuffer): OffloadContext</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(data: ByteBuffer, extensionRegistry: ExtensionRegistryLite): OffloadContext</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(data: ByteString): OffloadContext</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(data: ByteString, extensionRegistry: ExtensionRegistryLite): OffloadContext</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(data: byte[]): OffloadContext</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(data: byte[], extensionRegistry: ExtensionRegistryLite): OffloadContext</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(input: InputStream): OffloadContext</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(input: InputStream, extensionRegistry: ExtensionRegistryLite): OffloadContext</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(input: CodedInputStream): OffloadContext</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(input: CodedInputStream, extensionRegistry: ExtensionRegistryLite): OffloadContext</TD></TR>
<TR><TD ALIGN="LEFT" >+ parser(): Parser&lt;OffloadContext&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ toBuilder(): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeTo(output: CodedOutputStream)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

OffloadIndexBlockImpl381677195[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)OffloadIndexBlockImpl</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   dataHeaderLength: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   dataObjectLength: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   indexEntries: TreeMap&lt;Long, OffloadIndexEntryImpl&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   recyclerHandle: Handle&lt;OffloadIndexBlockImpl&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   segmentMetadata: LedgerMetadata [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >- fromStream(dis: DataInputStream): OffloadIndexBlock</TD></TR>
<TR><TD ALIGN="LEFT" >+ get(metadata: LedgerMetadata, dataObjectLength: long, dataHeaderLength: long, entries: List&lt;OffloadIndexEntryImpl&gt;): OffloadIndexBlockImpl</TD></TR>
<TR><TD ALIGN="LEFT" >+ get(magic: int, stream: DataInputStream): OffloadIndexBlockImpl</TD></TR>
<TR><TD ALIGN="LEFT" >+ getIndexEntryForEntry(messageEntryId: long): OffloadIndexEntry</TD></TR>
<TR><TD ALIGN="LEFT" >- parseLedgerMetadata(bytes: byte[]): LedgerMetadata</TD></TR>
<TR><TD ALIGN="LEFT" >+ recycle()</TD></TR>
<TR><TD ALIGN="LEFT" >+ toStream(): IndexInputStream</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

OffloadIndexBlockV2BuilderImpl381677195[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)OffloadIndexBlockV2BuilderImpl</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   dataHeaderLength: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   dataObjectLength: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   entries: List&lt;OffloadIndexEntryImpl&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   entryMap: SortedMap&lt;Long, List&lt;OffloadIndexEntryImpl&gt;&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   lastBlockSize: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   lastStreamingBlockSize: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   ledgerMetadata: LedgerMetadata [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   ledgerMetadataMap: Map&lt;Long, LedgerInfo&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   streamingOffset: long [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ addBlock(firstEntryId: long, partId: int, blockSize: int): OffloadIndexBlockBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ addBlock(ledgerId: long, firstEntryId: long, partId: int, blockSize: int): OffloadIndexBlockV2Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ addLedgerMeta(ledgerId: Long, metadata: LedgerInfo): OffloadIndexBlockV2BuilderImpl</TD></TR>
<TR><TD ALIGN="LEFT" >+ build(): OffloadIndexBlock</TD></TR>
<TR><TD ALIGN="LEFT" >+ buildV2(): OffloadIndexBlockV2</TD></TR>
<TR><TD ALIGN="LEFT" >+ fromStream(is: InputStream): OffloadIndexBlockV2</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

OffloadIndexBlockV2Impl381677195[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)OffloadIndexBlockV2Impl</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   compatibleMetadata: Map&lt;Long, LedgerMetadata&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   dataHeaderLength: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   dataObjectLength: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   indexEntries: Map&lt;Long, TreeMap&lt;Long, OffloadIndexEntryImpl&gt;&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   recyclerHandle: Handle&lt;OffloadIndexBlockV2Impl&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   segmentMetadata: Map&lt;Long, LedgerInfo&gt; [0..*]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >- fromStream(dis: DataInputStream): OffloadIndexBlockV2</TD></TR>
<TR><TD ALIGN="LEFT" >+ get(metadata: Map&lt;Long, LedgerInfo&gt;, dataObjectLength: long, dataHeaderLength: long, entries: Map&lt;Long, List&lt;OffloadIndexEntryImpl&gt;&gt;): OffloadIndexBlockV2Impl</TD></TR>
<TR><TD ALIGN="LEFT" >+ get(magic: int, stream: DataInputStream): OffloadIndexBlockV2Impl</TD></TR>
<TR><TD ALIGN="LEFT" >+ getIndexEntryForEntry(ledgerId: long, messageEntryId: long): OffloadIndexEntry</TD></TR>
<TR><TD ALIGN="LEFT" >+ getLedgerMetadata(ledgerId: long): LedgerMetadata</TD></TR>
<TR><TD ALIGN="LEFT" >+ getStartEntryId(ledgerId: long): long</TD></TR>
<TR><TD ALIGN="LEFT" >- parseLedgerInfo(bytes: byte[]): LedgerInfo</TD></TR>
<TR><TD ALIGN="LEFT" >+ recycle()</TD></TR>
<TR><TD ALIGN="LEFT" >+ toStream(): IndexInputStream</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

OffloadIndexEntryImpl381677195[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)OffloadIndexEntryImpl</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   blockHeaderSize: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   entryId: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   offset: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   partId: int [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ of(entryId: long, partId: int, offset: long, blockHeaderSize: long): OffloadIndexEntryImpl</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

OffloadResult1412342052[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)OffloadResult</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+   beginEntry: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   beginLedger: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   endEntry: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   endLedger: long [1]</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

OffloadSegmentInfoImpl997059435[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)OffloadSegmentInfoImpl</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+   beginEntryId: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   beginLedgerId: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   closed: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   driverMetadata: Map&lt;String, String&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >+   driverName: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   endEntryId: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   endLedgerId: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   uuid: UUID [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ closeSegment(endLedger: long, endEntry: long)</TD></TR>
<TR><TD ALIGN="LEFT" >+ result(): OffloadResult</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

OpAddEntry997059435[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)OpAddEntry</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   addOpCount: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   callback: AddEntryCallback [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   closeWhenDone: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   ctx: Object [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   data: ByteBuf [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   dataLength: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   entryId: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   lastInitTime: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   ledger: LedgerHandle [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   ml: ManagedLedgerImpl [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   numberOfMessages: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   payloadProcessorHandle: PayloadProcessorHandle [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   recyclerHandle: Handle&lt;OpAddEntry&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   startTime: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   state: State [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ addComplete(rc: int, lh: LedgerHandle, entryId: long, ctx: Object)</TD></TR>
<TR><TD ALIGN="LEFT" >- checkAndCompleteOp(ctx: Object): boolean</TD></TR>
<TR><TD ALIGN="LEFT" ># close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ closeComplete(rc: int, lh: LedgerHandle, ctx: Object)</TD></TR>
<TR><TD ALIGN="LEFT" >+ createNoRetainBuffer(ml: ManagedLedgerImpl, data: ByteBuf, callback: AddEntryCallback, ctx: Object): OpAddEntry</TD></TR>
<TR><TD ALIGN="LEFT" >+ createNoRetainBuffer(ml: ManagedLedgerImpl, data: ByteBuf, numberOfMessages: int, callback: AddEntryCallback, ctx: Object): OpAddEntry</TD></TR>
<TR><TD ALIGN="LEFT" >- createOpAddEntryNoRetainBuffer(ml: ManagedLedgerImpl, data: ByteBuf, callback: AddEntryCallback, ctx: Object): OpAddEntry</TD></TR>
<TR><TD ALIGN="LEFT" >+ failed(e: ManagedLedgerException)</TD></TR>
<TR><TD ALIGN="LEFT" ># handleAddFailure(lh: LedgerHandle)</TD></TR>
<TR><TD ALIGN="LEFT" ># handleAddTimeoutFailure(ledger: LedgerHandle, ctx: Object)</TD></TR>
<TR><TD ALIGN="LEFT" >+ initiate()</TD></TR>
<TR><TD ALIGN="LEFT" >+ recycle()</TD></TR>
<TR><TD ALIGN="LEFT" >+ safeRun()</TD></TR>
<TR><TD ALIGN="LEFT" >- updateLatency()</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

OpFindNewest997059435[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)OpFindNewest</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   callback: FindEntryCallback [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   condition: Predicate&lt;Entry&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   ctx: Object [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   cursor: ManagedCursorImpl [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   lastMatchedPosition: Position [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   ledger: ManagedLedgerImpl [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   max: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   min: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   searchPosition: PositionImpl [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   startPosition: PositionImpl [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   state: State [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ find()</TD></TR>
<TR><TD ALIGN="LEFT" >- mid(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ readEntryComplete(entry: Entry, ctx: Object)</TD></TR>
<TR><TD ALIGN="LEFT" >+ readEntryFailed(exception: ManagedLedgerException, ctx: Object)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

OpReadEntry997059435[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)OpReadEntry</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   callback: ReadEntriesCallback [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   count: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   ctx: Object [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   cursor: ManagedCursorImpl [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   entries: List&lt;Entry&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >#   maxPosition: PositionImpl [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   nextReadPosition: PositionImpl [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   readPosition: PositionImpl [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   recyclerHandle: Handle&lt;OpReadEntry&gt; [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># checkReadCompletion()</TD></TR>
<TR><TD ALIGN="LEFT" >+ create(cursor: ManagedCursorImpl, readPositionRef: PositionImpl, count: int, callback: ReadEntriesCallback, ctx: Object, maxPosition: PositionImpl): OpReadEntry</TD></TR>
<TR><TD ALIGN="LEFT" >+ readEntriesComplete(returnedEntries: List&lt;Entry&gt;, ctx: Object)</TD></TR>
<TR><TD ALIGN="LEFT" >+ readEntriesFailed(exception: ManagedLedgerException, ctx: Object)</TD></TR>
<TR><TD ALIGN="LEFT" >+ recycle()</TD></TR>
<TR><TD ALIGN="LEFT" ># updateReadPosition(newReadPosition: Position)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

PendingInitializeManagedLedger1746234011[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)PendingInitializeManagedLedger</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   createTimeMs: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   ledger: ManagedLedgerImpl [0..1]</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

PositionImpl997059435[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)PositionImpl</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   ackSet: long[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >#   entryId: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   ledgerId: long [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ compareTo(other: PositionImpl): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ get(ledgerId: long, entryId: long): PositionImpl</TD></TR>
<TR><TD ALIGN="LEFT" >+ get(ledgerId: long, entryId: long, ackSet: long[]): PositionImpl</TD></TR>
<TR><TD ALIGN="LEFT" >+ get(other: PositionImpl): PositionImpl</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

PositionImplRecyclable997059435[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)PositionImplRecyclable</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   recyclerHandle: Handle&lt;PositionImplRecyclable&gt; [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ create(): PositionImplRecyclable</TD></TR>
<TR><TD ALIGN="LEFT" >+ recycle()</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

PositionInfo1682746216[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)PositionInfo</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   batchedEntryDeletionIndexInfo_: List&lt;BatchedEntryDeletionIndexInfo&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   bitField0_: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   entryId_: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   individualDeletedMessages_: List&lt;MessageRange&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   ledgerId_: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   memoizedIsInitialized: byte [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   properties_: List&lt;LongProperty&gt; [0..*]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ getBatchedEntryDeletionIndexInfo(index: int): BatchedEntryDeletionIndexInfo</TD></TR>
<TR><TD ALIGN="LEFT" >+ getBatchedEntryDeletionIndexInfoOrBuilder(index: int): BatchedEntryDeletionIndexInfoOrBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ getIndividualDeletedMessages(index: int): MessageRange</TD></TR>
<TR><TD ALIGN="LEFT" >+ getIndividualDeletedMessagesOrBuilder(index: int): MessageRangeOrBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ getProperties(index: int): LongProperty</TD></TR>
<TR><TD ALIGN="LEFT" >+ getPropertiesOrBuilder(index: int): LongPropertyOrBuilder</TD></TR>
<TR><TD ALIGN="LEFT" ># internalGetFieldAccessorTable(): FieldAccessorTable</TD></TR>
<TR><TD ALIGN="LEFT" >+ newBuilder(): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ newBuilder(prototype: PositionInfo): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ newBuilderForType(): Builder</TD></TR>
<TR><TD ALIGN="LEFT" ># newBuilderForType(parent: BuilderParent): Builder</TD></TR>
<TR><TD ALIGN="LEFT" ># newInstance(unused: UnusedPrivateParameter): Object</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseDelimitedFrom(input: InputStream): PositionInfo</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseDelimitedFrom(input: InputStream, extensionRegistry: ExtensionRegistryLite): PositionInfo</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(data: ByteBuffer): PositionInfo</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(data: ByteBuffer, extensionRegistry: ExtensionRegistryLite): PositionInfo</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(data: ByteString): PositionInfo</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(data: ByteString, extensionRegistry: ExtensionRegistryLite): PositionInfo</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(data: byte[]): PositionInfo</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(data: byte[], extensionRegistry: ExtensionRegistryLite): PositionInfo</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(input: InputStream): PositionInfo</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(input: InputStream, extensionRegistry: ExtensionRegistryLite): PositionInfo</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(input: CodedInputStream): PositionInfo</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseFrom(input: CodedInputStream, extensionRegistry: ExtensionRegistryLite): PositionInfo</TD></TR>
<TR><TD ALIGN="LEFT" >+ parser(): Parser&lt;PositionInfo&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ toBuilder(): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeTo(output: CodedOutputStream)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

ReadEntryCallbackWrapper2079345937[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)ReadEntryCallbackWrapper</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   cntx: Object [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   createdTime: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   entryId: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   ledgerId: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   name: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   readEntriesCallback: ReadEntriesCallback [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   readEntryCallback: ReadEntryCallback [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   readOpCount: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   recyclerHandle: Handle&lt;ReadEntryCallbackWrapper&gt; [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># create(name: String, ledgerId: long, entryId: long, callback: ReadEntryCallback, readOpCount: long, createdTime: long, ctx: Object): ReadEntryCallbackWrapper</TD></TR>
<TR><TD ALIGN="LEFT" ># create(name: String, ledgerId: long, entryId: long, callback: ReadEntriesCallback, readOpCount: long, createdTime: long, ctx: Object): ReadEntryCallbackWrapper</TD></TR>
<TR><TD ALIGN="LEFT" >- reOpCount(ctx: Object): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ readEntriesComplete(returnedEntries: List&lt;Entry&gt;, ctx: Object)</TD></TR>
<TR><TD ALIGN="LEFT" >+ readEntriesFailed(exception: ManagedLedgerException, ctx: Object)</TD></TR>
<TR><TD ALIGN="LEFT" >+ readEntryComplete(entry: Entry, ctx: Object)</TD></TR>
<TR><TD ALIGN="LEFT" >+ readEntryFailed(exception: ManagedLedgerException, ctx: Object)</TD></TR>
<TR><TD ALIGN="LEFT" >+ readFailed(exception: ManagedLedgerException, ctx: Object)</TD></TR>
<TR><TD ALIGN="LEFT" >- recycle(readOpCount: long): boolean</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

ReadOnlyCursorImpl997059435[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)ReadOnlyCursorImpl</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ asyncClose(callback: CloseCallback, ctx: Object)</TD></TR>
<TR><TD ALIGN="LEFT" >+ getNumberOfEntries(range: Range&lt;PositionImpl&gt;): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ skipEntries(numEntriesToSkip: int)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

ReadOnlyManagedLedgerImpl997059435[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)ReadOnlyManagedLedgerImpl</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ asyncReadEntry(position: PositionImpl, callback: ReadEntryCallback, ctx: Object)</TD></TR>
<TR><TD ALIGN="LEFT" >- createReadOnlyCursor(startPosition: PositionImpl): ReadOnlyCursor</TD></TR>
<TR><TD ALIGN="LEFT" ># initializeAndCreateCursor(startPosition: PositionImpl): CompletableFuture&lt;ReadOnlyCursor&gt;</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

SafeRun996695433[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)SafeRun</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ safeRun(runnable: Runnable): SafeRunnable</TD></TR>
<TR><TD ALIGN="LEFT" >+ safeRun(runnable: Runnable, exceptionHandler: Consumer&lt;Throwable&gt;): SafeRunnable</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

StatsBuckets996695433[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)StatsBuckets</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   boundaries: long[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   buckets: LongAdder[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   count: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   sum: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   sumCounter: LongAdder [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   values: long[] [0..*]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ addAll(other: StatsBuckets)</TD></TR>
<TR><TD ALIGN="LEFT" >+ addValue(value: long)</TD></TR>
<TR><TD ALIGN="LEFT" >- isSorted(array: long[]): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ refresh()</TD></TR>
<TR><TD ALIGN="LEFT" >+ reset()</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

TieredStorageConfiguration502334150[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)TieredStorageConfiguration</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   configProperties: Map&lt;String, String&gt; [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   credentials: Supplier&lt;Credentials&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   provider: JCloudBlobStoreProvider [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ create(props: Properties): TieredStorageConfiguration</TD></TR>
<TR><TD ALIGN="LEFT" >+ create(props: Map&lt;String, String&gt;): TieredStorageConfiguration</TD></TR>
<TR><TD ALIGN="LEFT" >- getBackwardCompatibleKey(property: String): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ getConfigProperty(propertyName: String): String</TD></TR>
<TR><TD ALIGN="LEFT" >- getKeyName(property: String): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ getKeys(property: String): List&lt;String&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ validate()</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];
} 
} 

subgraph cluster_1905501234 { 
   	label="no qualified name"
	labeljust=l
	fillcolor="#ececec"
	style=filled
   
   noqualifiedname1905501234[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)Result</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   e: ManagedLedgerException [0..1]</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];
} 

subgraph cluster_991792299 { 
   	label=airlift
	labeljust=l
	fillcolor="#ececec"
	style=filled
   
   subgraph cluster_874863067 { 
   	label=compress
	labeljust=l
	fillcolor="#d8d8d8"
	style=filled
   
   ZStdRawCompressor1494378284[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)ZStdRawCompressor</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ compress(inputAddress: long, inputLimit: long, outputAddress: long, outputLimit: long, compressionLevel: int): int</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];
} 
} 

'edges    
AbstractBaseDispatcher1718290011 -> PersistentSubscription1101090806[label="subscription
[0..1]", arrowhead=none];
AbstractBatchMessageContainer12001400 -> ProducerImpl12001400[label="producer
[0..1]"];
AbstractDispatcherMultipleConsumers1718290011 -> PersistentDispatcherMultipleConsumers1101090806[arrowhead=none, arrowtail=empty, dir=both];
AbstractGenericSchema75672144 -> GenericProtobufNativeSchema75672144[arrowhead=none, arrowtail=empty, dir=both];
AbstractReplicator1718290011 -> BrokerService1718290011[label="brokerService
[0..1]"];
AbstractReplicator1718290011 -> NonPersistentReplicator442146095[arrowhead=none, arrowtail=empty, dir=both];
AbstractReplicator1718290011 -> ProducerImpl12001400[label="producer
[0..1]"];
AbstractSchema1622012615 -> BooleanSchema1622012615[arrowhead=none, arrowtail=empty, dir=both];
AbstractSchema1622012615 -> ByteBufSchema1622012615[arrowhead=none, arrowtail=empty, dir=both];
AbstractSchema1622012615 -> ByteBufferSchema1622012615[arrowhead=none, arrowtail=empty, dir=both];
AbstractSchema1622012615 -> ByteSchema1622012615[arrowhead=none, arrowtail=empty, dir=both];
AbstractSchema1622012615 -> DateSchema1622012615[arrowhead=none, arrowtail=empty, dir=both];
AbstractSchema1622012615 -> DoubleSchema1622012615[arrowhead=none, arrowtail=empty, dir=both];
AbstractSchema1622012615 -> FloatSchema1622012615[arrowhead=none, arrowtail=empty, dir=both];
AbstractSchema1622012615 -> InstantSchema1622012615[arrowhead=none, arrowtail=empty, dir=both];
AbstractSchema1622012615 -> IntSchema1622012615[arrowhead=none, arrowtail=empty, dir=both];
AbstractSchema1622012615 -> KeyValueSchemaImpl1622012615[arrowhead=none, arrowtail=empty, dir=both];
AbstractSchema1622012615 -> LocalDateSchema1622012615[arrowhead=none, arrowtail=empty, dir=both];
AbstractSchema1622012615 -> LocalDateTimeSchema1622012615[arrowhead=none, arrowtail=empty, dir=both];
AbstractSchema1622012615 -> LocalTimeSchema1622012615[arrowhead=none, arrowtail=empty, dir=both];
AbstractSchema1622012615 -> ShortSchema1622012615[arrowhead=none, arrowtail=empty, dir=both];
AbstractSchema1622012615 -> StringSchema1622012615[arrowhead=none, arrowtail=empty, dir=both];
AbstractSchema1622012615 -> TimeSchema1622012615[arrowhead=none, arrowtail=empty, dir=both];
AbstractSchema1622012615 -> TimestampSchema1622012615[arrowhead=none, arrowtail=empty, dir=both];
AbstractStructSchema1622012615 -> WrappedVersionedSchema2009232385[arrowhead=none, arrowtail=empty, dir=both];
AbstractTopic1718290011 -> BrokerService1718290011[label="brokerService
[0..1]"];
AbstractTopic1718290011 -> NonPersistentTopic442146095[arrowhead=none, arrowtail=empty, dir=both];
AbstractTopic1718290011 -> PersistentTopic1101090806[arrowhead=none, arrowtail=empty, dir=both];
AbstractTopic1718290011 -> Producer1718290011[label="producers
[0..*]"];
AbstractTopic1718290011 -> Producer1718290011[label="waitingExclusiveProducers
[0..*]"];
AdminResource2119895947 -> BacklogQuotaManager1718290011[label="namespaceBacklogQuota() -> getBacklogQuota()"];
AdminResource2119895947 -> Bookies620988779[arrowhead=none, arrowtail=empty, dir=both];
AdminResource2119895947 -> BrokerStatsBase229910521[arrowhead=none, arrowtail=empty, dir=both];
AdminResource2119895947 -> BrokersBase229910521[arrowhead=none, arrowtail=empty, dir=both];
AdminResource2119895947 -> Functions620988779[arrowhead=none, arrowtail=empty, dir=both];
AdminResource2119895947 -> FunctionsBase229910521[arrowhead=none, arrowtail=empty, dir=both];
AdminResource2119895947 -> NamespaceName1973581360[label="namespaceName
[0..1]"];
AdminResource2119895947 -> NamespaceService839302271[label="checkTopicExistsAsync() -> getListOfTopics()"];
AdminResource2119895947 -> NamespacesBase229910521[arrowhead=none, arrowtail=empty, dir=both];
AdminResource2119895947 -> PackagesBase229910521[arrowhead=none, arrowtail=empty, dir=both];
AdminResource2119895947 -> PersistentTopicsBase229910521[arrowhead=none, arrowtail=empty, dir=both];
AdminResource2119895947 -> ResourceGroupsBase229910521[arrowhead=none, arrowtail=empty, dir=both];
AdminResource2119895947 -> SchemasResourceBase229910521[arrowhead=none, arrowtail=empty, dir=both];
AdminResource2119895947 -> SinksBase229910521[arrowhead=none, arrowtail=empty, dir=both];
AdminResource2119895947 -> SourcesBase229910521[arrowhead=none, arrowtail=empty, dir=both];
AdminResource2119895947 -> TopicName1973581360[label="topicName
[0..1]"];
AdminResource2119895947 -> TopicsImpl1292556772[label="internalCreatePartitionedTopic() -> createPartitionedTopicAsync()"];
AdminResource2119895947 -> TransactionsBase229910521[arrowhead=none, arrowtail=empty, dir=both];
AdminResource2119895947 -> Worker620988779[arrowhead=none, arrowtail=empty, dir=both];
AdminResource2119895947 -> WorkerStats620988779[arrowhead=none, arrowtail=empty, dir=both];
AppendBrokerTimestampMetadataInterceptor2014195078 -> BrokerEntryMetadata297559756[label="intercept() -> setBrokerTimestamp()"];
AppendIndexMetadataInterceptor2014195078 -> AppendBrokerTimestampMetadataInterceptor2014195078[arrowhead=none];
AppendIndexMetadataInterceptor2014195078 -> BrokerEntryMetadata297559756[label="interceptWithNumberOfMessages() -> setIndex()"];
AuthenticationListState18732099 -> AuthenticationProviderList978396142[label="authenticate() -> applyAuthProcessor()"];
AuthenticationService978396142 -> AuthenticationProviderAthenz978396142[arrowhead=none];
AuthenticationService978396142 -> AuthenticationProviderBasic978396142[arrowhead=none];
AuthenticationService978396142 -> AuthenticationProviderList978396142[arrowhead=none];
AuthenticationService978396142 -> AuthenticationProviderSasl978396142[arrowhead=none];
AuthenticationService978396142 -> AuthenticationProviderTls978396142[arrowhead=none];
AuthenticationService978396142 -> AuthenticationProviderToken978396142[arrowhead=none];
AuthorizationService1708110945 -> FutureUtil1762718902[label="allowTopicPolicyOperationAsync() -> failedFuture()"];
AuthorizationService1708110945 -> PulsarAuthorizationProvider1708110945[arrowhead=none];
AuthorizationService1708110945 -> ReflectionUtils212457750[label="builder() -> newBuilder()", arrowhead=none];
AuthorizationService1708110945 -> ServiceConfiguration724302956[label="conf
[0..1]"];
AuthorizationService1708110945 -> TenantInfoImpl896442176[arrowhead=none];
AutoProduceBytesSchema1622012615 -> noqualifiedname1905501234[label="schema
[0..1]"];
AvroBaseStructSchema1622012615 -> AvroSchema1622012615[arrowhead=none, arrowtail=empty, dir=both];
AvroSchemaBasedCompatibilityCheck445450388 -> AvroSchemaCompatibilityCheck445450388[arrowhead=none, arrowtail=empty, dir=both];
AvroSchemaBasedCompatibilityCheck445450388 -> JsonSchemaCompatibilityCheck445450388[arrowhead=none, arrowtail=empty, dir=both];
AvroSchemaCompatibilityCheck445450388 -> ProtobufSchemaCompatibilityCheck445450388[arrowhead=none, arrowtail=empty, dir=both];
BacklogQuotaManager1718290011 -> BacklogQuotaImpl1043561458[arrowhead=none];
BacklogQuotaManager1718290011 -> ConcurrentOpenHashMap201476337[label="dropBacklogForTimeLimit() -> forEach()"];
BacklogQuotaManager1718290011 -> FutureUtil1762718902[label="disconnectProducers() -> waitForAll()"];
BacklogQuotaManager1718290011 -> NamespaceResources220376139[label="namespaceResources
[0..1]"];
BacklogQuotaManager1718290011 -> PersistentMessageExpiryMonitor1101090806[label="dropBacklogForTimeLimit() -> expireMessages()"];
BacklogQuotaManager1718290011 -> PersistentTopic1101090806[label="handleExceededBacklogQuota() -> getBacklogQuota()"];
BacklogQuotaManager1718290011 -> PositionImpl997059435[label="dropBacklogForTimeLimit() -> get()"];
BacklogQuotaManager1718290011 -> Producer1718290011[label="disconnectProducers() -> disconnect()"];
BaseCommand297559756 -> CommandAck297559756[label="ack
[0..1]"];
BaseCommand297559756 -> CommandAckResponse297559756[label="ackResponse
[0..1]"];
BaseCommand297559756 -> CommandActiveConsumerChange297559756[label="activeConsumerChange
[0..1]"];
BaseCommand297559756 -> CommandAddPartitionToTxn297559756[label="addPartitionToTxn
[0..1]"];
BaseCommand297559756 -> CommandAddPartitionToTxnResponse297559756[label="addPartitionToTxnResponse
[0..1]"];
BaseCommand297559756 -> CommandAddSubscriptionToTxn297559756[label="addSubscriptionToTxn
[0..1]"];
BaseCommand297559756 -> CommandAddSubscriptionToTxnResponse297559756[label="addSubscriptionToTxnResponse
[0..1]"];
BaseCommand297559756 -> CommandAuthChallenge297559756[label="authChallenge
[0..1]"];
BaseCommand297559756 -> CommandAuthResponse297559756[label="authResponse
[0..1]"];
BaseCommand297559756 -> CommandCloseConsumer297559756[label="closeConsumer
[0..1]"];
BaseCommand297559756 -> CommandCloseProducer297559756[label="closeProducer
[0..1]"];
BaseCommand297559756 -> CommandConnect297559756[label="connect
[0..1]"];
BaseCommand297559756 -> CommandConnected297559756[label="connected
[0..1]"];
BaseCommand297559756 -> CommandConsumerStats297559756[label="consumerStats
[0..1]"];
BaseCommand297559756 -> CommandConsumerStatsResponse297559756[label="consumerStatsResponse
[0..1]"];
BaseCommand297559756 -> CommandEndTxn297559756[label="endTxn
[0..1]"];
BaseCommand297559756 -> CommandEndTxnOnPartition297559756[label="endTxnOnPartition
[0..1]"];
BaseCommand297559756 -> CommandEndTxnOnPartitionResponse297559756[label="endTxnOnPartitionResponse
[0..1]"];
BaseCommand297559756 -> CommandEndTxnOnSubscription297559756[label="endTxnOnSubscription
[0..1]"];
BaseCommand297559756 -> CommandEndTxnOnSubscriptionResponse297559756[label="endTxnOnSubscriptionResponse
[0..1]"];
BaseCommand297559756 -> CommandEndTxnResponse297559756[label="endTxnResponse
[0..1]"];
BaseCommand297559756 -> CommandError297559756[label="error
[0..1]"];
BaseCommand297559756 -> CommandFlow297559756[label="flow
[0..1]"];
BaseCommand297559756 -> CommandGetLastMessageId297559756[label="getLastMessageId
[0..1]"];
BaseCommand297559756 -> CommandGetLastMessageIdResponse297559756[label="getLastMessageIdResponse
[0..1]"];
BaseCommand297559756 -> CommandGetOrCreateSchema297559756[label="getOrCreateSchema
[0..1]"];
BaseCommand297559756 -> CommandGetOrCreateSchemaResponse297559756[label="getOrCreateSchemaResponse
[0..1]"];
BaseCommand297559756 -> CommandGetSchema297559756[label="getSchema
[0..1]"];
BaseCommand297559756 -> CommandGetSchemaResponse297559756[label="getSchemaResponse
[0..1]"];
BaseCommand297559756 -> CommandGetTopicsOfNamespace297559756[label="getTopicsOfNamespace
[0..1]"];
BaseCommand297559756 -> CommandGetTopicsOfNamespaceResponse297559756[label="getTopicsOfNamespaceResponse
[0..1]"];
BaseCommand297559756 -> CommandLookupTopic297559756[label="lookupTopic
[0..1]"];
BaseCommand297559756 -> CommandLookupTopicResponse297559756[label="lookupTopicResponse
[0..1]"];
BaseCommand297559756 -> CommandMessage297559756[label="message
[0..1]"];
BaseCommand297559756 -> CommandNewTxn297559756[label="newTxn
[0..1]"];
BaseCommand297559756 -> CommandNewTxnResponse297559756[label="newTxnResponse
[0..1]"];
BaseCommand297559756 -> CommandPartitionedTopicMetadata297559756[label="partitionMetadata
[0..1]"];
BaseCommand297559756 -> CommandPartitionedTopicMetadataResponse297559756[label="partitionMetadataResponse
[0..1]"];
BaseCommand297559756 -> CommandPing297559756[label="ping
[0..1]"];
BaseCommand297559756 -> CommandPong297559756[label="pong
[0..1]"];
BaseCommand297559756 -> CommandProducer297559756[label="producer
[0..1]"];
BaseCommand297559756 -> CommandProducerSuccess297559756[label="producerSuccess
[0..1]"];
BaseCommand297559756 -> CommandReachedEndOfTopic297559756[label="reachedEndOfTopic
[0..1]"];
BaseCommand297559756 -> CommandRedeliverUnacknowledgedMessages297559756[label="redeliverUnacknowledgedMessages
[0..1]"];
BaseCommand297559756 -> CommandSeek297559756[label="seek
[0..1]"];
BaseCommand297559756 -> CommandSend297559756[label="send
[0..1]"];
BaseCommand297559756 -> CommandSendError297559756[label="sendError
[0..1]"];
BaseCommand297559756 -> CommandSendReceipt297559756[label="sendReceipt
[0..1]"];
BaseCommand297559756 -> CommandSubscribe297559756[label="subscribe
[0..1]"];
BaseCommand297559756 -> CommandSuccess297559756[label="success
[0..1]"];
BaseCommand297559756 -> CommandTcClientConnectRequest297559756[label="tcClientConnectRequest
[0..1]"];
BaseCommand297559756 -> CommandTcClientConnectResponse297559756[label="tcClientConnectResponse
[0..1]"];
BaseCommand297559756 -> CommandUnsubscribe297559756[label="unsubscribe
[0..1]"];
BaseResource1292556772 -> NamespacesImpl1292556772[arrowhead=none, arrowtail=empty, dir=both];
BaseResource1292556772 -> TopicsImpl1292556772[arrowhead=none, arrowtail=empty, dir=both];
BaseResources220376139 -> ClusterResources220376139[arrowhead=none, arrowtail=empty, dir=both];
BaseResources220376139 -> DynamicConfigurationResources220376139[arrowhead=none, arrowtail=empty, dir=both];
BaseResources220376139 -> FailureDomainResources166830254[arrowhead=none, arrowtail=empty, dir=both];
BaseResources220376139 -> PartitionedTopicResources2098679213[arrowhead=none, arrowtail=empty, dir=both];
BaseResources220376139 -> TenantResources220376139[arrowhead=none, arrowtail=empty, dir=both];
BatchMessageAcker12001400 -> BatchMessageAckerDisabled12001400[arrowhead=none, arrowtail=empty, dir=both];
BatchMessageIdImpl12001400 -> BatchMessageAcker12001400[label="acker
[0..1]"];
BatchSourceExecutor1311590187 -> ConsumerBase12001400[label="intermediateTopicConsumer
[0..1]", arrowhead=none];
BatchSourceExecutor1311590187 -> TopicMessageImpl12001400[label="currentTask
[0..1]", arrowhead=none];
BlobStoreBackedReadHandleImpl381677195 -> BackedInputStream1619784327[label="inputStream
[0..1]"];
BlobStoreBackedReadHandleImpl381677195 -> OffloadIndexBlockV2BuilderImpl381677195[arrowhead=none];
BlobStoreBackedReadHandleImplV2381677195 -> BackedInputStream1619784327[label="inputStreams
[0..*]"];
BlobStoreBackedReadHandleImplV2381677195 -> OffloadIndexBlockImpl381677195[arrowhead=none];
BlobStoreBackedReadHandleImplV2381677195 -> OffloadIndexBlockV2BuilderImpl381677195[arrowhead=none];
BlobStoreBackedReadHandleImplV2381677195 -> OffloadIndexBlockV2Impl381677195[arrowhead=none];
BlobStoreBackedReadHandleImplV2381677195 -> OffloadIndexEntryImpl381677195[arrowhead=none];
BlobStoreManagedLedgerOffloader381677195 -> BlobStoreBackedReadHandleImpl381677195[label="readOffloaded() -> open()"];
BlobStoreManagedLedgerOffloader381677195 -> BlobStoreBackedReadHandleImplV2381677195[label="readOffloaded() -> open()"];
BlobStoreManagedLedgerOffloader381677195 -> BlobStoreLocation502334150[label="blobStores
[0..*]"];
BlobStoreManagedLedgerOffloader381677195 -> BlockAwareSegmentInputStreamImpl381677195[label="offload() -> calculateBlockSize()"];
BlobStoreManagedLedgerOffloader381677195 -> BufferedOffloadStream381677195[label="streamingOffloadLoop() -> calculateBlockSize()"];
BlobStoreManagedLedgerOffloader381677195 -> EntryImpl997059435[label="offerEntry() -> create()"];
BlobStoreManagedLedgerOffloader381677195 -> LedgerInfo912267968[label="buildBlockAndUpload() -> newBuilder()"];
BlobStoreManagedLedgerOffloader381677195 -> OffloadResult1412342052[label="offloadResult
[0..1]"];
BlobStoreManagedLedgerOffloader381677195 -> OffloadSegmentInfoImpl997059435[label="segmentInfo
[0..1]"];
BlobStoreManagedLedgerOffloader381677195 -> PositionImpl997059435[label="lastOfferedPosition
[0..1]"];
BlobStoreManagedLedgerOffloader381677195 -> TieredStorageConfiguration502334150[label="config
[0..1]"];
BlockAwareSegmentInputStream1619784327 -> BlockAwareSegmentInputStreamImpl381677195[arrowhead=none, arrowtail=empty, dir=both];
BookkeeperSchemaStorage445450388 -> BookKeeperClientFactoryImpl724302956[arrowhead=none];
BookkeeperSchemaStorage445450388 -> LedgerMetadataUtils997059435[label="createLedger() -> buildMetadataForSchema()"];
BookkeeperSchemaStorage445450388 -> PositionInfo840873545[label="newPositionInfo() -> newBuilder()", arrowhead=none];
BookkeeperSchemaStorage445450388 -> PulsarService724302956[label="pulsar
[0..1]"];
BookkeeperSchemaStorage445450388 -> SchemaLocator840873545[label="locatorEntryCache
[0..1]"];
BookkeeperSchemaStorage445450388 -> ServiceConfiguration724302956[label="config
[0..1]"];
BookkeeperSchemaStorage445450388 -> StoredSchema1472480913[label="readSchemaOperations
[0..*]"];
BrokerInterceptorWithClassLoader1588982040 -> NarClassLoader1605698775[label="classLoader
[0..1]"];
BrokerInterceptors1588982040 -> BrokerInterceptorWithClassLoader1588982040[label="interceptors
[0..*]"];
BrokerProxyValidator79518146 -> NettyFutureUtil343630530[label="resolveAndCheckTargetAddress() -> toCompletableFuture()"];
BrokerService1718290011 -> AuthPoliciesImpl480042356[arrowhead=none];
BrokerService1718290011 -> AuthenticationService978396142[label="authenticationService
[0..1]"];
BrokerService1718290011 -> AuthorizationService1708110945[label="authorizationService
[0..1]"];
BrokerService1718290011 -> AutoSubscriptionCreationOverrideImpl1043561458[arrowhead=none];
BrokerService1718290011 -> AutoTopicCreationOverrideImpl1043561458[arrowhead=none];
BrokerService1718290011 -> BacklogQuotaManager1718290011[label="backlogQuotaManager
[0..1]"];
BrokerService1718290011 -> BindAddressValidator1093663096[label="start() -> validateBindAddresses()"];
BrokerService1718290011 -> BookieAffinityGroupDataImpl1043561458[arrowhead=none];
BrokerService1718290011 -> BrokerInterceptorDisabled1593963802[arrowhead=none];
BrokerService1718290011 -> BrokerInterceptorWithClassLoader1588982040[arrowhead=none];
BrokerService1718290011 -> BrokerInterceptors1588982040[arrowhead=none];
BrokerService1718290011 -> BundlesQuotas2118147928[label="bundlesQuotas
[0..1]"];
BrokerService1718290011 -> ChannelFutures343630530[label="closeChannel() -> toCompletableFuture()"];
BrokerService1718290011 -> ClientBuilderImpl12001400[arrowhead=none];
BrokerService1718290011 -> ClusterDataImpl896442176[arrowhead=none];
BrokerService1718290011 -> CompactorMXBeanImpl435643328[arrowhead=none];
BrokerService1718290011 -> ConcurrentOpenHashMap201476337[label="clusterAdmins
[0..1]"];
BrokerService1718290011 -> ConcurrentOpenHashMap201476337[label="configRegisteredListeners
[0..1]"];
BrokerService1718290011 -> ConcurrentOpenHashMap201476337[label="multiLayerTopicsMap
[0..1]"];
BrokerService1718290011 -> ConcurrentOpenHashMap201476337[label="offlineTopicStatCache
[0..1]"];
BrokerService1718290011 -> ConcurrentOpenHashMap201476337[label="owningTopics
[0..1]"];
BrokerService1718290011 -> ConcurrentOpenHashMap201476337[label="replicationClients
[0..1]"];
BrokerService1718290011 -> ConcurrentOpenHashMap201476337[label="topics
[0..1]"];
BrokerService1718290011 -> ConcurrentOpenHashSet201476337[label="blockedDispatchers
[0..1]"];
BrokerService1718290011 -> ConcurrentOpenHashSet201476337[label="owningTopics
[0..1]"];
BrokerService1718290011 -> DispatchRateLimiter1101090806[label="brokerDispatchRateLimiter
[0..1]"];
BrokerService1718290011 -> DistributedIdGenerator1718290011[label="producerNameGenerator
[0..1]"];
BrokerService1718290011 -> DynamicConfigurationResources220376139[label="handleMetadataChanges() -> isDynamicConfigurationPath()"];
BrokerService1718290011 -> EntryFilterWithClassLoader368263718[label="entryFilters
[0..*]"];
BrokerService1718290011 -> EventsTopicNames2082884193[label="isAllowAutoTopicCreation() -> checkTopicIsEventsNames()"];
BrokerService1718290011 -> EventsTopicNames2082884193[label="isSystemTopic() -> checkTopicIsEventsNames()", arrowhead=none];
BrokerService1718290011 -> InMemoryDelayedDeliveryTrackerFactory1284485384[arrowhead=none];
BrokerService1718290011 -> LocalPoliciesResources220376139[label="getManagedLedgerConfig() -> getLocalPoliciesAsync()"];
BrokerService1718290011 -> ModularLoadManagerWrapper109292786[arrowhead=none];
BrokerService1718290011 -> NamespaceBundleFactory1973581360[label="unloadDeletedReplNamespace() -> getBundlesAsync()"];
BrokerService1718290011 -> NamespaceName1973581360[label="handlePoliciesUpdates() -> includes()"];
BrokerService1718290011 -> NamespacesImpl1292556772[arrowhead=none];
BrokerService1718290011 -> NettyFutureUtil343630530[label="shutdownEventLoopGracefully() -> toCompletableFutureVoid()"];
BrokerService1718290011 -> NonPersistentReplicator442146095[arrowhead=none];
BrokerService1718290011 -> NonPersistentSubscription442146095[arrowhead=none];
BrokerService1718290011 -> NoopLoadManager1871869916[arrowhead=none];
BrokerService1718290011 -> ObserverGauge1852472696[label="pendingLookupRequests
[0..1]"];
BrokerService1718290011 -> ObserverGauge1852472696[label="pendingTopicLoadRequests
[0..1]"];
BrokerService1718290011 -> PersistentDispatcherMultipleConsumers1101090806[label="blockedDispatchers
[0..1]"];
BrokerService1718290011 -> PersistentOfflineTopicStats896442176[label="offlineTopicStatCache
[0..1]"];
BrokerService1718290011 -> PersistentReplicator1101090806[arrowhead=none];
BrokerService1718290011 -> PersistentSubscription1101090806[arrowhead=none];
BrokerService1718290011 -> PersistentTopic1101090806[label="multiLayerTopicsMap
[0..1]", arrowhead=none];
BrokerService1718290011 -> PersistentTopic1101090806[label="topics
[0..1]", arrowhead=none];
BrokerService1718290011 -> PrecisPublishLimiter1718290011[arrowhead=none];
BrokerService1718290011 -> PublishRateLimiterDisable1718290011[arrowhead=none];
BrokerService1718290011 -> PublishRateLimiterImpl1718290011[arrowhead=none];
BrokerService1718290011 -> PulsarAdminBuilderImpl1292556772[arrowhead=none];
BrokerService1718290011 -> PulsarChannelOptions1676996751[label="start() -> builder()"];
BrokerService1718290011 -> PulsarService724302956[label="pulsar
[0..1]"];
BrokerService1718290011 -> PulsarStats1718290011[label="pulsarStats
[0..1]"];
BrokerService1718290011 -> ReflectionUtils212457750[label="builder() -> newBuilder()", arrowhead=none];
BrokerService1718290011 -> ResourceGroupPublishLimiter664401495[arrowhead=none];
BrokerService1718290011 -> RetryUtil11637398[label="getTopicPoliciesAsyncWithRetry() -> retryAsynchronously()", arrowhead=none];
BrokerService1718290011 -> SimpleLoadManagerImpl109292786[arrowhead=none];
BrokerService1718290011 -> Summary1852472696[label="updateRates() -> rotateLatencyCollection()"];
BrokerService1718290011 -> SystemTopicBasedTopicPoliciesService1718290011[arrowhead=none];
BrokerService1718290011 -> SystemTopicClientBase1970406500[arrowhead=none];
BrokerService1718290011 -> TopicLoadingContext704824873[label="pendingTopicLoadingQueue
[0..*]"];
BrokerService1718290011 -> TopicName1973581360[label="isSystemTopic() -> get()", arrowhead=none];
BrokerService1718290011 -> TopicPoliciesServiceDisabled1529889815[arrowhead=none];
BrokerService1718290011 -> TopicResources220376139[label="checkMaxTopicsPerNamespace() -> getExistingPartitions()"];
BrokerService1718290011 -> TransactionMetadataStoreService724302956[label="unloadServiceUnit() -> removeTransactionMetadataStore()"];
BrokerServiceException1718290011 -> AddEntryMetadataException1254029274[arrowhead=none, arrowtail=empty, dir=both];
BrokerServiceException1718290011 -> AlreadyRunningException1254029274[arrowhead=none, arrowtail=empty, dir=both];
BrokerServiceException1718290011 -> ConsumerAssignException1254029274[arrowhead=none, arrowtail=empty, dir=both];
BrokerServiceException1718290011 -> ConsumerBusyException1254029274[arrowhead=none, arrowtail=empty, dir=both];
BrokerServiceException1718290011 -> NamingException1254029274[arrowhead=none, arrowtail=empty, dir=both];
BrokerServiceException1718290011 -> NotAllowedException1254029274[arrowhead=none, arrowtail=empty, dir=both];
BrokerServiceException1718290011 -> PersistenceException1254029274[arrowhead=none, arrowtail=empty, dir=both];
BrokerServiceException1718290011 -> ProducerBusyException1254029274[arrowhead=none, arrowtail=empty, dir=both];
BrokerServiceException1718290011 -> ProducerFencedException1254029274[arrowhead=none, arrowtail=empty, dir=both];
BrokerServiceException1718290011 -> SchemaException770960286[arrowhead=none, arrowtail=empty, dir=both];
BrokerServiceException1718290011 -> ServerMetadataException1254029274[arrowhead=none, arrowtail=empty, dir=both];
BrokerServiceException1718290011 -> ServiceUnitNotReadyException1254029274[arrowhead=none, arrowtail=empty, dir=both];
BrokerServiceException1718290011 -> SubscriptionBusyException1254029274[arrowhead=none, arrowtail=empty, dir=both];
BrokerServiceException1718290011 -> SubscriptionFencedException1254029274[arrowhead=none, arrowtail=empty, dir=both];
BrokerServiceException1718290011 -> SubscriptionInvalidCursorPosition1254029274[arrowhead=none, arrowtail=empty, dir=both];
BrokerServiceException1718290011 -> SubscriptionNotFoundException1254029274[arrowhead=none, arrowtail=empty, dir=both];
BrokerServiceException1718290011 -> TooManyRequestsException1254029274[arrowhead=none, arrowtail=empty, dir=both];
BrokerServiceException1718290011 -> TopicBacklogQuotaExceededException1254029274[arrowhead=none, arrowtail=empty, dir=both];
BrokerServiceException1718290011 -> TopicBusyException1254029274[arrowhead=none, arrowtail=empty, dir=both];
BrokerServiceException1718290011 -> TopicClosedException1254029274[arrowhead=none, arrowtail=empty, dir=both];
BrokerServiceException1718290011 -> TopicFencedException1254029274[arrowhead=none, arrowtail=empty, dir=both];
BrokerServiceException1718290011 -> TopicNotFoundException1254029274[arrowhead=none, arrowtail=empty, dir=both];
BrokerServiceException1718290011 -> TopicPoliciesCacheNotInitException1254029274[arrowhead=none, arrowtail=empty, dir=both];
BrokerServiceException1718290011 -> TopicTerminatedException1254029274[arrowhead=none, arrowtail=empty, dir=both];
BrokerServiceException1718290011 -> UnsupportedVersionException1254029274[arrowhead=none, arrowtail=empty, dir=both];
Builder156898441 -> IndexEntry840873545[arrowhead=none];
Builder156898441 -> PositionInfo840873545[label="positionBuilder_
[0..1]"];
Builder156898441 -> PositionInfo840873545[label="position_
[0..1]"];
Builder1754205562 -> Builder156898441[label="indexBuilder_
[0..1]"];
Builder1754205562 -> IndexEntry840873545[label="indexBuilder_
[0..1]"];
Builder1754205562 -> IndexEntry840873545[label="index_
[0..*]"];
Builder1754205562 -> SchemaEntry840873545[arrowhead=none];
Builder200622178 -> SchemaLocator840873545[arrowhead=none];
Builder268846344 -> KeyValuePair268846344[label="propsBuilder_
[0..1]"];
Builder268846344 -> KeyValuePair268846344[label="props_
[0..*]"];
Builder268846344 -> SchemaInfo1678783339[arrowhead=none];
Builder589409390 -> PositionInfo840873545[arrowhead=none];
Builder854020549 -> LedgerInfo912267968[arrowhead=none];
Builder854020549 -> OffloadContext1682746216[arrowhead=none];
ByteBufferSchemaWrapper1184234151 -> DeferredSchemaPlaceholder843672203[arrowhead=none, arrowtail=empty, dir=both];
ChunkMessageIdImpl12001400 -> MessageIdImpl12001400[label="firstChunkMsgId
[0..1]"];
ClientBuilderImpl12001400 -> AutoClusterFailover12001400[arrowhead=none];
ClientBuilderImpl12001400 -> ClientConfigurationData1053524534[label="conf
[0..1]"];
ClientBuilderImpl12001400 -> ConfigurationDataUtils1053524534[label="loadConf() -> loadData()"];
ClientBuilderImpl12001400 -> ControlledClusterFailover12001400[arrowhead=none];
ClientCnx12001400 -> ConsumerImpl12001400[label="consumers
[0..1]"];
ClientCnx12001400 -> ProducerImpl12001400[label="producers
[0..1]"];
ClientCnx12001400 -> ProxyClientCnx79518146[arrowhead=none, arrowtail=empty, dir=both];
ClientCnx12001400 -> TransactionBufferHandlerImpl1621168036[label="transactionBufferHandler
[0..1]", arrowhead=none];
ClientCnx12001400 -> TransactionMetaStoreHandler12001400[label="transactionMetaStoreHandlers
[0..1]"];
ClusterReplicationMetrics2102807099 -> ConcurrentOpenHashMap201476337[label="metricsMap
[0..1]"];
ClusterReplicationMetrics2102807099 -> Metrics1188434519[label="metricsList
[0..*]"];
ClusterReplicationMetrics2102807099 -> ReplicationMetrics2102807099[label="metricsMap
[0..1]"];
ClusterResources220376139 -> FailureDomainResources166830254[label="failureDomainResources
[0..1]"];
ClusterServiceCoordinator1316119764 -> LeaderService1316119764[label="leaderService
[0..1]"];
ClustersBase229910521 -> BrokerNamespaceIsolationDataImpl896442176[arrowhead=none];
ClustersBase229910521 -> BrokerNamespaceIsolationDataImplBuilder1788550532[arrowhead=none];
ClustersBase229910521 -> Clusters620988779[arrowhead=none, arrowtail=empty, dir=both];
ClustersBase229910521 -> FutureUtil1762718902[label="unloadMatchedNamespacesList() -> waitForAll()"];
ClustersBase229910521 -> NamedEntity1973581360[label="createCluster() -> checkName()"];
ClustersBase229910521 -> NamespaceIsolationDataImpl896442176[arrowhead=none];
ClustersBase229910521 -> NamespaceIsolationPolicies896602550[label="deleteNamespaceIsolationPolicy() -> deletePolicy()"];
ClustersBase229910521 -> ReflectionUtils212457750[label="builder() -> newBuilder()", arrowhead=none];
ClustersBase229910521 -> TenantsImpl1292556772[arrowhead=none];
CommandAck297559756 -> KeyLongValue297559756[label="properties
[0..*]"];
CommandAck297559756 -> MessageIdData297559756[label="messageIds
[0..*]"];
CommandAddPartitionToTxn297559756 -> StringHolder1726850686[label="partitions
[0..*]"];
CommandAddSubscriptionToTxn297559756 -> Subscription297559756[label="subscriptions
[0..*]"];
CommandAuthChallenge297559756 -> AuthData297559756[label="challenge
[0..1]"];
CommandAuthResponse297559756 -> AuthData297559756[label="response
[0..1]"];
CommandConnect297559756 -> FeatureFlags297559756[label="featureFlags
[0..1]"];
CommandEndTxnOnSubscription297559756 -> Subscription297559756[label="subscription
[0..1]"];
CommandGetLastMessageIdResponse297559756 -> MessageIdData297559756[label="consumerMarkDeletePosition
[0..1]"];
CommandGetLastMessageIdResponse297559756 -> MessageIdData297559756[label="lastMessageId
[0..1]"];
CommandGetOrCreateSchema297559756 -> Schema297559756[label="schema
[0..1]"];
CommandGetSchemaResponse297559756 -> Schema297559756[label="schema
[0..1]"];
CommandGetTopicsOfNamespaceResponse297559756 -> StringHolder1726850686[label="topics
[0..*]"];
CommandMessage297559756 -> MessageIdData297559756[label="messageId
[0..1]"];
CommandProducer297559756 -> KeyValue297559756[label="metadatas
[0..*]"];
CommandProducer297559756 -> Schema297559756[label="schema
[0..1]"];
CommandRedeliverUnacknowledgedMessages297559756 -> MessageIdData297559756[label="messageIds
[0..*]"];
CommandSeek297559756 -> MessageIdData297559756[label="messageId
[0..1]"];
CommandSendReceipt297559756 -> MessageIdData297559756[label="messageId
[0..1]"];
CommandSubscribe297559756 -> KeySharedMeta297559756[label="keySharedMeta
[0..1]"];
CommandSubscribe297559756 -> KeyValue297559756[label="metadatas
[0..*]"];
CommandSubscribe297559756 -> KeyValue297559756[label="subscriptionProperties
[0..*]"];
CommandSubscribe297559756 -> MessageIdData297559756[label="startMessageId
[0..1]"];
CommandSubscribe297559756 -> Schema297559756[label="schema
[0..1]"];
CommandSuccess297559756 -> Schema297559756[label="schema
[0..1]"];
Commands1070348832 -> BitSetRecyclable201476337[label="newAck() -> toLongArray()"];
Commands1070348832 -> BytesSchemaVersion1472480913[arrowhead=none];
Commands1070348832 -> CommandReachedEndOfTopic297559756[label="newReachedEndOfTopic() -> setConsumerId()"];
Commands1070348832 -> CommandSuccess297559756[label="newSuccessCommand() -> setRequestId()"];
Commands1070348832 -> ConcurrentBitSetRecyclable201476337[label="newMultiMessageAckCommon() -> recycle()"];
Commands1070348832 -> EmptyVersion1472480913[arrowhead=none];
Commands1070348832 -> LatestVersion1472480913[arrowhead=none];
Commands1070348832 -> LongSchemaVersion1828741399[arrowhead=none];
Commands1070348832 -> SchemaInfoImpl1622012615[arrowhead=none];
CompactorMXBeanImpl435643328 -> CompactionRecord435643328[label="compactionRecordOps
[0..*]"];
CompressionCodecLZ4917667102 -> AirliftUtils917667102[label="decode() -> ensureAirliftSupported()"];
CompressionCodecSnappy917667102 -> AirliftUtils917667102[label="decode() -> ensureAirliftSupported()"];
CompressionCodecZstd917667102 -> AirliftUtils917667102[label="decode() -> ensureAirliftSupported()"];
CompressionCodecZstd917667102 -> ZStdRawCompressor1494378284[label="encode() -> compress()"];
ConcurrentBitSet201476337 -> ConcurrentBitSetRecyclable201476337[arrowhead=none, arrowtail=empty, dir=both];
ConcurrentLongHashMap201476337 -> Section330549314[label="sections
[0..*]"];
ConcurrentLongHashMap201476337 -> noqualifiedname1905501234[label="sections
[0..*]"];
ConnectionHandler12001400 -> ClientCnx12001400[label="clientCnx
[0..1]"];
ConnectionHandler12001400 -> ConsumerImpl12001400[label="connection
[0..1]", arrowhead=none];
ConnectionPool12001400 -> ClientCnx12001400[label="pool
[0..*]"];
ConnectionPool12001400 -> ProxyConnectionPool79518146[arrowhead=none, arrowtail=empty, dir=both];
ConnectionPool12001400 -> PulsarChannelInitializer12001400[label="channelInitializerHandler
[0..1]"];
Consumer1718290011 -> PersistentSubscription1101090806[label="subscription
[0..1]", arrowhead=none];
Consumer1718290011 -> ServerCnx1718290011[label="cnx
[0..1]", arrowhead=none];
ConsumerBase12001400 -> ConsumerImpl12001400[arrowhead=none, arrowtail=empty, dir=both];
ConsumerBase12001400 -> ConsumerV1Impl1051373919[arrowhead=none];
ConsumerBase12001400 -> LeaderService1316119764[label="consumerEventListener
[0..1]", arrowhead=none];
ConsumerBase12001400 -> MultiTopicsConsumerImpl12001400[arrowhead=none, arrowtail=empty, dir=both];
ConsumerBase12001400 -> TopicMessageImpl12001400[label="incomingMessages
[0..*]", arrowhead=none];
ConsumerBase12001400 -> TopicMessageImpl12001400[label="pendingReceives
[0..*]", arrowhead=none];
ConsumerConfigurationData1053524534 -> LeaderService1316119764[label="consumerEventListener
[0..1]", arrowhead=none];
ConsumerHandler1308078636 -> ConsumerBase12001400[label="consumer
[0..1]", arrowhead=none];
ConsumerImpl12001400 -> ClientCnx12001400[label="clientCnxUsedForConsumerRegistration
[0..1]"];
ConsumerImpl12001400 -> ConnectionHandler12001400[label="connectionHandler
[0..1]"];
ConsumerImpl12001400 -> PersistentAcknowledgmentsGroupingTracker12001400[label="acknowledgmentsGroupingTracker
[0..1]", arrowhead=none];
ConsumerImpl12001400 -> ProducerImpl12001400[arrowhead=none];
ConsumerImpl12001400 -> RawConsumerImpl325194693[arrowhead=none, arrowtail=empty, dir=both];
ConsumerImpl12001400 -> TransactionMetaStoreHandler12001400[arrowhead=none];
ConsumerImpl12001400 -> ZeroQueueConsumerImpl12001400[arrowhead=none, arrowtail=empty, dir=both];
ConsumerStatsRecorderImpl12001400 -> ConsumerBase12001400[label="consumer
[0..1]", arrowhead=none];
ContextImpl1550931773 -> ConsumerBase12001400[label="inputConsumers
[0..*]", arrowhead=none];
ContextImpl1550931773 -> ConsumerBase12001400[label="topicConsumers
[0..*]", arrowhead=none];
DirectProxyHandler79518146 -> AuthData1605686738[label="authenticate() -> of()", arrowhead=none];
DirectProxyHandler79518146 -> AuthenticationAthenz1053578162[arrowhead=none];
DirectProxyHandler79518146 -> AuthenticationBasic1053578162[arrowhead=none];
DirectProxyHandler79518146 -> AuthenticationDataAthenz1053578162[arrowhead=none];
DirectProxyHandler79518146 -> AuthenticationDataBasic1053578162[arrowhead=none];
DirectProxyHandler79518146 -> AuthenticationDataKeyStoreTls1053578162[arrowhead=none];
DirectProxyHandler79518146 -> AuthenticationDataNull1053578162[arrowhead=none];
DirectProxyHandler79518146 -> AuthenticationDataOAuth21149561371[arrowhead=none];
DirectProxyHandler79518146 -> AuthenticationDataTls1053578162[arrowhead=none];
DirectProxyHandler79518146 -> AuthenticationDataToken1053578162[arrowhead=none];
DirectProxyHandler79518146 -> AuthenticationDisabled1053578162[arrowhead=none];
DirectProxyHandler79518146 -> AuthenticationKeyStoreTls1053578162[arrowhead=none];
DirectProxyHandler79518146 -> AuthenticationOAuth21149561371[arrowhead=none];
DirectProxyHandler79518146 -> AuthenticationSasl1053578162[arrowhead=none];
DirectProxyHandler79518146 -> AuthenticationTls1053578162[arrowhead=none];
DirectProxyHandler79518146 -> AuthenticationToken1053578162[arrowhead=none];
DirectProxyHandler79518146 -> ProxyConnection79518146[label="proxyConnection
[0..1]"];
DirectProxyHandler79518146 -> ProxyService79518146[label="service
[0..1]"];
DirectProxyHandler79518146 -> Rate1188434519[label="inboundChannelRequestsRate
[0..1]"];
DirectProxyHandler79518146 -> SaslAuthenticationDataProvider1053578162[arrowhead=none];
DispatchRateLimiter1101090806 -> BrokerService1718290011[label="brokerService
[0..1]"];
DispatchRateLimiter1101090806 -> DispatchRateImpl1043561458[arrowhead=none];
DispatchRateLimiter1101090806 -> DispatchRateImplBuilder811351110[arrowhead=none];
DispatchRateLimiter1101090806 -> PersistentTopic1101090806[label="topic
[0..1]"];
DispatchRateLimiter1101090806 -> RateLimiter1762718902[label="dispatchRateLimiterOnByte
[0..1]"];
DispatchRateLimiter1101090806 -> RateLimiter1762718902[label="dispatchRateLimiterOnMessage
[0..1]"];
EntryFilterWithClassLoader368263718 -> NarClassLoader1605698775[label="classLoader
[0..1]"];
EventLoopUtil343630530 -> NettyFutureUtil343630530[label="shutdownGracefully() -> toCompletableFutureVoid()"];
FileSystemManagedLedgerOffloader1944580565 -> FileStoreBackedReadHandleImpl1944580565[label="readOffloaded() -> open()"];
FileSystemManagedLedgerOffloader1944580565 -> OffloadPoliciesImpl896442176[label="offloadPolicies
[0..1]"];
FilterContext368263718 -> PersistentSubscription1101090806[label="subscription
[0..1]", arrowhead=none];
FunctionAssignmentTailer1316119764 -> ReaderImpl12001400[label="reader
[0..1]", arrowhead=none];
FunctionMetaDataTopicTailer1316119764 -> ReaderImpl12001400[label="reader
[0..1]", arrowhead=none];
FutureUtil1762718902 -> CompletableFutureCancellationHandler1762718902[label="whenCancelledOrTimedOut() -> attachToFuture()"];
GenericSchemaImpl75672144 -> GenericAvroSchema75672144[arrowhead=none, arrowtail=empty, dir=both];
GenericSchemaImpl75672144 -> GenericJsonSchema75672144[arrowhead=none, arrowtail=empty, dir=both];
HandlerState12001400 -> ConsumerBase12001400[arrowhead=none, arrowtail=empty, dir=both];
HandlerState12001400 -> TransactionMetaStoreHandler12001400[arrowhead=none, arrowtail=empty, dir=both];
InMemTransactionMetadataStore1462729559 -> TransactionCoordinatorID923625925[label="tcID
[0..1]"];
InMemTransactionMetadataStore1462729559 -> TransactionMetadataStoreStats1462729559[label="transactionMetadataStoreStats
[0..1]"];
InMemTransactionMetadataStore1462729559 -> TxnID320258398[label="transactions
[0..*]"];
InMemTransactionMetadataStore1462729559 -> TxnMetaImpl1462729559[arrowhead=none];
InMemoryDelayedDeliveryTracker1284485384 -> PersistentDispatcherMultipleConsumers1101090806[label="dispatcher
[0..1]"];
KeySharedMeta297559756 -> IntRange297559756[label="hashRanges
[0..*]"];
KeyValue1828741399 -> AbstractGenericSchema75672144[arrowhead=none];
KeyValue1828741399 -> AbstractSchema1622012615[arrowhead=none];
KeyValue1828741399 -> AutoConsumeSchema1622012615[arrowhead=none];
KeyValue1828741399 -> AutoProduceBytesSchema1622012615[arrowhead=none];
KeyValue1828741399 -> AvroSchema1622012615[label="supportSchemaVersioning() -> supportSchemaVersioning()", arrowhead=none];
KeyValue1828741399 -> ByteBufferSchemaWrapper1184234151[arrowhead=none];
KeyValue1828741399 -> GenericAvroSchema75672144[label="supportSchemaVersioning() -> supportSchemaVersioning()", arrowhead=none];
KeyValue1828741399 -> GenericJsonSchema75672144[label="supportSchemaVersioning() -> supportSchemaVersioning()", arrowhead=none];
KeyValue1828741399 -> GenericProtobufNativeSchema75672144[label="newRecordBuilder() -> newRecordBuilder()", arrowhead=none];
KeyValue1828741399 -> GenericProtobufNativeSchema75672144[label="supportSchemaVersioning() -> supportSchemaVersioning()", arrowhead=none];
KeyValue1828741399 -> GenericSchemaImpl75672144[arrowhead=none];
KeyValue1828741399 -> KafkaSchemaWrappedSchema1867121574[arrowhead=none];
KeyValue1828741399 -> NativeAvroBytesSchema1622012615[arrowhead=none];
KeyValue1828741399 -> SchemaDefinitionBuilderImpl1622012615[arrowhead=none];
KeyValue1828741399 -> SchemaDefinitionImpl1622012615[arrowhead=none];
KeyValue1828741399 -> SerDeSchema1430540343[arrowhead=none];
KeyValue1828741399 -> WrappedVersionedSchema2009232385[label="requireFetchingSchemaInfo() -> requireFetchingSchemaInfo()", arrowhead=none];
KeyValue1828741399 -> noqualifiedname1905501234[label="key
[0..1]"];
KeyValue1828741399 -> noqualifiedname1905501234[label="value
[0..1]"];
KeyValueSchemaCompatibilityCheck445450388 -> AvroSchemaBasedCompatibilityCheck445450388[arrowhead=none];
KeyValueSchemaCompatibilityCheck445450388 -> KeyValueSchemaInfo1622012615[label="decodeKeyValueSchemaData() -> decodeKeyValueSchemaInfo()"];
KeyValueSchemaCompatibilityCheck445450388 -> ProtobufNativeSchemaCompatibilityCheck445450388[arrowhead=none];
KeyValueSchemaImpl1622012615 -> BytesSchema1622012615[label="fetchSchemaIfNeeded() -> of()"];
KeyValueSchemaImpl1622012615 -> BytesSchemaVersion1472480913[label="fetchSchemaIfNeeded() -> of()"];
KeyValueSchemaImpl1622012615 -> MultiVersionSchemaInfoProvider75672144[arrowhead=none];
KeyValueSchemaImpl1622012615 -> PulsarSqlSchemaInfoProvider1649508102[arrowhead=none];
KeyValueSchemaImpl1622012615 -> noqualifiedname1905501234[label="keySchema
[0..1]"];
KeyValueSchemaImpl1622012615 -> noqualifiedname1905501234[label="valueSchema
[0..1]"];
LeaderService1316119764 -> ConsumerImpl12001400[label="consumer
[0..1]"];
LookupProxyHandler79518146 -> BrokerDiscoveryProvider79518146[label="discoveryProvider
[0..1]"];
LookupProxyHandler79518146 -> ProxyConnection79518146[label="proxyConnection
[0..1]"];
LookupProxyHandler79518146 -> TopicName1973581360[label="handlePartitionMetadataResponse() -> get()"];
MLTransactionLogImpl1462729559 -> ManagedCursorImpl997059435[arrowhead=none];
MLTransactionLogImpl1462729559 -> ManagedLedgerConfig359962201[label="managedLedgerConfig
[0..1]"];
MLTransactionLogImpl1462729559 -> ManagedLedgerFactoryImpl997059435[arrowhead=none];
MLTransactionLogImpl1462729559 -> ManagedLedgerImpl997059435[arrowhead=none];
MLTransactionLogImpl1462729559 -> TopicName1973581360[label="topicName
[0..1]"];
MLTransactionLogImpl1462729559 -> TransactionLogReplayer389689066[label="replayAsync() -> start()"];
MLTransactionLogImpl1462729559 -> TransactionMetadataEntry1906636927[label="append() -> writeTo()"];
MLTransactionMetadataStore1462729559 -> FutureUtil1762718902[label="closeAsync() -> failedFuture()"];
MLTransactionMetadataStore1462729559 -> InMemTransactionMetadataStore1462729559[arrowhead=none];
MLTransactionMetadataStore1462729559 -> MLTransactionLogImpl1462729559[label="transactionLog
[0..1]"];
MLTransactionMetadataStore1462729559 -> MLTransactionSequenceIdGenerator1462729559[label="sequenceIdGenerator
[0..1]"];
MLTransactionMetadataStore1462729559 -> TransactionCoordinatorID923625925[label="tcID
[0..1]"];
MLTransactionMetadataStore1462729559 -> TransactionMetadataStoreStats1462729559[label="transactionMetadataStoreStats
[0..1]"];
MLTransactionMetadataStore1462729559 -> TransactionSubscription923625925[label="subscriptionToTxnSubscription() -> builder()"];
MLTransactionMetadataStore1462729559 -> TransactionTimeoutTrackerImpl949786377[arrowhead=none];
MLTransactionMetadataStoreProvider1462729559 -> MLTransactionLogImpl1462729559[label="openStore() -> initialize()"];
MLTransactionSequenceIdGenerator1462729559 -> ManagedLedgerInterceptorImpl1588982040[arrowhead=none];
MLTransactionSequenceIdGenerator1462729559 -> TransactionMetadataEntry1906636927[label="onManagedLedgerLastLedgerInitialize() -> parseFrom()"];
ManagedCursorImpl997059435 -> BatchedEntryDeletionIndexInfo1682746216[label="buildBatchEntryDeletionIndexInfoList() -> newBuilder()"];
ManagedCursorImpl997059435 -> BitSetRecyclable201476337[label="batchDeletedIndexes
[0..*]"];
ManagedCursorImpl997059435 -> CloseFuture1733299833[arrowhead=none];
ManagedCursorImpl997059435 -> ConcurrentOpenLongPairRangeSet201476337[arrowhead=none];
ManagedCursorImpl997059435 -> DefaultRangeSet623349000[arrowhead=none];
ManagedCursorImpl997059435 -> FillEntryQueueCallback534259052[arrowhead=none];
ManagedCursorImpl997059435 -> LedgerMetadataUtils997059435[label="createNewMetadataLedger() -> buildAdditionalMetadataForCursor()"];
ManagedCursorImpl997059435 -> LongProperty1682746216[label="buildPropertiesMap() -> newBuilder()"];
ManagedCursorImpl997059435 -> ManagedCursorMXBeanImpl997059435[arrowhead=none];
ManagedCursorImpl997059435 -> ManagedLedgerConfig359962201[label="config
[0..1]"];
ManagedCursorImpl997059435 -> ManagedLedgerImpl997059435[label="ledger
[0..1]"];
ManagedCursorImpl997059435 -> ManagedLedgerMBeanImpl997059435[arrowhead=none];
ManagedCursorImpl997059435 -> MarkDeleteEntry1810717276[label="lastMarkDeleteEntry
[0..1]"];
ManagedCursorImpl997059435 -> MarkDeleteEntry1810717276[label="pendingMarkDeleteOps
[0..*]"];
ManagedCursorImpl997059435 -> MessageRange1682746216[label="buildIndividualDeletedMessageRanges() -> newBuilder()"];
ManagedCursorImpl997059435 -> MetaStoreImpl997059435[arrowhead=none];
ManagedCursorImpl997059435 -> NonDurableCursorImpl997059435[arrowhead=none, arrowtail=empty, dir=both];
ManagedCursorImpl997059435 -> OpFindNewest997059435[label="asyncFindNewestMatching() -> find()"];
ManagedCursorImpl997059435 -> OpReadEntry997059435[arrowhead=none];
ManagedCursorImpl997059435 -> PersistentDispatcherMultipleConsumers1101090806[arrowhead=none];
ManagedCursorImpl997059435 -> PersistentDispatcherSingleActiveConsumer1101090806[arrowhead=none];
ManagedCursorImpl997059435 -> PersistentMessageExpiryMonitor1101090806[arrowhead=none];
ManagedCursorImpl997059435 -> PersistentMessageFinder1101090806[arrowhead=none];
ManagedCursorImpl997059435 -> PersistentReplicator1101090806[arrowhead=none];
ManagedCursorImpl997059435 -> PositionImpl997059435[arrowhead=none];
ManagedCursorImpl997059435 -> PositionImplRecyclable997059435[arrowhead=none];
ManagedCursorImpl997059435 -> ReadEntries672467156[arrowhead=none];
ManagedCursorImpl997059435 -> ReadEntryCallbackWrapper2079345937[arrowhead=none];
ManagedCursorImpl997059435 -> ReadOnlyCursorImpl997059435[arrowhead=none, arrowtail=empty, dir=both];
ManagedCursorImpl997059435 -> Stat845397418[label="cursorLedgerStat
[0..1]"];
ManagedCursorImpl997059435 -> StreamingEntryReader679526921[arrowhead=none];
ManagedLedgerFactoryImpl997059435 -> DefaultBkFactory1746234011[arrowhead=none];
ManagedLedgerFactoryImpl997059435 -> EntryCacheManager997059435[label="entryCacheManager
[0..1]"];
ManagedLedgerFactoryImpl997059435 -> FutureUtil1762718902[label="shutdownAsync() -> waitForAll()"];
ManagedLedgerFactoryImpl997059435 -> LocalMemoryMetadataStore437280412[arrowhead=none];
ManagedLedgerFactoryImpl997059435 -> ManagedCursorImpl997059435[label="flushCursors() -> flush()"];
ManagedLedgerFactoryImpl997059435 -> ManagedLedgerException359962201[label="asyncGetManagedLedgerInfo() -> getManagedLedgerException()"];
ManagedLedgerFactoryImpl997059435 -> ManagedLedgerFactoryConfig359962201[label="config
[0..1]"];
ManagedLedgerFactoryImpl997059435 -> ManagedLedgerFactoryMBeanImpl997059435[label="mbean
[0..1]"];
ManagedLedgerFactoryImpl997059435 -> ManagedLedgerImpl997059435[label="ledgers
[0..*]"];
ManagedLedgerFactoryImpl997059435 -> ManagedLedgerMBeanImpl997059435[label="refreshStats() -> refreshStats()"];
ManagedLedgerFactoryImpl997059435 -> MetadataStoreFactoryImpl437280412[label="create() -> createExtended()", arrowhead=none];
ManagedLedgerFactoryImpl997059435 -> PendingInitializeManagedLedger1746234011[label="pendingInitializeLedgers
[0..*]"];
ManagedLedgerFactoryImpl997059435 -> ReadOnlyManagedLedgerImpl997059435[label="asyncOpenReadOnlyCursor() -> initializeAndCreateCursor()"];
ManagedLedgerFactoryImpl997059435 -> ZKMetadataStore437280412[arrowhead=none];
ManagedLedgerImpl997059435 -> OpAddEntry997059435[label="pendingAddEntries
[0..*]"];
ManagedLedgerOfflineBacklog997059435 -> Errors996695433[label="readLedgerMeta() -> isNoSuchLedgerExistsException()"];
ManagedLedgerOfflineBacklog997059435 -> LedgerInfo912267968[label="readLedgerMeta() -> newBuilder()"];
ManagedLedgerOfflineBacklog997059435 -> TopicName1973581360[label="getEstimatedUnloadedTopicBacklog() -> get()"];
MessageDeduplication1101090806 -> PersistentTopic1101090806[label="topic
[0..1]"];
MessageIdImpl12001400 -> BatchMessageIdImpl12001400[arrowhead=none, arrowtail=empty, dir=both];
MessageIdImpl12001400 -> ChunkMessageIdImpl12001400[arrowhead=none, arrowtail=empty, dir=both];
MessageImpl12001400 -> ClientCnx12001400[label="cnx
[0..1]"];
MessageMetadata297559756 -> EncryptionKeys297559756[label="encryptionKeys
[0..*]"];
MessageMetadata297559756 -> KeyValue297559756[label="properties
[0..*]"];
MessageMetadata297559756 -> StringHolder1726850686[label="replicateTos
[0..*]"];
MessagePayloadContextImpl12001400 -> ConsumerImpl12001400[label="consumer
[0..1]"];
MessagePublishContext1660348955 -> Producer1718290011[label="producer
[0..1]"];
MessagePublishContext1660348955 -> ReplicatedSubscriptionsController1101090806[arrowhead=none];
MessagePublishContext1660348955 -> RestMessagePublishContext763407854[arrowhead=none];
MessagesImpl12001400 -> TopicMessageImpl12001400[label="messageList
[0..*]", arrowhead=none];
MultiConsumerPulsarSource1430540343 -> ConsumerBase12001400[label="inputConsumers
[0..*]", arrowhead=none];
MultiTopicsConsumerImpl12001400 -> ConsumerImpl12001400[label="consumers
[0..*]"];
MultiTopicsConsumerImpl12001400 -> ConsumerImpl12001400[label="pausedConsumers
[0..*]"];
NamespaceBundleFactory1973581360 -> Backoff12001400[label="handleLoadBundlesRetry() -> next()"];
NamespaceBundleFactory1973581360 -> BundlesDataImpl1043561458[arrowhead=none];
NamespaceBundleFactory1973581360 -> MetadataCacheImpl738260656[arrowhead=none];
NamespaceBundleFactory1973581360 -> ModularLoadManagerImpl109292786[arrowhead=none];
NamespaceBundleFactory1973581360 -> NamespaceBundles1973581360[label="bundlesCache
[0..1]"];
NamespaceBundleFactory1973581360 -> NamespaceName1973581360[label="bundlesCache
[0..1]"];
NamespaceBundleFactory1973581360 -> NamespaceResources220376139[label="copyToLocalPolicies() -> getPoliciesAsync()"];
NamespaceBundleFactory1973581360 -> Policies896442176[label="policiesCache
[0..1]"];
NamespaceBundleFactory1973581360 -> PulsarService724302956[label="pulsar
[0..1]"];
NamespaceBundleFactory1973581360 -> TopicName1973581360[label="getBundleWithHighestTopicsAsync() -> get()"];
NamespaceBundleFactory1973581360 -> TopicResources220376139[label="getBundleWithHighestTopicsAsync() -> listPersistentTopicsAsync()"];
NamespacesImpl1292556772 -> BundlesDataImplBuilder1326424635[arrowhead=none];
NamespacesImpl1292556772 -> WebTargets1292556772[label="namespacePath() -> addParts()"];
NativeAvroBytesSchema1622012615 -> noqualifiedname1905501234[label="schema
[0..1]"];
NegativeAcksTracker12001400 -> ConsumerBase12001400[label="consumer
[0..1]"];
NonPersistentDispatcherMultipleConsumers442146095 -> PersistentSubscription1101090806[label="subscription
[0..1]", arrowhead=none];
NonPersistentDispatcherSingleActiveConsumer442146095 -> PersistentSubscription1101090806[label="subscription
[0..1]", arrowhead=none];
NonPersistentPartitionedTopicStatsImpl2018762865 -> NonPersistentTopicStatsImpl2018762865[label="partitions
[0..*]"];
NonPersistentPartitionedTopicStatsImpl2018762865 -> PartitionedTopicMetadata21576542[label="metadata
[0..1]"];
NonPersistentReplicator442146095 -> Backoff12001400[label="readEntries() -> reset()"];
NonPersistentReplicator442146095 -> NonPersistentReplicatorStatsImpl2018762865[label="stats
[0..1]"];
NonPersistentReplicator442146095 -> ProducerImpl12001400[label="sendMessage() -> sendAsync()"];
NonPersistentReplicator442146095 -> ProducerSendCallback842869190[label="sendMessage() -> create()"];
NonPersistentReplicator442146095 -> Rate1188434519[label="msgDrop
[0..1]"];
NonPersistentReplicator442146095 -> Rate1188434519[label="msgOut
[0..1]"];
NonPersistentSubscription442146095 -> NonPersistentStickyKeyDispatcherMultipleConsumers442146095[label="addConsumer() -> hasSameKeySharedPolicy()"];
NonPersistentSubscription442146095 -> NonPersistentTopic442146095[label="topic
[0..1]"];
NonPersistentSubscription442146095 -> PersistentDispatcherMultipleConsumers1101090806[label="dispatcher
[0..1]", arrowhead=none];
NonPersistentSubscription442146095 -> TopicName1973581360[label="addConsumer() -> getPartitionIndex()"];
NonPersistentTopicStatsImpl2018762865 -> NonPersistentPartitionedTopicStatsImpl2018762865[arrowhead=none, arrowtail=empty, dir=both];
NonPersistentTopicStatsImpl2018762865 -> NonPersistentPublisherStatsImpl2018762865[arrowhead=none];
NonPersistentTopicStatsImpl2018762865 -> PublisherStatsImpl2018762865[arrowhead=none];
NonPersistentTopicStatsImpl2018762865 -> ReplicatorStatsImpl2018762865[label="replication
[0..*]"];
NonPersistentTopicStatsImpl2018762865 -> SubscriptionStatsImpl2018762865[label="subscriptions
[0..*]"];
NonPersistentTopics620988779 -> BrokerService1718290011[label="getTopicReference() -> getTopicIfExists()"];
NonPersistentTopics620988779 -> NonPersistentTopic442146095[label="getStats() -> getStats()"];
NonPersistentTopics620988779 -> NonPersistentTopicStatsImpl2018762865[label="getPartitionedStats() -> add()"];
NonPersistentTopics620988779 -> PartitionedTopicResources2098679213[label="getPartitionedStats() -> partitionedTopicExists()"];
NonPersistentTopics620988779 -> PersistentTopicsBase229910521[label="unloadTopic() -> internalUnloadTopic()"];
NonPersistentTopics620988780 -> NamespaceBundle1973581360[label="getListFromBundle() -> includes()"];
NonPersistentTopics620988780 -> NonPersistentTopicsImpl1292556772[arrowhead=none];
NoopLoadManager1871869916 -> LocalBrokerData842356003[label="lockManager
[0..1]"];
NoopLoadManager1871869916 -> MetadataStoreException845397418[label="start() -> unwrap()"];
NoopLoadManager1871869916 -> PulsarService724302956[label="pulsar
[0..1]"];
OffloadPoliciesImpl896442176 -> ReflectionUtils212457750[label="builder() -> newBuilder()", arrowhead=none];
OpAddEntry997059435 -> PersistentTopic1101090806[label="callback
[0..1]", arrowhead=none];
OpReadEntry997059435 -> PersistentDispatcherMultipleConsumers1101090806[label="callback
[0..1]", arrowhead=none];
ParserProxyHandler79518146 -> ProxyService79518146[label="service
[0..1]"];
PartitionedProducerImpl12001400 -> ProducerImpl12001400[label="producers
[0..1]"];
PartitionedTopicResources2098679213 -> Codec1762718902[label="listPartitionedTopicsAsync() -> decode()"];
PartitionedTopicResources2098679213 -> TopicName1973581360[label="listPartitionedTopicsAsync() -> get()"];
PartitionedTopicStatsImpl2018762865 -> PartitionedTopicMetadata21576542[label="metadata
[0..1]"];
PendingAckHandleImpl1598175378 -> PersistentSubscription1101090806[label="persistentSubscription
[0..1]"];
PersistentAcknowledgmentsGroupingTracker12001400 -> ConsumerImpl12001400[label="consumer
[0..1]"];
PersistentAcknowledgmentsGroupingTracker12001400 -> NonPersistentAcknowledgmentGroupingTracker12001400[arrowhead=none];
PersistentDispatcherMultipleConsumers1101090806 -> AbstractBaseDispatcher1718290011[arrowhead=none];
PersistentDispatcherMultipleConsumers1101090806 -> FillEntryQueueCallback534259052[arrowhead=none];
PersistentDispatcherMultipleConsumers1101090806 -> NonPersistentDispatcherMultipleConsumers442146095[arrowhead=none];
PersistentDispatcherMultipleConsumers1101090806 -> NonPersistentDispatcherSingleActiveConsumer442146095[arrowhead=none];
PersistentDispatcherMultipleConsumers1101090806 -> OpReadEntry997059435[arrowhead=none];
PersistentDispatcherMultipleConsumers1101090806 -> PersistentDispatcherSingleActiveConsumer1101090806[arrowhead=none];
PersistentDispatcherMultipleConsumers1101090806 -> PersistentReplicator1101090806[arrowhead=none];
PersistentDispatcherMultipleConsumers1101090806 -> PersistentStickyKeyDispatcherMultipleConsumers1101090806[arrowhead=none, arrowtail=empty, dir=both];
PersistentDispatcherMultipleConsumers1101090806 -> PersistentStreamingDispatcherMultipleConsumers1101090806[arrowhead=none, arrowtail=empty, dir=both];
PersistentDispatcherMultipleConsumers1101090806 -> PersistentStreamingDispatcherSingleActiveConsumer1101090806[arrowhead=none];
PersistentDispatcherMultipleConsumers1101090806 -> PersistentTopic1101090806[label="topic
[0..1]"];
PersistentDispatcherMultipleConsumers1101090806 -> ReadEntries672467156[arrowhead=none];
PersistentDispatcherMultipleConsumers1101090806 -> ReadEntryCallbackWrapper2079345937[arrowhead=none];
PersistentDispatcherSingleActiveConsumer1101090806 -> PersistentTopic1101090806[label="topic
[0..1]"];
PersistentMessageExpiryMonitor1101090806 -> PersistentSubscription1101090806[label="subscription
[0..1]"];
PersistentOfflineTopicStats896442176 -> CursorDetails961700686[label="cursorDetails
[0..*]"];
PersistentOfflineTopicStats896442176 -> LedgerDetails961700686[label="dataLedgerDetails
[0..*]"];
PersistentReplicator1101090806 -> PersistentTopic1101090806[label="topic
[0..1]"];
PersistentSubscription1101090806 -> AbstractBaseDispatcher1718290011[arrowhead=none];
PersistentSubscription1101090806 -> AbstractDispatcherMultipleConsumers1718290011[label="canUnsubscribe() -> canUnsubscribe()", arrowhead=none];
PersistentSubscription1101090806 -> BrokerService1718290011[label="removeConsumer() -> pulsar()"];
PersistentSubscription1101090806 -> CompactedTopicImpl435643328[arrowhead=none];
PersistentSubscription1101090806 -> CompactorSubscription1101090806[arrowhead=none, arrowtail=empty, dir=both];
PersistentSubscription1101090806 -> InMemoryRedeliveryTracker1718290011[arrowhead=none];
PersistentSubscription1101090806 -> ManagedCursorImpl997059435[label="acknowledgeMessage() -> isMessageDeleted()"];
PersistentSubscription1101090806 -> NonPersistentDispatcherSingleActiveConsumer442146095[label="consumerFlow() -> consumerFlow()", arrowhead=none];
PersistentSubscription1101090806 -> NonPersistentSubscription442146095[arrowhead=none];
PersistentSubscription1101090806 -> PendingAckHandleDisabled1598175378[arrowhead=none];
PersistentSubscription1101090806 -> PendingAckHandleImpl1598175378[arrowhead=none];
PersistentSubscription1101090806 -> PersistentDispatcherMultipleConsumers1101090806[arrowhead=none];
PersistentSubscription1101090806 -> PersistentDispatcherMultipleConsumers1101090806[label="dispatcher
[0..1]", arrowhead=none];
PersistentSubscription1101090806 -> PersistentDispatcherSingleActiveConsumer1101090806[arrowhead=none];
PersistentSubscription1101090806 -> PersistentMessageExpiryMonitor1101090806[label="expiryMonitor
[0..1]"];
PersistentSubscription1101090806 -> PersistentMessageFinder1101090806[label="resetCursor() -> findMessages()"];
PersistentSubscription1101090806 -> PersistentStickyKeyDispatcherMultipleConsumers1101090806[label="addConsumer() -> hasSameKeySharedPolicy()"];
PersistentSubscription1101090806 -> PersistentStreamingDispatcherMultipleConsumers1101090806[arrowhead=none];
PersistentSubscription1101090806 -> PersistentStreamingDispatcherSingleActiveConsumer1101090806[arrowhead=none];
PersistentSubscription1101090806 -> PersistentTopic1101090806[label="topic
[0..1]"];
PersistentSubscription1101090806 -> RedeliveryTrackerDisabled1718290011[arrowhead=none];
PersistentSubscription1101090806 -> ReplicatedSubscriptionSnapshotCache1101090806[label="replicatedSubscriptionSnapshotCache
[0..1]"];
PersistentSubscription1101090806 -> ReplicatedSubscriptionsController1101090806[label="acknowledgeMessage() -> localSubscriptionUpdated()"];
PersistentSubscription1101090806 -> ReplicatedSubscriptionsSnapshot297559756[label="processReplicatedSubscriptionSnapshot() -> copyFrom()"];
PersistentSubscription1101090806 -> TopicName1973581360[label="addConsumer() -> getPartitionIndex()"];
PersistentTopic1101090806 -> AbstractTopic1718290011[arrowhead=none];
PersistentTopic1101090806 -> MessageDeduplication1101090806[label="messageDeduplication
[0..1]"];
PersistentTopic1101090806 -> NonPersistentTopic442146095[arrowhead=none];
PersistentTopic1101090806 -> PersistentSubscription1101090806[label="subscriptions
[0..1]"];
PersistentTopic1101090806 -> ReplicatedSubscriptionsController1101090806[label="replicatedSubscriptionsController
[0..1]"];
PersistentTopic1101090806 -> SystemTopic1101090806[arrowhead=none, arrowtail=empty, dir=both];
PersistentTopic1101090806 -> TopicTransactionBuffer1621168036[label="transactionBuffer
[0..1]", arrowhead=none];
PersistentTopics620988779 -> NonPersistentTopics620988779[arrowhead=none, arrowtail=empty, dir=both];
PersistentTopics620988780 -> NonPersistentTopics620988780[arrowhead=none, arrowtail=empty, dir=both];
PersistentTopicsBase229910521 -> AuthorizationService1708110945[label="grantPermissions() -> grantPermissionAsync()"];
PersistentTopicsBase229910521 -> BlobStoreManagedLedgerOffloader381677195[arrowhead=none];
PersistentTopicsBase229910521 -> ClusterResources220376139[label="updatePartitionInOtherCluster() -> getClusterAsync()"];
PersistentTopicsBase229910521 -> CompressionCodecLZ4917667102[arrowhead=none];
PersistentTopicsBase229910521 -> CompressionCodecNone917667102[arrowhead=none];
PersistentTopicsBase229910521 -> CompressionCodecProvider917667102[label="generateResponseWithEntry() -> getCompressionCodec()"];
PersistentTopicsBase229910521 -> CompressionCodecSnappy917667102[arrowhead=none];
PersistentTopicsBase229910521 -> CompressionCodecZLib917667102[arrowhead=none];
PersistentTopicsBase229910521 -> CompressionCodecZstd917667102[arrowhead=none];
PersistentTopicsBase229910521 -> DelayedDeliveryPoliciesImpl1043561458[arrowhead=none];
PersistentTopicsBase229910521 -> DelayedDeliveryPoliciesImplBuilder699932710[arrowhead=none];
PersistentTopicsBase229910521 -> EncryptionKeys297559756[label="generateResponseWithEntry() -> toByteArray()"];
PersistentTopicsBase229910521 -> EventsTopicNames2082884193[label="internalUnloadTopic() -> checkTopicIsTransactionCoordinatorAssign()"];
PersistentTopicsBase229910521 -> FileSystemManagedLedgerOffloader1944580565[arrowhead=none];
PersistentTopicsBase229910521 -> ManagedLedgerOfflineBacklog997059435[label="internalGetBacklog() -> estimateUnloadedTopicBacklog()"];
PersistentTopicsBase229910521 -> MessageImpl12001400[label="internalGetMessageIdByTimestamp() -> isEntryPublishedEarlierThan()"];
PersistentTopicsBase229910521 -> NamespaceBundleFactory1973581360[label="internalGetList() -> getBundle()"];
PersistentTopicsBase229910521 -> NamespaceService839302271[label="internalGetPartitionedMetadata() -> checkTopicExists()"];
PersistentTopicsBase229910521 -> NonPersistentPartitionedTopicStatsImpl2018762865[arrowhead=none];
PersistentTopicsBase229910521 -> NonPersistentSubscriptionStatsImpl2018762865[arrowhead=none];
PersistentTopicsBase229910521 -> NullLedgerOffloader997059435[arrowhead=none];
PersistentTopicsBase229910521 -> OffloadPoliciesImpl896442176[label="internalGetOffloadPolicies() -> mergeConfiguration()"];
PersistentTopicsBase229910521 -> PartitionedTopicStatsImpl2018762865[arrowhead=none];
PersistentTopicsBase229910521 -> PersistentTopics620988779[arrowhead=none, arrowtail=empty, dir=both];
PersistentTopicsBase229910521 -> PersistentTopics620988780[arrowhead=none, arrowtail=empty, dir=both];
PersistentTopicsBase229910521 -> SubscriptionStatsImpl2018762865[arrowhead=none];
PersistentTopicsBase229910521 -> TopicStatsImpl2018762865[arrowhead=none];
PersistentTopicsBase229910521 -> TopicsBase763407854[arrowhead=none, arrowtail=empty, dir=both];
PersistentTopicsBase229910521 -> TopicsImpl1292556772[arrowhead=none];
PersistentTopicsBase229910521 -> TransactionCoordinatorID923625925[label="internalUnloadTransactionCoordinatorAsync() -> get()"];
PersistentTopicsBase229910521 -> TransactionMetadataStoreService724302956[label="internalUnloadTransactionCoordinatorAsync() -> removeTransactionMetadataStore()"];
PrecisPublishLimiter1718290011 -> RateLimiter1762718902[label="topicPublishRateLimiterOnByte
[0..1]"];
PrecisPublishLimiter1718290011 -> RateLimiter1762718902[label="topicPublishRateLimiterOnMessage
[0..1]"];
Producer1718290011 -> PersistentTopic1101090806[label="topic
[0..1]", arrowhead=none];
Producer1718290011 -> ServerCnx1718290011[label="cnx
[0..1]", arrowhead=none];
ProducerBase12001400 -> ProducerImpl12001400[arrowhead=none, arrowtail=empty, dir=both];
ProducerImpl12001400 -> ConnectionHandler12001400[label="connectionHandler
[0..1]"];
ProducerStatsRecorderImpl12001400 -> ProducerImpl12001400[label="producer
[0..1]"];
ProducerV1Impl1051373919 -> ProducerImpl12001400[label="producer
[0..1]"];
ProtobufNativeSchemaDataValidator349782408 -> ProtobufNativeSchemaUtils1622012615[label="validate() -> deserialize()"];
ProtobufNativeSchemaUtils1622012615 -> ProtobufNativeSchemaData1472480913[label="serialize() -> builder()"];
ProxyConnection79518146 -> AuthData1605686738[label="clientAuthData
[0..1]"];
ProxyConnection79518146 -> AuthenticationListState18732099[arrowhead=none];
ProxyConnection79518146 -> AuthenticationService978396142[label="handleConnect() -> getAuthenticationProvider()"];
ProxyConnection79518146 -> BrokerProxyValidator79518146[label="brokerProxyValidator
[0..1]"];
ProxyConnection79518146 -> ClientCnx12001400[label="exceptionCaught() -> isKnownException()"];
ProxyConnection79518146 -> ClientConfigurationData1053524534[label="clientConf
[0..1]"];
ProxyConnection79518146 -> ConnectionPool12001400[label="connectionPool
[0..1]"];
ProxyConnection79518146 -> DirectProxyHandler79518146[label="directProxyHandler
[0..1]"];
ProxyConnection79518146 -> LoadReport842356003[label="getProtocol() -> getProtocol()", arrowhead=none];
ProxyConnection79518146 -> LocalBrokerData842356003[label="getProtocol() -> getProtocol()", arrowhead=none];
ProxyConnection79518146 -> LookupProxyHandler79518146[label="lookupProxyHandler
[0..1]"];
ProxyConnection79518146 -> OneStageAuthenticationState978396142[arrowhead=none];
ProxyConnection79518146 -> ProxyService79518146[label="service
[0..1]"];
ProxyConnection79518146 -> PulsarDecoder1070348832[label="channelRead() -> channelRead()"];
ProxyConnection79518146 -> Rate1188434519[label="channelRead() -> recordEvent()"];
ProxyConnection79518146 -> SaslAuthenticationState978396142[arrowhead=none];
ProxyConnection79518146 -> TokenAuthenticationState588253940[arrowhead=none];
ProxyService79518146 -> ProxyConnection79518146[label="clientCnxs
[0..*]"];
ProxyServiceStarter79518146 -> ProxyService79518146[label="proxyService
[0..1]"];
ProxyStats1244791364 -> ProxyService79518146[label="service
[0..1]"];
PulsarAdminBuilderImpl1292556772 -> ClientConfigurationData1053524534[label="conf
[0..1]"];
PulsarChannelInitializer12001400 -> ClientCnx12001400[label="clientCnxSupplier
[0..1]"];
PulsarChannelInitializer1718290011 -> ServerCnx1718290011[label="connections
[0..1]"];
PulsarClientImpl12001400 -> ConnectionPool12001400[label="cnxPool
[0..1]"];
PulsarClientImpl12001400 -> ConsumerBase12001400[label="consumers
[0..*]"];
PulsarCommandSenderImpl1718290011 -> PositionImpl997059435[label="sendMessagesToConsumer() -> get()"];
PulsarCommandSenderImpl1718290011 -> ServerCnx1718290011[label="cnx
[0..1]"];
PulsarDecoder1070348832 -> BaseCommand297559756[label="cmd
[0..1]"];
PulsarDecoder1070348832 -> ProxyBackendHandler828483243[arrowhead=none, arrowtail=empty, dir=both];
PulsarDecoder1070348832 -> PulsarHandler1070348832[arrowhead=none, arrowtail=empty, dir=both];
PulsarHandler1070348832 -> ClientCnx12001400[arrowhead=none, arrowtail=empty, dir=both];
PulsarHandler1070348832 -> ProxyConnection79518146[arrowhead=none, arrowtail=empty, dir=both];
PulsarHandler1070348832 -> Runnables1762718902[label="channelActive() -> catchingAndLoggingThrowables()"];
PulsarHandler1070348832 -> ServerCnx1718290011[arrowhead=none, arrowtail=empty, dir=both];
PulsarOffsetBackingStore1955210581 -> ReaderImpl12001400[label="reader
[0..1]", arrowhead=none];
PulsarRecord1430540343 -> TopicMessageImpl12001400[label="message
[0..1]", arrowhead=none];
PulsarService724302956 -> BrokerService1718290011[label="brokerService
[0..1]"];
PulsarService724302956 -> TransactionBufferClientImpl1621168036[label="transactionBufferClient
[0..1]", arrowhead=none];
PulsarServiceNameResolver12001400 -> ServiceURI1605698901[label="serviceUri
[0..1]"];
PulsarStats1718290011 -> AbstractTopic1718290011[arrowhead=none];
PulsarStats1718290011 -> BrokerOperabilityMetrics2102807099[label="brokerOperabilityMetrics
[0..1]"];
PulsarStats1718290011 -> ClusterReplicationMetrics2102807099[label="clusterReplicationMetrics
[0..1]"];
PulsarStats1718290011 -> Metrics1188434519[label="metricsCollection
[0..*]"];
PulsarStats1718290011 -> Metrics1188434519[label="tempMetricsCollection
[0..*]"];
PulsarStats1718290011 -> NamespaceBundle1973581360[label="updateStats() -> getBundleRange()"];
PulsarStats1718290011 -> NamespaceBundleStats842356003[label="bundleStats
[0..*]"];
PulsarStats1718290011 -> NamespaceStats2102807099[label="nsStats
[0..1]"];
PulsarStats1718290011 -> NonPersistentTopic442146095[arrowhead=none];
PulsarStats1718290011 -> PersistentTopic1101090806[arrowhead=none];
PulsarStats1718290011 -> PulsarService724302956[label="pulsarService
[0..1]"];
PulsarWebResource2102840826 -> AdminResource2119895947[arrowhead=none, arrowtail=empty, dir=both];
PulsarWebResource2102840826 -> ClustersBase229910521[arrowhead=none, arrowtail=empty, dir=both];
PulsarWebResource2102840826 -> NamespaceBundles1973581360[label="validateNamespaceBundleRange() -> validateBundle()"];
PulsarWebResource2102840826 -> NamespaceName1973581360[label="validateBundleOwnership() -> get()"];
PulsarWebResource2102840826 -> NamespaceResources220376139[label="checkLocalOrGetPeerReplicationCluster() -> getPoliciesAsync()"];
PulsarWebResource2102840826 -> PolicyPath896799675[label="splitPath() -> splitPath()"];
PulsarWebResource2102840826 -> PulsarService724302956[label="pulsar
[0..1]"];
PulsarWebResource2102840826 -> TenantsBase229910521[arrowhead=none, arrowtail=empty, dir=both];
PulsarWebResource2102840826 -> TopicLookupBase967123692[arrowhead=none, arrowtail=empty, dir=both];
PulsarWorkerService1316119764 -> LeaderService1316119764[label="leaderService
[0..1]"];
RateLimiter1762718902 -> Runnables1762718902[label="createTask() -> catchingAndLoggingThrowables()"];
RateLimiterBuilder1999122404 -> ResourceGroupPublishLimiter664401495[arrowhead=none];
RawConsumerImpl325194693 -> RawMessageAndCnx325194693[label="incomingRawMessages
[0..*]"];
RawMessageAndCnx325194693 -> ClientCnx12001400[label="cnx
[0..1]"];
RawReaderImpl12001400 -> RawConsumerImpl325194693[label="consumer
[0..1]"];
ReadEntryCallbackWrapper2079345937 -> PersistentDispatcherMultipleConsumers1101090806[label="readEntriesCallback
[0..1]", arrowhead=none];
ReaderHandler1308078636 -> ReaderImpl12001400[label="reader
[0..1]", arrowhead=none];
ReaderImpl12001400 -> ConsumerImpl12001400[label="consumer
[0..1]"];
ReaderImpl12001400 -> MultiTopicsReaderImpl12001400[arrowhead=none];
ReaderImpl12001400 -> ReaderV1Impl1051373919[arrowhead=none];
ReplicatedSubscriptionsController1101090806 -> PersistentTopic1101090806[label="topic
[0..1]"];
ReplicatedSubscriptionsController1101090806 -> ReplicatedSubscriptionsSnapshotBuilder1101090806[label="pendingSnapshots
[0..*]"];
ReplicatedSubscriptionsSnapshotBuilder1101090806 -> ReplicatedSubscriptionsController1101090806[label="controller
[0..1]"];
ResourceUsageReader498281929 -> ReaderImpl12001400[label="consumer
[0..1]", arrowhead=none];
RestMessagePublishContext763407854 -> MessagePublishContext1660348955[arrowhead=none];
RestMessagePublishContext763407854 -> PersistentTopic1101090806[label="topic
[0..1]", arrowhead=none];
RestMessagePublishContext763407854 -> PositionImpl997059435[label="positionFuture
[0..1]"];
RestMessagePublishContext763407854 -> ReplicatedSubscriptionsController1101090806[arrowhead=none];
RetryUtil11637398 -> Backoff12001400[label="executeWithRetry() -> next()"];
SaslAuthenticationState978396142 -> PulsarSaslServer978396142[label="pulsarSaslServer
[0..1]"];
SaslAuthenticationState978396142 -> SaslAuthenticationDataSource978396142[label="authenticationDataSource
[0..1]"];
SchedulerManager1316119764 -> LeaderService1316119764[label="leaderService
[0..1]"];
SchemaDefinitionBuilderImpl1622012615 -> AbstractMultiVersionReader657740342[arrowhead=none];
SchemaDefinitionBuilderImpl1622012615 -> AvroReader657740342[arrowhead=none];
SchemaDefinitionBuilderImpl1622012615 -> AvroWriter502335110[arrowhead=none];
SchemaDefinitionBuilderImpl1622012615 -> GenericAvroReader75672144[arrowhead=none];
SchemaDefinitionBuilderImpl1622012615 -> GenericAvroWriter75672144[arrowhead=none];
SchemaDefinitionBuilderImpl1622012615 -> GenericJsonReader75672144[arrowhead=none];
SchemaDefinitionBuilderImpl1622012615 -> GenericJsonWriter75672144[arrowhead=none];
SchemaDefinitionBuilderImpl1622012615 -> GenericProtobufNativeReader75672144[arrowhead=none];
SchemaDefinitionBuilderImpl1622012615 -> GenericProtobufNativeWriter75672144[arrowhead=none];
SchemaDefinitionBuilderImpl1622012615 -> JacksonJsonReader657740342[arrowhead=none];
SchemaDefinitionBuilderImpl1622012615 -> JacksonJsonWriter502335110[arrowhead=none];
SchemaDefinitionBuilderImpl1622012615 -> JsonReader657740342[arrowhead=none];
SchemaDefinitionBuilderImpl1622012615 -> JsonWriter502335110[arrowhead=none];
SchemaDefinitionBuilderImpl1622012615 -> MultiVersionGenericProtobufNativeReader75672144[arrowhead=none];
SchemaDefinitionBuilderImpl1622012615 -> ProtobufReader657740342[arrowhead=none];
SchemaDefinitionBuilderImpl1622012615 -> ProtobufWriter502335110[arrowhead=none];
SchemaDefinitionBuilderImpl1622012615 -> noqualifiedname1905501234[label="clazz
[0..1]"];
SchemaDefinitionBuilderImpl1622012615 -> noqualifiedname1905501234[label="reader
[0..1]"];
SchemaDefinitionBuilderImpl1622012615 -> noqualifiedname1905501234[label="writer
[0..1]"];
SchemaDefinitionImpl1622012615 -> noqualifiedname1905501234[label="pojo
[0..1]"];
SchemaDefinitionImpl1622012615 -> noqualifiedname1905501234[label="reader
[0..1]"];
SchemaDefinitionImpl1622012615 -> noqualifiedname1905501234[label="writer
[0..1]"];
SchemaEntry840873545 -> IndexEntry840873545[label="index_
[0..*]"];
SchemaException770960286 -> IncompatibleSchemaException770960286[arrowhead=none, arrowtail=empty, dir=both];
SchemaException770960286 -> InvalidSchemaDataException770960286[arrowhead=none, arrowtail=empty, dir=both];
SchemaInfo1678783339 -> KeyValuePair268846344[label="props_
[0..*]"];
SchemaInfoUtil1622012615 -> Commands1070348832[label="newSchemaInfo() -> getSchemaType()"];
SchemaInfoUtil1622012615 -> Schema297559756[label="newSchemaInfo() -> getPropertyAt()"];
SchemaLocator840873545 -> IndexEntry840873545[label="index_
[0..*]"];
SchemaLocator840873545 -> IndexEntry840873545[label="info_
[0..1]"];
SchemaRegistryServiceImpl445450388 -> BookkeeperSchemaStorage445450388[arrowhead=none];
SchemaRegistryServiceImpl445450388 -> FutureUtil1762718902[label="checkConsumerCompatibility() -> failedFuture()"];
SchemaRegistryServiceImpl445450388 -> KeyValuePair268846344[label="toPairs() -> newBuilder()", arrowhead=none];
SchemaRegistryServiceImpl445450388 -> SchemaData1472480913[label="schemaInfoToSchema() -> builder()", arrowhead=none];
SchemaRegistryServiceWithSchemaDataValidator349782408 -> DefaultSchemaRegistryService445450388[arrowhead=none];
SchemaRegistryServiceWithSchemaDataValidator349782408 -> KeyValueSchemaCompatibilityCheck445450388[label="validateSchemaData() -> decodeKeyValueSchemaData()", arrowhead=none];
SchemaRegistryServiceWithSchemaDataValidator349782408 -> PrimitiveSchemaDataValidator349782408[arrowhead=none];
SchemaRegistryServiceWithSchemaDataValidator349782408 -> ProtobufNativeSchemaDataValidator349782408[arrowhead=none];
SchemaRegistryServiceWithSchemaDataValidator349782408 -> SchemaRegistryServiceImpl445450388[arrowhead=none];
SchemaRegistryServiceWithSchemaDataValidator349782408 -> StringSchemaDataValidator349782408[arrowhead=none];
SchemaRegistryServiceWithSchemaDataValidator349782408 -> StructSchemaDataValidator349782408[arrowhead=none];
SchemaUtils1622012615 -> ObjectMapperFactory1762718902[label="convertKeyValueSchemaInfoDataToString() -> create()"];
Section330549314 -> noqualifiedname1905501234[label="values
[0..*]"];
SerDeSchema1430540343 -> ByteBufferSerDe82010421[arrowhead=none];
SerDeSchema1430540343 -> CustomBaseSerde82010421[arrowhead=none];
SerDeSchema1430540343 -> CustomDerivedSerde82010421[arrowhead=none];
SerDeSchema1430540343 -> CustomObjectSerde1774045186[arrowhead=none];
SerDeSchema1430540343 -> JavaSerDe1955622255[arrowhead=none];
SerDeSchema1430540343 -> noqualifiedname1905501234[label="serDe
[0..1]"];
ServerCnx1718290011 -> BrokerService1718290011[label="service
[0..1]"];
ServerCnx1718290011 -> ClientCnx12001400[label="exceptionCaught() -> isKnownException()"];
ServerCnx1718290011 -> ConcurrentLongHashMap201476337[label="consumers
[0..1]"];
ServerCnx1718290011 -> ConcurrentLongHashMap201476337[label="producers
[0..1]"];
ServerCnx1718290011 -> Consumer1718290011[label="consumers
[0..1]"];
ServerCnx1718290011 -> DefaultConnectionController1434559213[arrowhead=none];
ServerCnx1718290011 -> Exceptions2034047811[label="handleProducer() -> areExceptionsPresentInChain()"];
ServerCnx1718290011 -> FeatureFlags297559756[label="features
[0..1]"];
ServerCnx1718290011 -> KeySharedMeta297559756[label="handleSubscribe() -> copyFrom()"];
ServerCnx1718290011 -> MLTransactionMetadataStore1462729559[label="handleAddSubscriptionToTxn() -> subscriptionToTxnSubscription()"];
ServerCnx1718290011 -> ManagedLedgerImpl997059435[label="getLargestBatchIndexWhenPossible() -> asyncReadEntry()"];
ServerCnx1718290011 -> MessageIdData297559756[label="handleSeek() -> getAckSetAt()"];
ServerCnx1718290011 -> Metadata1973581360[label="handleSubscribe() -> validateMetadata()"];
ServerCnx1718290011 -> NamespaceName1973581360[label="handleGetTopicsOfNamespace() -> get()"];
ServerCnx1718290011 -> NamespaceService839302271[label="handleGetTopicsOfNamespace() -> getListOfTopics()"];
ServerCnx1718290011 -> PersistentTopicsBase229910521[label="handlePartitionMetadataRequest() -> unsafeGetPartitionedTopicMetadataAsync()"];
ServerCnx1718290011 -> PositionImpl997059435[label="getLargestBatchIndexWhenPossible() -> compareTo()"];
ServerCnx1718290011 -> Producer1718290011[label="producers
[0..1]"];
ServerCnx1718290011 -> PulsarCommandSenderImpl1718290011[arrowhead=none];
ServerCnx1718290011 -> PulsarCommandSenderImpl1718290011[label="commandSender
[0..1]", arrowhead=none];
ServerCnx1718290011 -> SchemaData1472480913[label="getSchema() -> builder()"];
ServerCnx1718290011 -> SchemaInfoUtil1622012615[label="handleGetSchema() -> newSchemaInfo()"];
ServerCnx1718290011 -> TopicLookupBase967123692[label="handleLookup() -> lookupTopicAsync()"];
ServiceChannelInitializer79518146 -> ProxyService79518146[label="proxyService
[0..1]"];
SimpleLoadManagerImpl109292786 -> ConcurrentOpenHashMap201476337[label="brokerToNamespaceToBundleRange
[0..1]"];
SimpleLoadManagerImpl109292786 -> ConcurrentOpenHashSet201476337[label="brokerToNamespaceToBundleRange
[0..1]"];
SimpleLoadManagerImpl109292786 -> CoordinationServiceImpl1394915087[arrowhead=none];
SimpleLoadManagerImpl109292786 -> DefaultImplementation212457750[label="builder() -> newAdminClientBuilder()", arrowhead=none];
SimpleLoadManagerImpl109292786 -> GenericBrokerHostUsageImpl109292786[arrowhead=none];
SimpleLoadManagerImpl109292786 -> LinuxBrokerHostUsageImpl109292786[arrowhead=none];
SimpleLoadManagerImpl109292786 -> LoadReport842356003[label="brokerLock
[0..1]"];
SimpleLoadManagerImpl109292786 -> LoadReport842356003[label="currentLoadReports
[0..*]"];
SimpleLoadManagerImpl109292786 -> LoadReport842356003[label="lastLoadReport
[0..1]"];
SimpleLoadManagerImpl109292786 -> LoadReport842356003[label="loadReports
[0..1]"];
SimpleLoadManagerImpl109292786 -> LockManagerImpl1394915087[arrowhead=none];
SimpleLoadManagerImpl109292786 -> Metrics1188434519[label="loadBalancingMetrics
[0..1]"];
SimpleLoadManagerImpl109292786 -> NamespaceService839302271[label="doNamespaceBundleSplit() -> getBundleCount()"];
SimpleLoadManagerImpl109292786 -> PulsarAdminImpl1292556772[arrowhead=none];
SimpleLoadManagerImpl109292786 -> PulsarService724302956[label="pulsar
[0..1]"];
SimpleLoadManagerImpl109292786 -> ResourceLockImpl1394915087[arrowhead=none];
SimpleLoadManagerImpl109292786 -> ResourceQuota896442176[label="realtimeAvgResourceQuota
[0..1]"];
SimpleLoadManagerImpl109292786 -> ResourceQuota896442176[label="realtimeResourceQuotas
[0..1]"];
SimpleLoadManagerImpl109292786 -> ResourceUnitRanking842356003[label="resourceUnitRankings
[0..*]"];
SimpleLoadManagerImpl109292786 -> SimpleResourceAllocationPolicies109292786[label="policies
[0..1]"];
SimpleLoadManagerImpl109292786 -> SimpleResourceUnit109292786[arrowhead=none];
SimpleLoadManagerImpl109292786 -> WRRPlacementStrategy109292786[arrowhead=none];
SingleConsumerPulsarSource1430540343 -> ConsumerBase12001400[label="consumer
[0..1]", arrowhead=none];
SingleConsumerPulsarSource1430540343 -> ConsumerBase12001400[label="inputConsumers
[0..*]", arrowhead=none];
SingleMessageMetadata297559756 -> KeyValue297559756[label="properties
[0..*]"];
StreamingEntryReader679526921 -> PersistentDispatcherMultipleConsumers1101090806[label="dispatcher
[0..1]", arrowhead=none];
StreamingEntryReader679526921 -> PersistentTopic1101090806[label="topic
[0..1]"];
SubscribeRateLimiter1101090806 -> BrokerService1718290011[label="brokerService
[0..1]"];
SubscriptionOption1718290011 -> ChunkMessageIdImpl12001400[arrowhead=none];
SubscriptionOption1718290011 -> KeySharedMeta297559756[label="keySharedMeta
[0..1]"];
SubscriptionOption1718290011 -> MessageIdImpl12001400[arrowhead=none];
SubscriptionOption1718290011 -> MultiMessageIdImpl12001400[arrowhead=none];
SubscriptionOption1718290011 -> ServerCnx1718290011[arrowhead=none];
SubscriptionOption1718290011 -> TopicMessageIdImpl12001400[arrowhead=none];
Summary1852472696 -> Child1346619936[label="observe() -> observe()"];
SystemTopicBasedTopicPoliciesService1718290011 -> AbstractTopic1718290011[arrowhead=none];
SystemTopicBasedTopicPoliciesService1718290011 -> AbstractTopic1718290011[label="listeners
[0..*]", arrowhead=none];
SystemTopicBasedTopicPoliciesService1718290011 -> MessageImpl12001400[arrowhead=none];
SystemTopicBasedTopicPoliciesService1718290011 -> NamespaceEventsSystemTopicFactory1970406500[label="namespaceEventsSystemTopicFactory
[0..1]"];
SystemTopicBasedTopicPoliciesService1718290011 -> NamespaceName1973581360[label="ownedBundlesCountPerNamespace
[0..*]"];
SystemTopicBasedTopicPoliciesService1718290011 -> NamespaceName1973581360[label="policyCacheInitMap
[0..*]"];
SystemTopicBasedTopicPoliciesService1718290011 -> NamespaceName1973581360[label="readerCaches
[0..*]"];
SystemTopicBasedTopicPoliciesService1718290011 -> NonPersistentTopic442146095[arrowhead=none];
SystemTopicBasedTopicPoliciesService1718290011 -> PersistentTopic1101090806[label="onUpdate() -> onUpdate()", arrowhead=none];
SystemTopicBasedTopicPoliciesService1718290011 -> PulsarEvent2082884193[label="readerCaches
[0..*]"];
SystemTopicBasedTopicPoliciesService1718290011 -> PulsarService724302956[label="pulsarService
[0..1]"];
SystemTopicBasedTopicPoliciesService1718290011 -> RetryUtil11637398[label="createSystemTopicClientWithRetry() -> retryAsynchronously()"];
SystemTopicBasedTopicPoliciesService1718290011 -> TopicMessageImpl12001400[arrowhead=none];
SystemTopicBasedTopicPoliciesService1718290011 -> TopicName1973581360[label="globalPoliciesCache
[0..*]"];
SystemTopicBasedTopicPoliciesService1718290011 -> TopicName1973581360[label="listeners
[0..*]"];
SystemTopicBasedTopicPoliciesService1718290011 -> TopicName1973581360[label="policiesCache
[0..*]"];
SystemTopicBasedTopicPoliciesService1718290011 -> TopicPolicies896442176[label="globalPoliciesCache
[0..*]"];
SystemTopicBasedTopicPoliciesService1718290011 -> TopicPolicies896442176[label="listeners
[0..*]"];
SystemTopicBasedTopicPoliciesService1718290011 -> TopicPolicies896442176[label="policiesCache
[0..*]"];
SystemTopicBasedTopicPoliciesService1718290011 -> TopicPoliciesEvent2082884193[label="getPulsarEvent() -> builder()"];
SystemTopicClientBase1970406500 -> FutureUtil1762718902[label="closeAsync() -> waitForAll()"];
SystemTopicClientBase1970406500 -> PulsarClientImpl12001400[arrowhead=none];
SystemTopicClientBase1970406500 -> PulsarClientImplementationBindingImpl12001400[arrowhead=none];
SystemTopicClientBase1970406500 -> PulsarClientV1Impl1051373919[arrowhead=none];
SystemTopicClientBase1970406500 -> TopicName1973581360[label="topicName
[0..1]"];
SystemTopicClientBase1970406500 -> TopicPoliciesSystemTopicClient1970406500[arrowhead=none, arrowtail=empty, dir=both];
SystemTopicClientBase1970406500 -> TopicPolicyReader1851406594[arrowhead=none];
SystemTopicClientBase1970406500 -> TopicPolicyWriter1851406594[arrowhead=none];
SystemTopicClientBase1970406500 -> TransactionBufferSnapshotReader1252191935[arrowhead=none];
SystemTopicClientBase1970406500 -> TransactionBufferSnapshotWriter1252191935[arrowhead=none];
SystemTopicClientBase1970406500 -> TransactionBufferSystemTopicClient1970406500[arrowhead=none, arrowtail=empty, dir=both];
SystemTopicClientBase1970406500 -> noqualifiedname1905501234[label="readers
[0..*]"];
SystemTopicClientBase1970406500 -> noqualifiedname1905501234[label="writers
[0..*]"];
TableViewImpl12001400 -> ReaderImpl12001400[label="readers
[0..*]", arrowhead=none];
TenantsBase229910521 -> ClusterResources220376139[label="validateClusters() -> list()"];
TenantsBase229910521 -> FutureUtil1762718902[label="internalDeleteTenantForcefully() -> waitForAll()"];
TenantsBase229910521 -> LocalPoliciesResources220376139[label="internalDeleteTenant() -> deleteLocalPoliciesTenantAsync()"];
TenantsBase229910521 -> NamedEntity1973581360[label="createTenant() -> checkName()"];
TenantsBase229910521 -> PartitionedTopicResources2098679213[label="internalDeleteTenant() -> clearPartitionedTopicTenantAsync()"];
TenantsBase229910521 -> Properties620988780[arrowhead=none, arrowtail=empty, dir=both];
TenantsBase229910521 -> Tenants620988779[arrowhead=none, arrowtail=empty, dir=both];
TenantsBase229910521 -> TopicResources220376139[label="internalDeleteTenant() -> clearTenantPersistence()"];
TokenAuthenticationState588253940 -> AuthenticationDataCommand978396142[arrowhead=none];
TokenAuthenticationState588253940 -> AuthenticationDataHttp978396142[arrowhead=none];
TokenAuthenticationState588253940 -> AuthenticationProviderToken978396142[label="provider
[0..1]"];
TokenAuthenticationState588253940 -> SaslAuthenticationDataSource978396142[arrowhead=none];
TopicLoadingContext704824873 -> PersistentTopic1101090806[label="topicFuture
[0..1]", arrowhead=none];
TopicLookupBase967123692 -> BrokerService1718290011[label="internalLookupTopicAsync() -> isAllowAutoTopicCreation()"];
TopicLookupBase967123692 -> TopicLookup941238890[arrowhead=none, arrowtail=empty, dir=both];
TopicMessageImpl12001400 -> ConsumerImpl12001400[label="receivedByconsumer
[0..1]"];
TopicMessageImpl12001400 -> MessageImpl12001400[arrowhead=none];
TopicName1973581360 -> NamespaceBundle1973581360[arrowhead=none];
TopicName1973581360 -> NamespaceName1973581360[arrowhead=none];
TopicPolicyReader1851406594 -> ReaderImpl12001400[label="reader
[0..1]", arrowhead=none];
TopicResources220376139 -> TopicName1973581360[label="listPersistentTopicsAsync() -> get()"];
TopicStatsImpl2018762865 -> NonPersistentTopicStatsImpl2018762865[arrowhead=none, arrowtail=empty, dir=both];
TopicStatsImpl2018762865 -> PartitionedTopicStatsImpl2018762865[arrowhead=none, arrowtail=empty, dir=both];
TopicTransactionBuffer1621168036 -> InMemTransactionBuffer1621168036[arrowhead=none];
TopicTransactionBuffer1621168036 -> PersistentTopic1101090806[label="topic
[0..1]"];
TopicTransactionBuffer1621168036 -> TransactionBufferDisable1621168036[arrowhead=none];
TopicTransactionBufferRecover230463737 -> PersistentTopic1101090806[label="topic
[0..1]"];
TopicTransactionBufferRecover230463737 -> TopicTransactionBuffer1621168036[label="topicTransactionBuffer
[0..1]"];
TopicTransactionBufferState1621168036 -> TopicTransactionBuffer1621168036[arrowhead=none, arrowtail=empty, dir=both];
TopicsBase763407854 -> AdminResource2119895947[label="messageToByteBuf() -> checkArgument()"];
TopicsBase763407854 -> AuthorizationService1708110945[label="validateProducePermission() -> canProduce()"];
TopicsBase763407854 -> Commands1070348832[label="messageToByteBuf() -> serializeMetadataAndPayload()"];
TopicsBase763407854 -> CompressionCodecProvider917667102[label="messageToByteBuf() -> convertToWireProtocol()"];
TopicsBase763407854 -> GenericAvroWriter75672144[label="encodeWithSchema() -> write()"];
TopicsBase763407854 -> GenericJsonWriter75672144[label="encodeWithSchema() -> write()"];
TopicsBase763407854 -> KeyValueSchemaInfo1622012615[label="getSchemaData() -> encodeKeyValueSchemaInfo()"];
TopicsBase763407854 -> LookupOptions839302271[label="lookUpBrokerForTopic() -> builder()"];
TopicsBase763407854 -> NamespaceService839302271[label="lookUpBrokerForTopic() -> getBrokerServiceUrlAsync()"];
TopicsBase763407854 -> RestMessagePublishContext763407854[label="publishSingleMessageToPartition() -> get()"];
TopicsBase763407854 -> StringSchema1622012615[label="getSchemaData() -> utf8()"];
TopicsBase763407854 -> Topics763407854[arrowhead=none, arrowtail=empty, dir=both];
TopicsImpl1292556772 -> Commands1070348832[label="getIndividualMsgsFromBatch() -> deSerializeSingleMessageInBatch()"];
TopicsImpl1292556772 -> EncryptionKeys297559756[label="getMessagesFromHttpResponse() -> parseFrom()"];
TradeUnit1840568558 -> ConsumerBase12001400[label="consumerFuture
[0..1]", arrowhead=none];
TransactionBufferClientImpl1621168036 -> TransactionBufferHandlerImpl1621168036[arrowhead=none];
TransactionBufferClientImpl1621168036 -> TransactionBufferHandlerImpl1621168036[label="tbHandler
[0..1]", arrowhead=none];
TransactionBufferHandlerImpl1621168036 -> ClientCnx12001400[label="cache
[0..1]"];
TransactionBufferHandlerImpl1621168036 -> OpRequestSend934907670[label="pendingRequests
[0..*]"];
TransactionBufferHandlerImpl1621168036 -> PulsarClientImpl12001400[label="getClientCnx() -> getConnection()"];
TransactionBufferSnapshotReader1252191935 -> ReaderImpl12001400[label="reader
[0..1]", arrowhead=none];
TransactionCoordinatorClientImpl219831672 -> TransactionMetaStoreHandler12001400[label="handlerMap
[0..1]"];
TransactionCoordinatorClientImpl219831672 -> TransactionMetaStoreHandler12001400[label="handlers
[0..*]"];
TransactionImpl219831672 -> ConsumerImpl12001400[label="cumulativeAckConsumers
[0..*]"];
TransactionLogReplayer389689066 -> EntryImpl997059435[arrowhead=none];
TransactionLogReplayer389689066 -> FillEntryQueueCallback389689066[label="fillEntryQueueCallback
[0..1]"];
TransactionLogReplayer389689066 -> TransactionEntryImpl1621168036[label="release() -> release()", arrowhead=none];
TransactionLogReplayer389689066 -> TransactionMetadataEntry1906636927[label="start() -> parseFrom()"];
TransactionMetaStoreHandler12001400 -> ConnectionHandler12001400[label="connectionHandler
[0..1]"];
TransactionMetadataEntry1906636927 -> StringHolder964745931[label="partitions
[0..*]"];
TransactionMetadataEntry1906636927 -> Subscription297559756[label="subscriptions
[0..*]"];
TransactionMetadataStoreService724302956 -> ConcurrentLongHashMap201476337[label="pendingConnectRequests
[0..1]"];
TransactionMetadataStoreService724302956 -> ConcurrentLongHashMap201476337[label="tcLoadSemaphores
[0..1]"];
TransactionMetadataStoreService724302956 -> InMemTransactionMetadataStoreProvider1462729559[arrowhead=none];
TransactionMetadataStoreService724302956 -> MLTransactionLogImpl1462729559[label="openTransactionMetadataStore() -> getMLTransactionLogName()"];
TransactionMetadataStoreService724302956 -> MLTransactionMetadataStoreProvider1462729559[arrowhead=none];
TransactionMetadataStoreService724302956 -> PulsarService724302956[label="pulsarService
[0..1]"];
TransactionMetadataStoreService724302956 -> TransactionBufferClientImpl1621168036[arrowhead=none];
TransactionMetadataStoreService724302956 -> TransactionBufferClientImpl1621168036[label="tbClient
[0..1]", arrowhead=none];
TransactionMetadataStoreService724302956 -> TransactionCoordinatorID923625925[label="stores
[0..*]"];
TransactionMetadataStoreService724302956 -> TransactionTimeoutTrackerFactoryImpl949786377[arrowhead=none];
TransactionMetadataStoreState923625925 -> MLTransactionMetadataStore1462729559[arrowhead=none, arrowtail=empty, dir=both];
TransactionMetadataStoreStats1462729559 -> StatsBuckets996695433[label="executionLatencyBuckets
[0..1]"];
TransactionTimeoutTrackerFactoryImpl949786377 -> TransactionMetadataStoreService724302956[label="transactionMetadataStoreService
[0..1]"];
TransactionTimeoutTrackerImpl949786377 -> TransactionMetadataStoreService724302956[label="transactionMetadataStoreService
[0..1]"];
TransactionTimeoutTrackerImpl949786377 -> TripleLongPriorityQueue201476337[label="priorityQueue
[0..1]"];
TxnMetaImpl1462729559 -> TransactionSubscription923625925[label="ackedPartitions
[0..*]"];
TxnMetaImpl1462729559 -> TransactionUtil1462365557[label="updateTxnStatus() -> canTransitionTo()"];
TxnMetaImpl1462729559 -> TxnID320258398[label="txnID
[0..1]"];
TypedMessageBuilderImpl12001400 -> TransactionImpl219831672[label="txn
[0..1]"];
WorkerStatsManager1316119764 -> LeaderService1316119764[label="leaderService
[0..1]"];
WrappedVersionedSchema2009232385 -> AbstractStructSchema1622012615[label="parent
[0..1]"];
WrappedVersionedSchema2009232385 -> noqualifiedname1905501234[label="parent
[0..1]"];
WriteInEventLoopCallback1331407256 -> ClientCnx12001400[label="cnx
[0..1]"];
WriteInEventLoopCallback1331407256 -> ProducerImpl12001400[label="producer
[0..1]"];
    
}
@enduml